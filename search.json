[{"title":"事件系统","url":"/2020/07/20/xys-5.2/","content":"# [UnityAction](https://docs.unity3d.com/ScriptReference/Events.UnityAction.html) 和 [UnityEvent](https://docs.unity3d.com/ScriptReference/Events.UnityEvent.html)\n按我的理解的话，UnityAction 是委托，之前我也提到了，我觉得委托就是同类型方法指针的集合，而 UnityEvent 感觉是 UnityAction 的集合，但需要注意的是，这里的 UnityAction 也需要是同一类型的，所以自己想一下，感觉这样设置的好处可能只是能够将这么多同类型的方法再次进行一个分类，可以调用 `AddListener` 和 `RemoveListener` 来管理 UnityAction 。\n使用事件的好处在于可以减少代码中的耦合，避免类和类之间相互调用，减少后期修改带来的维护成本，比如游戏中将网络请求、发送请求和处理请求的结果都放在同一个类（假设叫 A 类）中处理，在网络模块中有一个类似 AddListener 的接口，A 将自己的方法注册进去，那么在网络模块将网络消息处理结束之后，再执行这个类似 UnityEvent 的方法，那么未来 A 类发生了变化也不会影响到网络模块。\nUnityAction 有 0-4 个参数的形式，都是无返回值的，而关于 UnityEvent，在 \n[Scripting API](https://docs.unity3d.com/ScriptReference/Events.UnityEvent.html)上虽然也写了 4 种形式，但是可以看到都需要继承 UnityEvent 来实现。\n``` cs\n[System.Serializable]\npublic class MyIntEvent : UnityEvent<int>\n{\n}\n```\n书上的完整例子是这样的，要特别注意的是 UnityAction 可添加泛型参数，但是 UnityEvent 如果要带参数的话，需要再写个继承类。\n``` cs\n// 文件名：Script_05_09.cs\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Events;\n\n// 这里的继承的泛型需要与 UnityAction 的泛型类型相对应。\n[System.Serializable]\npublic class MyEvent : UnityEvent<int, string> { }\npublic class Script_05_09 : MonoBehaviour\n{\n    public UnityAction<int, string> Action1;\n    public UnityAction<int, string> Action2;\n    public MyEvent myEvent;\n    // Start is called before the first frame update\n    void Start()\n    {\n        // 注意如果使用 += 的话，没有对应的 -=，会有隐患\n        Action1 = MyFunction1;\n        Action2 = MyFunction2;\n        myEvent.AddListener(Action1);\n        myEvent.AddListener(Action2);\n    }\n\n    private void MyFunction1(int n,string str)\n    {\n        Debug.LogFormat(\"My Function1 被调用，n: {0},str: {1}\", n, str);\n    }\n    private void MyFunction2(int n,string str)\n    {\n        Debug.LogFormat(\"My Function2 被调用，n: {0},str: {1}\", n, str);\n    }\n    // Update is called once per frame\n    void Update()\n    {\n        if (Input.GetKeyDown(KeyCode.A))\n        {\n            Action1(1, \"miao\");\n            // Action1.Invoke(1, \"miao\"); // 跟上面一样的\n        }\n        if (Input.GetKeyDown(KeyCode.B))\n        {\n            Action2(2, \"wang\");\n            // Action2.Invoke(2, \"wang\"); // 跟上面一样的\n        }\n        if (Input.GetKeyDown(KeyCode.C))\n        {\n            // myEvent(3, \"wu~\");  // UnityEvent 不能这么使用\n            myEvent.Invoke(3, \"wu~\");\n        }\n    }\n    private void OnGUI()\n    {\n        GUILayout.TextField(\"请尝试按下 A/B/C 键\");\n    }\n}\n\n```\n# UI 事件\n事件依赖于 Graphic Raycaster 组件，应该是挂在 Canvas 上的，代表这个 Canvas 下面的 UI 元素都接收点击事件，如果有部分元素是不需要接收点击事件的，那么可以将这部分放到一个单独的 Canvas 里面，然后把该 Canvas 上的 Graphic Raycaster 组件的 enable 设置为 false，或者直接删除 Graphic Raycaster 组件。\nUGUI 有很多点击方法的时间，下面来看一下，接口对应的方法就不写了，这里好像都是一个接口里面只有一个方法，而且继承了接口的话，在代码中不实现也会报错。\n- [IPointerEnterHandler](https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.IPointerEnterHandler.html) 指针（鼠标之类的）进入该区域的时候调用。\n- [IPointerExitHandler](https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.IPointerExitHandler.html) 指针离开该区域的时候调用。\n- [IPointerDownHandler](https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.IPointerDownHandler.html) 指针按下的时候调用。\n- [IPointerUpHandler](https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.IPointerUpHandler.html) 鼠标抬起时调用。\n- [IPointerClickHandler](https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.IPointerClickHandler.html) 按下并抬起的时候调用，也就是点击的时候。\n- [IInitializePotentialDragHandler](https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.IInitializePotentialDragHandler.html) 拖动初始化，不能获取到方向。\n- [IBeginDragHandler](https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.IBeginDragHandler.html) 刚开始拖动的时候调用，并且可以获取到拖动的方向。\n- [IDragHandler](https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.IDragHandler.html) 滑动持续时调用。\n- [IEndDragHandler](https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.IEndDragHandler.html) 滑动结束时调用。\n- [IDropHandler](https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.IDropHandler.html) 落下时调用。\n- [IScrollHandler](https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.IScrollHandler.html) 鼠标滚轮持续时调用。\n- [IUpdateSelectedHandler](https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.IUpdateSelectedHandler.html) 选择时调用，只针对 Selectable 起作用。\n- [ISelectHandler](https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.ISelectHandler.html) 选择后调用，只针对 Selectable 起作用。\n- [IDeselectHandler](https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.IDeselectHandler.html) 取消选择的时候调用，因为只能选择一个 Selectable ，当选择新的之后，之前选择的都会回调取消选择事件。\n- [IMoveHandler](https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.IMoveHandler.html) 选择后，可监听上下左右 WASD 方向键。如果访问 eventData.moveDir 还可以取到具体移动的方向。\n- [ISubmitHandler](https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.ISubmitHandler.html) 按钮按下事件。\n- [ICancelHandler](https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.ICancelHandler.html) 按钮取消事件，按下时按 Esc 键可取消。\n下面演示如何让 image 反馈点击事件：\n``` cs\n// 文件名：Script_05_06.cs\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.EventSystems;\n\npublic class Script_05_06 : MonoBehaviour, IPointerClickHandler\n{\n    public void OnPointerClick(PointerEventData eventData)\n    {\n        Debug.Log(\"image 被点击了\");\n    }\n}\n```\n效果是在点击了这个图片之后控制台会显示 `image 被点击了`。\n# UI 事件管理\n上面有很多接口，实现这些接口可以监听对应的事件，但这种方式要在每一个需要监听这个事件的物体上挂上这个脚本，也不符合 MVC(模型、视图和控制器) 的设计模式，所以最好是写一个类来统一管理 UI 事件，比如用 `MyOnClick` 方法来处理按钮、文本、图片元素的点击事件。这里需要用到 [EventSystems.EventTrigger](https://docs.unity3d.com/2018.3/Documentation/ScriptReference/EventSystems.EventTrigger.html),这个类实现了上述的各种接口，并且都是 virtual 的，只需要继承了之后想要监听哪个事件就复写对应的方法即可，下面是 EventSystems.EventTrigger 的声明：\n``` cs\nnamespace UnityEngine.EventSystems\n{\n    [AddComponentMenu (\"Event/Event Trigger\")]\n    public class EventTrigger : MonoBehaviour, IEventSystemHandler, IPointerEnterHandler, IPointerExitHandler, IPointerDownHandler, IPointerUpHandler, IPointerClickHandler, IBeginDragHandler, IInitializePotentialDragHandler, IDragHandler, IEndDragHandler, IDropHandler, IScrollHandler, IUpdateSelectedHandler, ISelectHandler, IDeselectHandler, IMoveHandler, ISubmitHandler, ICancelHandler\n    {\n        //\n        // Fields\n        //\n        [Obsolete (\"Please use triggers instead (UnityUpgradable) -> triggers\", true)]\n        public List<EventTrigger.Entry> delegates;\n\n        //\n        // Properties\n        //\n        public List<EventTrigger.Entry> triggers {\n            get;\n            set;\n        }\n\n        //\n        // Constructors\n        //\n        protected EventTrigger ();\n\n        //\n        // Methods\n        //\n        private void Execute (EventTriggerType id, BaseEventData eventData);\n\n        public virtual void OnBeginDrag (PointerEventData eventData);\n\n        public virtual void OnCancel (BaseEventData eventData);\n\n        public virtual void OnDeselect (BaseEventData eventData);\n\n        public virtual void OnDrag (PointerEventData eventData);\n\n        public virtual void OnDrop (PointerEventData eventData);\n\n        public virtual void OnEndDrag (PointerEventData eventData);\n\n        public virtual void OnInitializePotentialDrag (PointerEventData eventData);\n\n        public virtual void OnMove (AxisEventData eventData);\n\n        public virtual void OnPointerClick (PointerEventData eventData);\n\n        public virtual void OnPointerDown (PointerEventData eventData);\n\n        public virtual void OnPointerEnter (PointerEventData eventData);\n\n        public virtual void OnPointerExit (PointerEventData eventData);\n\n        public virtual void OnPointerUp (PointerEventData eventData);\n\n        public virtual void OnScroll (PointerEventData eventData);\n\n        public virtual void OnSelect (BaseEventData eventData);\n\n        public virtual void OnSubmit (BaseEventData eventData);\n\n        public virtual void OnUpdateSelected (BaseEventData eventData);\n\n        //\n        // Nested Types\n        //\n        [Serializable]\n        public class Entry\n        {\n            public EventTriggerType eventID;\n\n            public EventTrigger.TriggerEvent callback;\n\n            public Entry ();\n        }\n\n        [Serializable]\n        public class TriggerEvent : UnityEvent<BaseEventData>\n        {\n            public TriggerEvent ();\n        }\n    }\n}\n```\n下面是符合代码实现监听两个 button 、一个 image 和一个 text 的点击事件的代码。\n``` cs\n// 文件名:Script_05_07.cs\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Events;\nusing UnityEngine.EventSystems;\nusing UnityEngine.UI;\n\npublic class Script_05_07 : MonoBehaviour\n{\n    public Button button1;\n    public Button button2;\n    public Image image;\n    public Text text;\n\n    // 最好写在 Awake 里面？\n    private void Start()\n    {\n        button1.onClick.AddListener(delegate() {\n            this.MyOnClick(button1.gameObject);\n        });\n\n        button2.onClick.AddListener(delegate ()\n        {\n            this.MyOnClick(button2.gameObject);\n        });\n\n        UIEventListener.Get(image.gameObject).OnClick = MyOnClick;\n        UIEventListener.Get(text.gameObject).OnClick = MyOnClick;\n    }\n\n    public void MyOnClick(GameObject go)\n    {\n        // 判断的时候一定要 .gameObject\n        if(go == button1.gameObject)\n        {\n            Debug.LogFormat(\"{0} 被按下了(button1)\",go.name);\n        }\n        else if (go == button2.gameObject)\n        {\n            Debug.LogFormat(\"{0} 被按下了(button2)\", go.name);\n        }\n        else if (go == image.gameObject)\n        {\n            Debug.LogFormat(\"{0} 被按下了(image)\", go.name);\n        }\n        else if(go == text.gameObject)\n        {\n            Debug.LogFormat(\"{0} 被按下了(text)\", go.name);\n        }\n    }\n}\n\npublic class UIEventListener : EventTrigger\n{\n    public UnityAction<GameObject> OnClick;\n    public override void OnPointerClick(PointerEventData eventData)\n    {\n        // 复写方法的时候都需要考虑一下要不要执行基类的方法。\n        base.OnPointerClick(eventData);\n\n        // 因为已经将这个脚本挂到了当前的物体身上，所以参数就是当前的物体\n        // 下面的使用方法为如果委托不为空那么就调用\n        OnClick?.Invoke(gameObject);\n    }\n\n    // 如果 go 上没有该脚本，那么给 go 添加上该脚本，如果有的话，直接返回\n    static public UIEventListener Get(GameObject go)\n    {\n        UIEventListener listener = go.GetComponent<UIEventListener>();\n        if(listener == null)\n        {\n            listener = go.AddComponent<UIEventListener>();\n        }\n        return listener;\n    }\n}\n```\n代码中要注意理清传递方法和方法中使用的参数的过程，还有传参和比较的时候要注意转换成 GameObject 的类型。\n关于方法的注册是应该写在 Start 里面还是 Awake 里面，个人的理解是，Awake 用来初始化自身的一些成员，Start 可以引用其他类的成员了，这样可以保证在引用其他类的成员时不会出现空指针，但是方法的注册，只能通过订阅者去注册，就是虽然 UnityAction 成员是在发布者的类里面的，但是自己身无法完成赋值，所以需要订阅者尽早的完成赋值，以免导致时间发生时方法还没有注册进去。\n再说一下 MVC 的设计思路，一般是在控制层接收事件，再将事件传递给模块层，等模块层处理完毕再通知 UI 层刷新显示。\n\n# RaycastTarget 优化\nUGUI 的点击事件是基于射线的，像是 image 或者 text 不需要相应点击事件的话，那么就需要把身上的 RayCastTarget 取消选中。因为 UI 事件会在 EventSyetem 的 Update() 方法中调用 Process 时触发。UGUI 会遍历屏幕中所有的 RayCastTarget 为 True 的 UI，然后发射线，排序找到玩家最先触发的 UI，再抛出事件给出逻辑层去响应，这样无形中会带来很多开销。\n优化的方式是尽量将每个不需要相应点击事件的 UI 身上的 RayCastTarget 给取消勾选，但是有时 UI 太多的话并不能保证自己能注意到每一个 UI，所以可以重写 OnDrawGizmos 方法将所有 RayCastTarget 为 true 的 UI 的边框在 Scene 中画出来。\n## 用到的相关 API 介绍\n- [OnDrawGizmos](https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnDrawGizmos.html)\n- [Gizmos](https://docs.unity3d.com/ScriptReference/Gizmos.html) 用于画各种图形，方块，圆，线之类的。在 UnityEngine 命名空间下。\n- [MaskableGraphic](https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.UI.MaskableGraphic.html?q=Maskable#methods)(UGUI 手册) / [MaskableGraphic](https://docs.unity3d.com/2018.1/Documentation/ScriptReference/UI.MaskableGraphic.html)(老版 Unity 官方 API 手册)，MaskableGraphic 是一个抽象类，Image,Text,RayImage 都是继承于它，MaskableGraphic 又是 Graphic 的子类，一会将用到的 raycastTarget 成员就是继承于 Graphic。 \n``` cs\npublic abstract class MaskableGraphic : Graphic, \nICanvasElement, IClippable, IMaskable, IMaterialModifier\n```\n## 运行效果\n如图所示，RayCastTarget 为 true 的组件在 Scene 面板中会有一个红色的框框，然后在 Gizmos 勾选或者取消勾选对应的脚本名称，即可显示或者不显示这个自定义功能。\n![](/img/xys_5.2_1.png)\n![](/img/xys_5.2_2.png)\n## 代码\n``` cs\n// 文件名：Script_05_10.cs\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI;\n\n// 找到场景中所有的 MaskableGraphic 的子类（比如 image，text，rayImage 等）\n// 然后画出是否勾选了 Raycast Target\npublic class Script_05_10 : MonoBehaviour\n{\n    // static 节约内存资源，应该还可以再优化节约计算资源。\n    private Vector3[] corners = new Vector3[4];\n\n#if UNITY_EDITOR\n    private void OnDrawGizmos()\n    {\n        foreach(MaskableGraphic go in GameObject.FindObjectsOfType<MaskableGraphic>())\n        {\n            if (go.raycastTarget)\n            {\n                // RectTransform go_trans = go.transform as RectTransform;\n                RectTransform go_trans = go.rectTransform;\n                go_trans.GetWorldCorners(corners);\n                Gizmos.color = Color.red;\n                int length = corners.Length;\n                for(int i = 0; i < length; i++)\n                {\n                    // 取模是为了首尾相连\n                    Gizmos.DrawLine(corners[i], corners[(i + 1) % length]);\n                }\n            }\n        }\n    }\n#endif\n}\n```\n关于 `corners` 是否需要加 static ，个人理解是，全场景只需要一个实例化的脚本，因为一个实例就可以遍历场景所有的 UI，而 corners 只是一个数据计算的工具台而已，只需要一个就够了，所以可以加 static，但其实这个可以直接写成单例，不然新建一个实例就会在每一帧多调用一次 OnDrawGizmos，对计算力来说是不必要的开销。\n然后关于 Unity 自带的一些回调函数，比如说 Awake、Start、Update，其实不是在 MonoBehaviours 及其父类中定义的，而是采用了一种反射（具体不知道）机制实现的，所以不需要加 override，也不能写错方法的名字。\n这里其实不需要特地考虑 corners 的长度，因为肯定是 4 个，GetWorldCorners 方法也限制了必须是 4 个。\n关于 `GetWorldCorners` 方法，定义如下：\n``` cs\npublic void GetWorldCorners(Vector3[] fourCornersArray);\n```\n但是从功能上来说的话，其实 `fourCornersArray` 的参数更像是出参，我也做了一个实验，可以看到如果在调用前数组没有分配内存的话，Fun2 是会报错的，因为数组此时为 null，但是使用 Fun1 的话就不会出现这个问题，而官方应该是按照 Fun2 来实现的，所以有些不明白其中的奥义所在。\n``` cs\n// 解决方案名：csharpTest\n// 项目名：inOutTest\nusing System;\n\nnamespace inOutTest\n{\n    class Program\n    {\n        static void Fun1(out A[] a)\n        {\n            a = new A[4] { new A{ a=1,b = \"m\"},new A{ a = 2, b = \"mm\" },\n                            new A{ a=3,b = \"mmm\"},new A{ a = 4, b = \"mmmm\" }};\n        }\n        static void Fun2(A[] ass)\n        {\n            ass[0] = new A { a = 1, b = \"m\" };\n            ass[1] = new A { a = 2, b = \"mm\" };\n            ass[2] = new A { a = 3, b = \"mmm\" };\n            ass[3] = new A { a = 4, b = \"mmmm\" };\n        }\n        static void Main(string[] args)\n        {\n            A[] ass /* 可以在这里断开来试试，Fun2 会报错 */ = new A[4];\n            // Fun1(out ass);\n            Fun2(ass);\n\n            foreach (A aa in ass)\n            {\n                Console.WriteLine(aa);\n            }\n            Console.ReadKey();\n        }\n    }\n    class A\n    {\n        public int a;\n        public string b;\n        public override string ToString()\n        {\n            return string.Format(\"a = {0},b = {1}\", a, b);\n        }\n    }\n}\n``` ","tags":["Unity","宣雨松"]},{"title":"UGUI 基本元素","url":"/2020/07/16/xys-5.1/","content":"终于看到 UI 了。\n# Text\n## 修剪字体\n因为一般 .ttf 的字体文件里面会有很多无用字符，所以可以用 FontCreator 处理一下，下面将演示在幼圆字体中删去几个字符，并且将黑体的数字和幼圆的汉字做拼接。\n打开 FontCreator ，然后点击 File->Open Installed Font, 选择幼圆字体和黑体，再将幼圆字体中不需要的字删掉（快捷键 Delete），然后在黑体中将 0-9,A-Z,a-z 复制到幼圆对应的位置。效果如图所示：\n![](/img/xys_5.1_1.png)\n然后将处理好的字体导出为 .ttf，并放到 Unity 中，再将字体赋给 text 组件的 Font 属性中，对比如下：\n![](/img/xys_5.1_2.png)\n## Raycast Target\n如果 UI 组件不需要点击事件，那么就不要勾选上 Raycast Target 复选框，因为 UGUI 的事件系统会遍历出所有带 Raycast Target 的组件，会带来额外的开销。\n## Material\nUGUI 的默认材质是我们无法更改的，但是我们可以复写它，只要将自定义的材质拖到 Materail 中就好了。\n## 描边和阴影\n在 Text 游戏对象上添加 Outline 和 Shadow 组件的话，文本可以获得描边和阴影的效果。可以设置颜色，描边距离等参数。描边的底层实现是在原有 Text 的基础上在上、下、左、右又多画了一遍，所以效率很低，但是阴影就只需要多画一遍，所以能用阴影的尽量用阴影，少用描边。\n## 动态字体\nUnity3D中支持动态字体和静态字体两种格式字体，动态字体即使用TTF格式字体库，静态字体则需要自己打包字体图集。\n动态字体和静态字体区别在于，动态字体如果出现字体库中不存在的字体，会使用系统字体，而静态字体则不会，而且静态字体是图片，字体大小通过缩放来改变。Unity3D也有自带的字体，Windows下自带字体为Arial。如果使用Unity3D的自带字体Arial字体，在某些机型上可能显示不全。因为Arial是英文字体，并不包含中文字体，在程序运行过程中如果遇到字库中没有的字，程序就会从系统的默认字体库中查找对应的文字，如果系统默认的字库中也没有这个字，那么就会造成字体不显示问题。\n动态字体的原理还有一个是如果同样的文字但是是不同的大小，那同样的文字会在纹理中生成三份。\n- 实验一：缺失字体会用默认字体补全\n在上文修剪字体中已经去掉了几个常用字，然后在 Unity 的 text 组件中输入被删去的字符，发现那几个字会变成 Arial 字体。应该是 Unity 选择了当前系统的默认字体。\n- 实验二：动态字体会因为大小不同而出现冗余\n设置两个含有相同内容的同一个字体的 Text，然后点击相应的字体，看它的 Font Material，可以看到 “喵星人（号字体）” 等几个字符都是有两份的。\n![](/img/xys_5.1_5.png)\n![](/img/xys_5.1_6.png)\n\n\n也是基于以上原因，不建议在游戏中使用动态字体。\n游戏中除了聊天和起名字等必须由用户自己主动输入的文字外，其实大量的文字是不需要使用到动态字体的。在游戏中强烈推荐使用 TextMeshPro，这原本是一个第三方软件，后来被 Unity 官方收购，现在可以免费使用。只需要在`Window > Package Manager` 中安装 TextMesh Pro 即可。\nTextMeshPro 最基础的用法就是使用它的 Text 组件来显示文本。有两种使用方法，一种是通过网格 MeshRenderer 渲染，一种是通过 UI 系统渲染。\n- Mesh 方式创建方法：Hierarchy 的 Create 菜单（右键菜单）> 3D > TextMesh Pro - Text\n- UI 方式创建方法：Hierarchy 的 Create 菜单（右键菜单）> UI > TextMesh Pro - Text\n对比一下 UGUI 的 Text 和 TextMesh Pro 的 Text：\n可以很明显的看到 UGUI 的 Text 在放大之后会模糊，但 TextMesh Pro 依然很清晰。\n![](/img/xys_5.1_7.png)\n\n\n这是因为 TextMesh Pro 的 Text 使用了不同的技术来渲染文字，叫做Signed Distance Field（后面简称 SDF，原理是用位图保存矢量信息，记录到边的最短距离，最后用 Shader 还原回来）。使用 SDF 技术字符在渲染时不会因为缩放而造成字符模糊的情况，总是能够准确的渲染字符的边缘。\nTextMesh Pro 没有动态字体，所以对中文环境的游戏建议是：\n- 对于游戏中显示的文字可以使用TextMesh Pro的SDF字体，提高显示效果和特效处理。\n- 对于游戏中的输入框建议使用UGUI自带输入框，使用动态字体。\n\n\n创建字体过程如下：\n- 菜单栏打开Window -> TextMeshPro -> Font Asset Creator\n- Font Source -> Character Set -> Generate Font Atlas -> Save\nFont Source 选择要创建SDF字体的源字体\n\n面板参数解释如下：\n- `Sampling Point Size` 创建字体的字号的大小。\n    - `Auto Sizing` 建议使用该选项。根据给定 Atlas Resolution（图集分辨率）来计算并使用最大字号。\n    - `Custom Size` 自定义字号。\n- `Padding` 图集中每个字符之间的间隔，以便在渲染时能却分他们的边缘。此外 padding 也用于文字的特效，所以不宜过小；但是也不宜过大，过大会造成更大的atlas分辨率或者atlas上能承载的字符更少。对于512*512的图集，padding为5通常比较合适。\n- `Packing Method` 打包方式\n    - `Fast` 可能计算出不是最大的字号，但是计算速度会快一些\n    - `Optimum` 可以计算出图集上能承载的最大的字号\n    - 通常在测试设置时使用 Fast，在最终打包时使用 Optimum\n- `Atlas Resolution` 使用 SFD 字体时，更高的分辨率会产生更精细的渐变，从而产生更高质量的字体。对于大多数字体，仅包含所有 ASCII 字符时，512x512 纹理分辨率足够用。\n    - 当需要支持数千个字符时，不得不使用大纹理。但即使在最高分辨率下，也可能无法满足所有要求。在这种情况下，可以通过创建多个字体资源来拆分字符。将最常用的字符放在主字体资源中，将其他字符放在后备(fallback)字体资源中。\n- `Character Set` 字体文件中的字符不会自动包含在字体资源中。你必须指定你需要的那些。你可以选择一些预定义的字符集，也可以自己提供字符列表。\n    - `ASCII` 大小写字母 + 数字 + 常见符号\n    - `Extended ASCII` 包含所有的 ASCII 字符\n    - `ASCII lowercase` 小写字母 + 数字 + 常见符号\n    - `ASCII uppercase` 大写字母 + 数字 + 常见符号\n    - `Numbers + Symbols` 数字 + 常见符号\n    - `Custom Range` 使用十进制来制定字符的编码范围，可以使用减号和英文逗号来指定范围，如 `32-126,161-255`。使用自定义字符范围时，可以直接引用一个SDF字体，使用这个字体中的字符集\n\n    - `Unicode Range(Hex)` 使用 16 进制来制定字符的编码范围，可以使用减号和英文逗号来指定范围，如 20-7E,A1-FF\n    - `Custom Characters` 自定义字符，直接输入对应的字符\n    - `Characters from file` 从外部文件中导入字符\n- `Render Mode` 距离场模式创建SDF纹理需要与 SDF shader 一起使用。字符是在高分辨率下采样来创建良好的渐变。16x 是默认值并且足以用于大多数情况。32x 生成较慢但可以让复杂或小字符产生更好的质量。\n其他模式直接将字符渲染为位图，以便与位图字体一起使用。Raster 模式不使用抗锯齿，Smooth 模式使用抗锯齿。两者都有一个Hinted模式，它将字符像素与纹理像素对齐以获得更清晰的结果。\n- `Get Kerning Pairs` 你可以选择从字体中提取字距数据。此数据用于调整特定字符对之间的间距，以产生更好的视觉效果。但是请注意很多字体没有字距数据。\nTextMesh Pro 有文档和例子，需要使用时可以详细了解一下。\n![](xys_5.1_8.png)\n## 字体花屏\nUGUI 的动态字体每出现一个新的字（或者同样的字但是大小不一样），材质上也都会多一个字，一开始是 256\\*256（像素）的材质，但扩大到 4096\\*4096（像素）的时候，就会触达 UGUI 内部的重建字体贴图的命令，就会导致字体花屏，为了解决这一问题，我们需要监听 [Font.textureRebuilt](https://docs.unity3d.com/ScriptReference/Font-textureRebuilt.html),在贴图重建的时候，在下一帧找到场景中所有的该字体，并且调用 FontTextureChanged() 方法刷新。代码如下：\n``` cs\n// 文件名： Script_05_01.cs\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI;\n// 当字体贴图发生改变的时候，为了防止字体花屏，刷新场景中的每一个 Text。\npublic class Script_05_1 : MonoBehaviour\n{\n    private Font m_changedFont = null;\n    void Start()\n    {\n        // textureRebuilt 的传参是贴图重建的字体\n        Font.textureRebuilt += delegate (Font font)\n        {\n            m_changedFont = font;\n        };\n    }\n\n    void Update()\n    {\n      if(m_changedFont != null)\n        {\n            Text[] text = GameObject.FindObjectsOfType<Text>();\n            if(text != null)\n            {\n                foreach(Text t in text)\n                {\n                    if(t == m_changedFont)\n                    {\n                        t.FontTextureChanged();\n                    }\n                }\n            }\n            // 将贴图重建的字体还原回 null；\n            m_changedFont = null;\n        }  \n    }\n}\n\n```\n这里的代码感觉可能是有问题的，因为如果在同一帧中有多个字体贴图发生了重建的话，这里只能检测到一个，所以或许用 List 来存储可能会好一点，但是如果是 List 的话，就需要查找两个集合之间的交集（贴图改变的字体集合和场景中所有 text 的字体）。\n# Image 组件\nImage 用来显示图片。\n- Image Type\n    - `Simple` 直接显示图片\n    - `Sliced` 通过九宫格的形式显示图片，可用 [SpriteEditor](https://docs.unity3d.com/2018.4/Documentation/Manual/SpriteEditor.html) 来编辑九宫格的区域。\n    - `Tiled` 平铺图片。\n    - `Filled` 像技能 CD 冷却一样，旋转图片。\n- 9 切片\n[官方文档](https://docs.unity3d.com/2018.4/Documentation/Manual/9SliceSprites.html)上的例子挺好的，也按照上面实现了一下，要注意的就是在修改 Sprite Type 为 Sprite(2D and UI)时，要注意把 Mesh Type 也改成 Full Rect，再使用 Sprite Editor。然后可以新建一个 Sprite，将 Source Images 选成刚刚处理好的图片，将 Image Type 改成 Filled 或者 Sliced 试试，感觉很有用。 \n# Raw Image 组件\nImage 组件只能显示 Texture Type 为 Sprite(2D and UI) 的图片，但是 Raw Image 既可以显示任意 Texture 也可以使用 Sprite（虽然还是以 Texture 的形式显示的）,Unity 一般会在为场景中的每一个 Texture 调用一次 [draw call](https://docs.unity3d.com/2018.4/Documentation/Manual/DrawCallBatching.html)，所以如果一个场景中有大量的 Texture，那么大量的 draw call 调用将有可能导致资源密集型的效率问题。可以使用 [Sprite Atlas](https://docs.unity3d.com/2018.4/Documentation/Manual/class-SpriteAtlas.html) 来处理这个问题，Sprite Atlas 可以将多个 Texture 合并为 一个 Texture，这样就可以只调用一次 draw call 而不是很多次 draw call。\n在大量 UI 系统中不建议使用 Raw Image,但是有时不得不用它，比如 Render Texture ，需要将摄像机渲染到纹理中，就必须要使用它。\n# Button 组件\nButton 组件依赖于 Image 组件。可以监听点击事件，下面演示在代码中实现的方式：\n``` cs\n// 文件米：Script_05_02.cs\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI;\n\npublic class Script_05_02 : MonoBehaviour\n{\n    public Button btn;\n    // Start is called before the first frame update\n    void Start()\n    {\n        btn.onClick.AddListener(delegate ()\n        {\n            Debug.Log(\"按钮被按下了\");\n        });\n    }\n}\n```\n当点击 Button 的时候控制台会显示 `按钮被按下了`。另一种注册事件的方法时在按钮的 Inspector 面板上点击 OnClick，将需要注册的方法所在的物体拖进 Object 里，随后便可以选择相应组件上相应的方法。但不建议这么使用，因为在代码中对按钮进行监听更加灵活。\n# Toggle 组件\n在一个物体上添加 Toggle Group 组件，里面只有一个属性：\n- `Allow Switch Off` 如果不勾选上的话，那么不能将同一组的 Toggle 同时同时设置为取消勾选状态；反之，可以不勾选所有的 Toggle。\n将想要放在同一组的 Toggle 的 Group 选项引用挂有 Toggle Group 的物体，那么这一组 Toggle 就可以实现互斥选择，即最多只选择其中一个 Toggle。可以监听 Toggle 的选择/取消选择时间。\n``` cs\n// 文件名：Script_05_03.cs\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI;\n\npublic class Script_05_03 : MonoBehaviour\n{\n    public Toggle[] toggles;\n    // Start is called before the first frame update\n    void Start()\n    {\n        foreach(Toggle toggle in toggles)\n        {\n            // 委托参数为 bool 类型的 Toggle 当前状态\n            toggle.onValueChanged.AddListener(delegate (bool isOn)\n            {\n                Debug.LogFormat(\"{0}的值发生了改变，当前状态为：{1}\", toggle.name, isOn);\n            });\n        }\n    }\n\n    // 测试通过 Toggle.isOn 来设置 Toggle 状态的效果是否和手动点击一样（一样的）\n    private void OnGUI()\n    {\n        if(GUILayout.Button(\"改变 Toggle1 的状态\"))\n        {\n            if(toggles != null && toggles[0].name == \"Toggle1\")\n            {\n                toggles[0].isOn = !toggles[0].isOn;\n            }\n        }\n    }\n}\n```\n注意 onValueChanged 的委托的参数是改变后的值，也就是当前的值，而且在注册了之后只要是 Toggle 的状态发生了改变方法都会被调用，不管是因为手动改变了状态还是在代码中调用 Toggle.isOn, 还是因为选择了其他的 Toggle 导致的当前 Toggle 的状态发生改变。\n\n# Slider 组件\n[Slider](https://docs.unity3d.com/2020.1/Documentation/Manual/script-Slider.html) 组件是一个在进度条上拖动，游戏中经常用作人物血条，光照强度等。同样的，可以监听 `Slider.onValueChanged()` 方法来取到滑动条的进度。不过要注意这里的 `onValueChanged()` 方法和上面 Toggle 中传递的 UnityEvent 是不同多的，回调的参数也是不同的，上面的参数是 bool 值，这里的是 float。\n``` cs\n// 文件名：Script_05_04.cs\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI;\n\npublic class Script_05_04 : MonoBehaviour\n{\n    public Slider slider;\n    private void Start()\n    {\n        slider.minValue = 0;\n        slider.maxValue = 100;\n        slider.onValueChanged.AddListener(delegate (float value)\n        {\n            Debug.LogFormat(\"slider 的值发生了改变，现在为：{0}\", value);\n        });\n    }\n    private void OnGUI()\n    {\n        if (GUILayout.Button(\"slider 的值加 1\"))\n        {\n            slider.value++;\n        }\n        if (GUILayout.Button(\"slider 的值减 1\"))\n        {\n            slider.value--;\n\n        }\n    }\n}\n\n```\nSlider 的 minValue 和 maxValue 类似于 `Mathf.Clamp` 一样，比如 maxValue 的值为 100 的话，当加得超过一百的时候，取值就是 100，minValue 同理。\n# Scrollbar & ScrollView 组件\n新建一个 [Scroll View](https://docs.unity3d.com/2018.4/Documentation/Manual/script-ScrollRect.html) 组件，默认内容是这样的:\n![](/img/xys_5.1_9.png)\n虽然根物体的名字是 Scroll View，但其实最有用的是根物体上挂着的 Scroll Rect 组件，他有 Scrollbar 的引用，还有 Content 的引用，如果将 Viewport 下的 Content 给移除，然后新建一个 Text,并将引用赋值给 Scroll Rect 的 Content，再改变 Text 的大小，让其超过 Mask 的覆盖范围，那么就可以实现用滑动条来拖动文字的效果。\n![](/img/xys_5.1_10.png)\nViewport 上有 Mask 组件，如果不知道 Text 需要拖到多大，可以将 Mask 先禁用。\n![](/img/xys_5.1_11.png)\n# 使用 ScrollRect 组件制作游戏摇杆\n书中没有明确两个 Sprite 的关系，但是经过试验，个人觉得下面的方式比较好：\n\n- 摇杆背景(yaogan)\n    - 摇杆手柄(Image2)\n\n然后将 Script_05_05 脚本挂在 yaogan 上面，Image2 赋给 脚本中的 content，Image1 和 Image2 的位置关系都设置为不延伸的中间，这样是可行的，但是缺点在于 yaogan 不能更改位置关系，因为一旦改变了位置关系，那么 `sizeDelta` 算出来的就不是背景的大小了(这里没有一个 size 属性吗？),一个解决方案就是在 yaogan 外层再加一个 EmptyGameobject ，但紧接着带来的坏处就是不能通过 EmptyGameobject 来改变整个摇杆装置的大小。而且这里也默认了背景是正方形的，因为只是取了 `sizeDelta.x` 来作为半径。\n\n``` cs\n// 文件名：Script_05_05.cs\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI;\n\n// 用 ScrollRect 实现一个游戏摇杆\npublic class Script_05_05 : ScrollRect\n{\n    protected float mRadius = 0f;\n\n    // 设置为 protected，别忘了调用 base.Start()\n    protected override void Start()\n    {\n        base.Start();\n        // 计算两个 x 轴两个锚点之间的距离 / 2 为移动半径\n        mRadius = (transform as RectTransform).sizeDelta.x * 0.5f;\n    }\n\n    // 因为 PointerEventData 用到的次数少，所以不需要 using 整个命名空间\n    public override void OnDrag(UnityEngine.EventSystems.PointerEventData eventData)\n    {\n        base.OnDrag(eventData);\n\n        // 这样的话 content 活动范围是一个正方形，而不是圆形，所以需要计算 content 的锚点位置向量的模\n        // 如果大于半径的话，再用单位向量 * 半径，就是 content 的最终位置。\n        //this.content.anchoredPosition = new Vector3(Mathf.Clamp(this.content.anchoredPosition.x, -mRadius, mRadius),\n        //    Mathf.Clamp(this.content.anchoredPosition.y, -mRadius, mRadius));\n        \n        // 如果要新建一个局部变量，要注意最后需要使用 SetContentAnchoredPosition(contentPosition) 来赋值\n        // 直接使用赋值符号改变的是局部变量的指向\n        // var contentPosition= this.content.anchoredPosition;\n        if(this.content.anchoredPosition.magnitude > mRadius)\n        {\n            this.content.anchoredPosition = this.content.anchoredPosition.normalized * mRadius;\n        }\n    }\n}\n}\n```\n\n# 参考\n[Unity3D中的动态字体和静态字体](https://blog.csdn.net/Wei_Yuan_2012/article/details/87927582)\n[TextMeshPro插件](https://zhuanlan.zhihu.com/p/48512586)","tags":["Unity","宣雨松"]},{"title":"脚本调试","url":"/2020/07/15/xys-4.5/","content":"\n# 脚本编译规则\n- 最终所有代码都会生成 dll，放在 Project/Library/ScriptAssembiles 下面。\n- 脚本分为运行时和编辑时两类，运行时脚本最终会编译进游戏包中，而编辑时脚本仅用于编辑器模式下，不会被打包进游戏包。\n- 脚本编译顺序：最先编译 Plugins 目录下的，然后是 Plugins 下的所有 Editor 子目录，然后编译其他目录，最后编译其他 Editor 目录。\n- 先编译的不可以访问后面的数据，所以 Plugins 下的代码不能访问其他代码，后编译的可以访问先编译的脚本。\n- 各目录脚本最终所在的 dll： \n    - Plugins 下非 Editor 目录脚本编译进 Assembly-CSharp-firstpass.dll\n    - Plugins 下的 Editor 目录脚本编译进 Assembly-CSharp-Editor-firstpass.dll\n    - 其他非 Editor 目录脚本编译进 Assembly-CSharp.dll\n    - 其他 Editor 目录脚本编译进 Assembly-CSharp-Editor.dll\n\n# 优化编译\nTips：\n- 当游戏内有很多 C# 代码时，改动一点点代码就需要等很久，因为 Unity 在重新编译 dll，可以将代码分为框架类代码和逻辑性代码，框架性代码一般写好之后不会经常变动，常常需要更改的往往是逻辑性代码，将框架性代码放到 Plugins 目录下，那么在修改逻辑性代码时，就不会额外的编译 Plugins 目录下的代码了。\n- 如果代码量非常巨大，那么编译还是会很慢，可以将部分 CS 代码预先变异成 dll，这样编译速度就更快了。（暂时还不知道怎么做，先记录一下）\n\n# 编译DLL （没懂）\n.NET 可以把 C/C++ 语言编译进 DLL，但是游戏发布后，有的平台是识别不了的，例如移动平台，此时如果编译 DLL 时只能编译 C# 代码，则需要在 macOS 系统中打开终端，输入编译指令，DLL 编译完后直接拖到项目中即可。\n``` bash\nmcs -r:/Applications/Unity/Unity.app/Contents/Managed/UnityEngine.dll\n-target:library -out:test.dll *.cs\n```\n- UnityEngine.dll:编译所依赖的 DLL 文件。\n- -target:library:生成 Library1 类型。\n- -out:test.dll:最终生成 DLL 的保存目录。\n- *.cs:表示当前目录下的所有 C# 代码。如果有多个目录多个文件，可以用空格分隔。\n\n# 脚本跨平台\n雨松大大夸了一波 Unity 的跨平台，没懂，应该是指 Unity 针对每个平台有一套底层的核心库，然后通过 C# 去调用，所以对于用户来说只需要使用 C# 就好了。\n> Unity 自己提供了两个核心的 DLL 库，Unity 编辑器只支持 Windows、macOS 和 Linux 这 3 个平台，所以代码大部分是由 C# 编写的并且编译在 UnityEditor.dll 中，然后通过 Mono 实现了跨平台。运行时由于它兼容的平台非常多（目前已经有 20 多个平台了），并不是所有平台都能运行 DLL 的。再说，底层渲染方法也不能使用 C# 来调用，所以 Unity 只把 C# 接口封装到了 UnityEngine.dll 中。至于更底层的内部实现，则是由这个 DLL 再去调用 C++ 来完成的。拿移动平台来说，编译 C++ 的方式是不同的，Android 需要编译成 .so，ios 则需要编译在 .a 中。所以，Unity 会针对每个平台编译出这份核心库，从而实现了跨平台。现在 Unity 还支持 IL2CPP，它可以把 DLL 代码转化成 C++ 来执行，这从效率上又能提高一个台阶，并且开发者依然使用 C#，只有在打包的时候才会转化成 IL2CPP，整个过程使开发者无感，超棒der。虽然拿不到 Unity 的源码，但是 UnityEngine.dll 和 UnityEditor.dll 这两个 DLL 文件是可以反编译的。\n\n# 程序集定义\n上面提过如果程序过大的话，那么每次改动一点都会等待很久重新编译，除了上面两种方法之外还可以使用程序集。\n用户在一个文件夹下新建一个程序集定义，那么就意味着这个文件夹及其子文件夹都变成了一个程序集，单独编译成一个 DLL，如果需要依赖其他的程序集的话，在程序集定义的 Inspector 面板上设置依赖。如图是在 A 程序集中设置了对 B 程序集的依赖。\n![](/img/xys_4.5.5_1.png)\n![](/img/xys_4.5.5_2.png)\n\n# 日志\n在游戏发布时一定要将 Debug 给关掉，因为他会有额外的消耗，或者在编写需要输出日志的时候就加上，如果没有定义 UNITY_EDITOR 那么就关闭日志。\n``` cs\n#if !UNITY_EDITOR\n    Debug.unityLogger.logEnabled = false;\n#endif\n```\n除此之外，错误日志并不是主动打的，下面实现将错误信息打在屏幕上的功能，以方便 Debug。\n``` cs\n// 文件名：Script_04_21.cs\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\n// 捕获错误，并将其显示在屏幕上\npublic class Script_04_21 : MonoBehaviour\n{\n    // 是否显示 UI\n    private bool m_bIsVisible = false;\n\n    // 存储所有错误信息和调用栈 \n    private List<string> m_lErrorMsg = new List<string>();\n\n    // 显示的 UI 范围\n    private Rect m_rWindow = new Rect(0, 0, Screen.width, Screen.height);\n\n    // 设置 Scroll 的位置\n    private Vector2 m_v2ScrollPosition = Vector2.zero;\n\n    // Start is called before the first frame update\n    void Start()\n    {\n        // 监听 logMessageReceived ,参数：日志字符串(string)，调用栈(string)，消息类型(LogType)\n        Application.logMessageReceived += (logMsg, stackTrace, type) =>\n        {\n            if(type == LogType.Error || type == LogType.Exception)\n            {\n                m_bIsVisible = true;\n                m_lErrorMsg.Add(string.Format(\"{0} \\n {1}\", logMsg, stackTrace));\n            }\n        };\n\n        // 设置 Error\n        for(int i = 0; i < 10; i++)\n        {\n            Debug.LogError(\"出错了:\" + i);\n        }\n\n        // 设置异常\n        int[] a = null;\n        a[1] = 1;\n    }\n\n    private void OnGUI()\n    {\n        if (m_bIsVisible)\n        {\n            m_rWindow = GUILayout.Window(0, m_rWindow, WindowFun, \"console\");\n        }\n    }\n\n    void WindowFun(int id)\n    {\n        GUILayout.BeginHorizontal();\n        if (GUILayout.Button(\"Clear\", GUILayout.MaxWidth(200)))\n        {\n            m_lErrorMsg.Clear();\n        }\n\n        if (GUILayout.Button(\"Close\", GUILayout.MaxWidth(200)))\n        {\n            m_bIsVisible = false;\n        }\n        GUILayout.EndHorizontal();\n\n        m_v2ScrollPosition = GUILayout.BeginScrollView(m_v2ScrollPosition);\n        foreach(var msg in m_lErrorMsg)\n        {\n            // 因为不需要再打印其他的字符串，所以这边的颜色要不要换回来都没关系\n            Color currentColor = GUI.contentColor;\n            GUI.contentColor = Color.red;\n            GUILayout.TextField(msg);\n            GUI.contentColor = currentColor;\n        }\n        GUILayout.EndScrollView();\n    }\n}\n```\n\n在代码中我们估计打印了一个错误和故意搞了一个异常，运行效果如图所示，错误信息和调用栈都被打印下来了。\n![](/img/xys_4.5.6.png)\n\n# 脚本调试\nUnity 2018 彻底废除了 MonoDevelop，使用 VS，设置了断点之后，在点击 “附加到 Unity”，就会在断点处停住，但不知道为什么我无法像书上所说的，直接将鼠标放到变量身上就可以看到对应的值。\n书中还写了一个小技巧，可以直接在监视中直接输入 `gameObject.transfrom.position` 或者 `gameObject.name` 来直接查看。 ","tags":["Unity","宣雨松"]},{"title":"定时回调和工作线程","url":"/2020/07/13/xys-4.4.10-4.4.11/","content":"\n# 定时回调的实现 \n## CustomYieldInstruction 文档\n如果想要在协程函数里面自定义 `yield return new xxxxClass();` 那么就需要继承自 `CustomYieldInstruction`，然后重写里面的 `keepWaiting` 属性，为 false 的时候表示继续运行，true 的时候表示继续挂起（等待），每一帧都会在 `MonoBehaviour.Update` 之后，`MonoBehaviour.LateUpdate` 之前检查一遍 `keepWaiting` 的值，并确定要不要运行。\n\n下面的例子运行效果是：先点击 \"开始等待按下鼠标右键\" 的按钮，此时输出 `start waitting mouse button down`，然后当前线程会继续运行，所以会输出 `wait-mouse-button-down coroutine has started`, 而 \"等待右键按下的协程\" 此时在等待右键按下。当右键按下后协程函数会继续运行，所以会输出 `right button pressed`。\n\n代码和运行结果如下：\n``` cs\n// 文件名：CustomYieldInstructionTest.cs\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class CustomYieldInstructionTest : MonoBehaviour\n{\n    private void OnGUI()\n    {\n        if (GUILayout.Button(\"开始等待按下鼠标右键\"))\n        {\n            StartCoroutine(WaitMouseButtonDown());\n            Debug.Log(\"wait-mouse-button-down coroutine has started\");\n        }\n    }\n\n    private IEnumerator WaitMouseButtonDown()\n    {\n        yield return new WaitForMouseDown();\n        Debug.Log(\"right button pressed\");\n    }\n}\n\n// 最好把这个类放到 Plugins 之类的文件中，这样可以保证它在 JS 脚本前面编译\n// （可能对于 c# 脚本没有这个担心的必要）\npublic class WaitForMouseDown : CustomYieldInstruction\n{\n    // 当鼠标右键按下的时候返回 false，也就是继续运行\n    public override bool keepWaiting\n    {\n        get { return !Input.GetMouseButtonDown(1); }\n    }\n\n    public WaitForMouseDown()\n    {\n        Debug.Log(\"start waitting mouse button down\");\n    }\n}\n\n```\n> - start waitting mouse button down\n> - wait-mouse-button-down coroutine has started\n> - right button pressed \n\n## 实现\n``` cs\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Events;\n\n// 实现每过一秒执行一次回调，然后经过 x 秒结束任务\npublic class Script_04_19 : MonoBehaviour\n{\n    // Start is called before the first frame update\n    IEnumerator Start()\n    {\n        Debug.LogFormat(\"10s start，now time：{0}\", Time.time);\n        yield return new CustomWait(10, 1, () => { Debug.LogFormat(\"now time: {0}\", Time.time); });\n        Debug.LogFormat(\"10s over，now time：{0}\", Time.time);\n    }\n    public class CustomWait : CustomYieldInstruction\n    {\n        public override bool keepWaiting\n        {\n            get\n            {\n                if(Time.time - m_StartTime >= m_TotalTime)\n                {\n                    return false; // 协程结束\n                }\n                else\n                {\n                    // 如果经过了时间间隔的话，调用一次 callback\n                    if(Time.time - m_LastTime >= m_Interval)\n                    {\n                        m_LastTime = Time.time;\n                        callback();\n                    }\n                }\n                return true; // 协程继续挂起，等待下一次判断\n            }\n        }\n\n        private float m_TotalTime; // 总时间\n        private float m_Interval; // 时间间隔\n        private float m_StartTime; // 开始的时间\n        private float m_LastTime; // 上一次回调的时间\n        private UnityAction callback; // 回调委托\n\n        public CustomWait(float totalTime,float interval,UnityAction callback)\n        {\n            this.m_TotalTime = totalTime;\n            this.m_Interval = interval;\n            this.m_StartTime = Time.time;\n            this.m_LastTime = Time.time;\n            this.callback = callback;\n        }\n    }\n}\n```\n直接点击运行，结果为：\n> - 10s start，now time：0\n> - now time: 1.003115\n> - now time: 2.007475\n> - now time: 3.010088\n> - now time: 4.011698\n> - now time: 5.013549\n> - now time: 6.015391\n> - now time: 7.01544\n> - now time: 8.018571\n> - now time: 9.019051\n> - 10s over，now time：10.00058  \n\n可以看到基本上是实现了的，但是我认为还是存在三个问题：\n- 无法设置非常小的时间间隔。假设游戏是以 30FPS 稳定运行，那么就不能通过这种方法完成每 0.03s 回调一次的功能，因为帧与帧之间是 0.02s。\n- 掉帧或者运行不稳定的话，不能每次时间间隔相等。其实从上面也可以看出来每次的时间间隔也是有细微差别的，如果一帧运算量过大导致掉帧，那这种差别就更大了。\n- 因为每一次离预期的时间间隔都会有细小的差别，以后每次回调的时间都是在上一次上再计算，就会导致差距越来越大。我试验到 1000s ，最后的结果为：\n> - now time: 999.7771\n> - 1000s over，now time：1000.004\n\n可以看到，现在已经到了 999.777，那我有理由相信 2000s 的时候，就会有 1s 以上的差值。\n\n- 改动一：将内部类提出来了，可行。\n- 将 Start 的返回值变成了 `IEnumerator` 之后，就不能有 `void Start` 了。\n\n# 工作线程\n想要运行多线程的任务，一种方法是在主线程创建新的线程，然后运行结束之后将结果与主线程同步，但这样适用于少量的，长期运作的线程，但游戏经常会创建大量的小体量的线程，这样的话每个线程的生命周期都很短，可能会成为 CPU 和操作系统的瓶颈。另一种方法是使用线程池，但如果同时有大量的活动线程，超过了 CPU 的物理核心数的话，就会导致线程之间的竞争，从而产生频繁的上下文切换。而 Job System 基本上保证一个 Work Thread 对应一个逻辑核心，以减少上下文的切换，Job System 会将 Job 放到一个工作队列，然后顺序的执行，每个 Job 之间可以是独立的，也可以是依赖的，Job System 会保证执行的顺序和依赖关系。\n在写多线程的代码时，如果出现了因为竞争导致的 bug，那绝对是非常痛苦的，因为不一定能复现。[Unity 官网](https://docs.unity3d.com/Manual/JobSystemSafetySystem.html) 上举了一个例子，如果主线程将一个引用传递给工作线程，那工作线程是不知道自己在改变这个值的时候，主线程是否在读取的，为了避免这种情况的发生，Unity 采用的策略是，在线程之间不传递引用，只传递拷贝，这样的话就需要保证可传递的数据类型都是 [blittable data types](https://en.wikipedia.org/wiki/Blittable_types) 的，这样在托管内存和非托管内存中移动时不需要转化（这里暂时不是很懂），具体的类型为：\n- System.Byte\n- System.SByte\n- System.Int16\n- System.UInt16\n- System.Int32\n- System.UInt32\n- System.Int64\n- System.UInt64\n- System.IntPtr\n- System.UIntPtr\n- System.Single\n- System.Double\n\n这样的显而易见的问题就是，会出现多份拷贝，并且在各个线程中不统一的情况。为了解决这个问题，再引出一个 `NativeContainer`，他其实是主线程开启的一块共享内存，工作线程可以直接操作这块内存中的数据，从而避免拷贝，这种数据的类型为 [NativeArray](https://docs.unity3d.com/ScriptReference/Unity.Collections.NativeArray_1.html),他可以保证多个线程在写入相同的共享内存时，会抛出异常，这时可以考虑将两者或者多者在共享内存的使用上设置为依赖关系。默认情况下，一个 job 对 NativeArray 有权限时，意味着它拥有读和写权限。如果只需要读的话，可以在加上 [ReadOnly], 两个同时只具有读权限的 Job 可以同时读取一块共享内存。使用方法如下：\n``` cs\n[ReadOnly]\npublic NativeArray<int> input;\n```\n注意：static 数据会绕过所有的安全系统。\n在创建 `NativeArray` 的时候，应该指定内存分配器的类型，有以下三种类型：\n- `Allocator.Temp` 具有最快的分配速度。此类型适用于寿命为一帧或更短的分配。不应该使用 Temp 将 NativeContainer 分配传递给作业。在从方法调用（例如 MonoBehaviour.Update 或从本机代码到托管代码的任何其他回调）返回之前，还需要调用 Dispose 方法。\n- `Allocator.TempJob` 的分配速度比 Temp 慢，但比 Persistent 快。此类型适用于寿命为四帧的分配，并具有线程安全性。如果没有在四帧内对其执行 Dispose 方法，控制台会输出一条从本机代码生成的警告。大多数小作业都使用这种 NativeContainer 分配类型。\n- `Allocator.Persistent` 是最慢的分配，但可以在您所需的任意时间内持续存在，如果有必要，可以在整个应用程序的生命周期内存在。此分配器是直接调用 malloc 的封装器。持续时间较长的作业可以使用这种 NativeContainer 分配类型。在非常注重性能的情况下不应使用 Persistent\n\n## 用法\n创建如下作业，注意类内的成员变量只能为 blittable type 或者 NativeContainer type 之一，blittable type 的成员变量是拷贝，所以主线程想要访问工作线程的数据的话，只能通过 NativeContainer type。\n``` cs\n// 将两个浮点值相加的作业\npublic struct MyJob : IJob\n{\n    public float a;\n    public float b;\n    public NativeArray<float> result;\n\n    public void Execute()\n    {\n        result[0] = a + b;\n    }\n}\n```\n\n调用 Schedule 会将作业放到作业队列中，并且作业一旦已经被调度（这里应该就是指进入了作业队列的意思吧），那么就无法终止。以下代码在主线程中：\n``` cs\n// 创建单个浮点数的本机数组以存储结果。此示例等待作业完成，仅用于演示目的\nNativeArray<float> result = new NativeArray<float>(1, Allocator.TempJob);\n\n// 设置作业数据\nMyJob jobData = new MyJob();\njobData.a = 10;\njobData.b = 10;\njobData.result = result;\n\n// 调度作业\nJobHandle handle = jobData.Schedule();\n\n// 等待作业完成\nhandle.Complete();\n\n// NativeArray 的所有副本都指向同一内存，您可以在\"您的\"NativeArray 副本中访问结果\nfloat aPlusB = result[0];\n\n// 释放由结果数组分配的内存\nresult.Dispose();\n```\n\n如果存在依赖的话，可以在调用 `Schedule` 方法时，将需要依赖的另一个 JobHandle 传入：\n``` cs\nJobHandle firstJobHandle = firstJob.Schedule();\nsecondJob.Schedule(firstJobHandle);\n```\n如果不止一个依赖的话，可以使用 `JobHandle.CombineDependencies` 进行整合：\n``` cs\nNativeArray<JobHandle> handles = new NativeArray<JobHandle>(numJobs, Allocator.TempJob);\n\n// 使用来自多个调度作业的 `JobHandles` 填充 `handles`...\n\nJobHandle jh = JobHandle.CombineDependencies(handles);\n```\n执行了 `Schedule` 只是将 Job 加入了作业队列，如果在主线程中需要结果的话，可以调用 `Complete` 方法，它将先执行调用者及其依赖项的任务，并将该作业的 NativeContainer 类型的所有权交还给主线程。\n\n``` cs\n// 作业代码\n// 将两个浮点值相加的作业\npublic struct MyJob : IJob\n{\n    public float a;\n    public float b;\n    public NativeArray<float> result;\n\n    public void Execute()\n    {\n        result[0] = a + b;\n    }\n}\n\n// 将一个值加一的作业\npublic struct AddOneJob : IJob\n{\n    public NativeArray<float> result;\n    \n    public void Execute()\n    {\n        result[0] = result[0] + 1;\n    }\n}\n```\n``` cs\n// 主线程代码\n// 创建单个浮点数的本机数组以存储结果。此示例等待作业完成\nNativeArray<float> result = new NativeArray<float>(1, Allocator.TempJob);\n\n// 设置作业 #1 的数据\nMyJob jobData = new MyJob();\njobData.a = 10;\njobData.b = 10;\njobData.result = result;\n\n// 调度作业 #1\nJobHandle firstHandle = jobData.Schedule();\n\n// 设置作业 #2 的数据\nAddOneJob incJobData = new AddOneJob();\nincJobData.result = result;\n\n// 调度作业 #2\nJobHandle secondHandle = incJobData.Schedule(firstHandle);\n\n// 等待作业 #2 完成\nsecondHandle.Complete();\n\n// NativeArray 的所有副本都指向同一内存，您可以在\"您的\"NativeArray 副本中访问结果\nfloat aPlusB = result[0];\n\n// 释放由结果数组分配的内存\nresult.Dispose();\n```\n\n## [ParallelFor Job](https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJobParallelFor.html)\n如果我们希望大量的对象执行相同的操作，那么可以使用 ParallelFor Job，结构体实现 IJobParallelFor 接口，就是 ParallelFor Job，它使用一个数据 NativeArray 作为其数据源。并对数据源中的每一项都调用一次 Execute 方法。Execute 方法中有一个整数参数。该索引用于访问和操作作业实现中的数据源的单个元素。下面的例子中出现了三个 NativeArray ，但唯一的那个数据源其实是传递了长度的 NativeArray，他决定了调用几次 Execute。ParallelFor Job 运行在多个核上，彼此独立，可以同时操作多个 Execute。\n``` cs\n// 作业代码\n// 将两个浮点值相加的作业\npublic struct MyParallelJob : IJobParallelFor\n{\n    [ReadOnly]\n    public NativeArray<float> a;\n    [ReadOnly]\n    public NativeArray<float> b;\n    public NativeArray<float> result;\n\n    public void Execute(int i)\n    {\n        result[i] = a[i] + b[i];\n    }\n}\n```\n\n``` cs\n// 主线程代码\nNativeArray<float> a = new NativeArray<float>(2, Allocator.TempJob);\n\nNativeArray<float> b = new NativeArray<float>(2, Allocator.TempJob);\n\nNativeArray<float> result = new NativeArray<float>(2, Allocator.TempJob);\n\na[0] = 1.1;\nb[0] = 2.2;\na[1] = 3.3;\nb[1] = 4.4;\n\nMyParallelJob jobData = new MyParallelJob();\njobData.a = a;  \njobData.b = b;\njobData.result = result;\n\n// 调度作业，为结果数组中的每个索引执行一个 Execute 方法，且每个处理批次只处理一项\nJobHandle handle = jobData.Schedule(result.Length, 1);\n\n// 等待作业完成\nhandle.Complete();\n\n// 释放数组分配的内存\na.Dispose();\nb.Dispose();\nresult.Dispose();\n```\n\n## IJobParallelForTransform\nParallelForTransform 作业是另一种 ParallelFor 作业；专为操作变换组件而设计。（好好用。。可以快速的实现大量物体的坐标变化）\n运行效果：\n将想要调整位置的物体的 transform 引用设置好，然后运行，点击按钮，三个物体的 position 会变成代码中 position(NativeArray<Vector3>) 的位置。\n![](/img/xys_4.4.11_1.jpg)\n![](/img/xys_4.4.11_2.jpg)\n\n``` cs\n// 文件名：Script_04_20.cs\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Jobs;\nusing Unity.Jobs;\nusing Unity.Collections;\n\npublic class Script_04_20 : MonoBehaviour\n{\n    public Transform[] trans;\n    private void OnGUI()\n    {\n        if (GUILayout.Button(\"开始调整位置\"))\n        {\n            // 定义并初始化 NativeArray。\n            NativeArray<Vector3> position = new NativeArray<Vector3>(trans.Length,Allocator.Persistent);\n            for(int i = 0; i < position.Length; ++i)\n            {\n                position[i] = Vector3.one * i;\n            }\n\n            // 获得 TransformAccessArray,当 transArray 改变时，trans 所对应的物体的 transform 也会跟着改变。\n            TransformAccessArray transArray = new TransformAccessArray(trans);\n            \n            // 启动工作线程\n            MyJob myJob = new MyJob { arry = position };\n            JobHandle hj = myJob.Schedule(transArray);\n            \n            // 等待工作线程结束\n            hj.Complete();\n\n            // 结束\n            transArray.Dispose();\n            position.Dispose();\n        }\n    }\n\n    public struct MyJob : IJobParallelForTransform\n    {\n        // 因为不需要对其有写操作，所以可以加一个 [ReadOnly]\n        [ReadOnly]public NativeArray<Vector3> arry;\n        public void Execute(int index, TransformAccess transform)\n        {\n            transform.position = arry[index];\n        }\n    }\n}\n\n```\n\n# Profiler\nWindow > Analysis > Profiler 可以访问 Profiler 窗口，详情参见 [性能分析器概述](https://docs.unity3d.com/cn/current/Manual/ProfilerWindow.html)","tags":["Unity","宣雨松"]},{"title":"委托与事件","url":"/2020/07/10/csharpTest2/","content":"\n# 委托\n笔者将其理解为一个特定类型的函数指针集合，增添或者删除就对应 add 和 remove。\n- 可以使用 `+=` 或者 `-=` 来增加或者减少委托指向的函数\n- 同一个委托内必须都是同一个类型的函数（相同的参数和相同的返回值）\n- 调用时是按照函数被添加的顺序来执行的\n- 如果是有返回的值的函数，那么调用结束之后只会获得最后一个函数的返回值，所以多播委托最好使用 `void` 类型的返回值函数\n- 当委托内一个函数都没有时，调用委托会得到空指针异常\n- 在逐一调用委托内的函数时，有任何一个函数抛出异常，那么整个过程都会停止\n\n``` cs\n// namespace/文件 : DelegateTest\n// delegate 的简单用法演示\nusing System;\n\nnamespace DelegateTest\n{\n    class Program\n    {\n        // 定义一个无返回值，两个 int 类型的形参的委托\n        delegate void TestDelegate(int a, int b);\n        static void Test1(int a, int b)\n        {\n            Console.WriteLine(\"Test1 function a={0},b={1}\", a, b);\n        }\n        static void Test2(int a, int b)\n        {\n            Console.WriteLine(\"Test2 function a={0},b={1}\", a, b);\n        }\n        static void Main(string[] args)\n        {\n            TestDelegate dele = new TestDelegate(Test1);\n            dele += Test2;\n\n            // 获得多播委托中的每个方法\n            Delegate[] delegates = dele.GetInvocationList();\n            foreach (Delegate d in delegates)\n            {\n                d.DynamicInvoke(1, 2); // 直接传递所有参数\n            }\n        }\n    }\n}\n```\n运行结果：\n>Test1 function a=1,b=2\n>Test2 function a=1,b=2\n\n# 事件\n事件是基于委托的，下面是一个小例子：\n``` cs\nusing System;\n\nnamespace DelegateTest\n{\n    class Program\n    {\n        // 定义一个无返回值，两个 int 类型的形参的委托\n        public delegate void TestDelegate(int a, int b);\n        public TestDelegate dele1;\n        public event TestDelegate dele2; // 对的，声明了一个事件\n        static void Test1(int a,int b)\n        {\n            Console.WriteLine(\"Test1 function a={0},b={1}\",a,b);\n        }\n        static void Test2(int a, int b)\n        {\n            Console.WriteLine(\"Test2 function a={0},b={1}\",a,b);\n        }\n        static void Main(string[] args)\n        {\n            // TestDelegate event dele = new TestDelegate(Test1);// 错的，因为事件不能作为局部变量\n            Program p = new Program();\n            \n            p.dele1 = new TestDelegate(Test1);\n            p.dele1 += Test2;\n            p.dele1(1, 2);\n\n            p.dele2 = new TestDelegate(Test1);\n            p.dele2 += Test2;\n            p.dele2(2, 3);\n        }\n    }\n}\n```\n\n运行结果：\n>Test1 function a=1,b=2\n>Test2 function a=1,b=2\n>Test1 function a=2,b=3\n>Test2 function a=2,b=3\n\n# 委托与事件的区别\n- 委托可以声明一个成员变量，或者是一个局部变量，但是事件只能作为成员变量，不能作为局部变量。\n- 事件只能在类的内部触发，不能在类的外部触发，可以在类的外部注册。委托可以在外部触发，但最好不要这么用。\n- 事件是一种特殊的委托，或者说是受限制的委托，只能使用 += 或者 -= 操作符，但二者本质上是同一个东西。\n- `event ActionHandler Tick` 编译成一个私有的委托实例\n- 使用的时候，委托常用来表示回调，事件用来表示外发的接口。\n\n# 观察者设计模式\n被观察者只有一个，假设我们叫他“楚门”，观察者有很多，当楚门的一些状态发生变化时，观察者也会做出相应的动作。\n在游戏中的体现可能是，比如被观察者是“开始按钮”，观察者是资源管理器，场景管理，音乐播放器等，当开始按钮被点击，也就是状态发生了改变，那么这些管理器也需要做出相应的动作。\n\n下面的例子是如果楚门发现了真相，那么所有人都欢呼，如果楚门在这个世界一直到死去，那么所有人都说遗憾，可惜。\n``` cs\nusing System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace ChuMenEvent\n{\n    class ChuMen\n    {\n        public delegate void findTheTruth(float time); // 发现真相所用时长\n        public findTheTruth findDelegate;\n        \n        public delegate void die(bool hasFindTheTruth); // 在人造环境中死去时是否已经发现真相\n        public die dieDelegate;            \n        public void FindTheTruth(float time)\n        {\n            Console.WriteLine(\"楚门用时 {0}years 发现了真相\", time);\n            if (findDelegate != null)\n            {\n                findDelegate(time);\n            }\n        }\n\n        public void Die(bool hasFindTheTruth)\n        {\n            Console.WriteLine(\"ChuMen Died\");\n            if(dieDelegate != null)\n            {\n                dieDelegate(hasFindTheTruth);\n            }\n        }\n\n\n    }\n}\n```\n``` cs\nusing System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace ChuMenEvent\n{\n    class Audience\n    {\n        private string identity;\n        private string name;\n\n        public Audience(string identity,string name)\n        {\n            this.identity = identity;\n            this.name = name;\n        }\n        public void Celebrate(float time)\n        {\n            if(time < 20)\n            {\n                Console.WriteLine(\"身为{0}的{1}说：不会吧不会吧，楚门不到20岁就发现了\", identity, name);\n            }\n            else\n            {\n                Console.WriteLine(\"身为{0}的{1}说：哎呀，被他发现了呢\", identity, name);\n            }\n        }\n\n        public void Regret(bool hasFindTheTruth)\n        {\n            if (hasFindTheTruth)\n            {\n                Console.WriteLine(\"身为{0}的{1}说：这是他的选择\", identity, name);\n            }\n            else\n            {\n                Console.WriteLine(\"身为{0}的{1}说：噶比（可惜）\", identity, name);\n            }\n        }\n\n    }\n}\n```\n\n``` cs\nusing System;\n\nnamespace ChuMenEvent\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            ChuMen chu = new ChuMen();\n            Audience director = new Audience(\"director\", \"aaa\");\n            chu.dieDelegate += director.Regret;\n            chu.findDelegate += director.Celebrate;\n            \n            Audience doctor = new Audience(\"doctor\", \"bbb\");\n            chu.dieDelegate += doctor.Regret;\n            chu.findDelegate += doctor.Celebrate;\n\n            chu.FindTheTruth(10);\n            chu.FindTheTruth(30);\n            chu.Die(true);\n            chu.Die(false);\n        }\n    }\n}\n\n```\n这样子的话，后面再加观察者是不需要改动被观察者(楚门)的代码的，只需要新建一个观察者，然后注册委托，就可以了。\n但上面的例子，每次都需要手动注册，也非常的麻烦，因为观察者只有一个，所以可以给被观察者的构造函数传递一个观察者的引用，并在构造函数中注册委托。\n下面将代码进行优化，并且将委托改为事件的写法。\n\n``` cs\nusing System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace ChuMenEvent\n{\n    class ChuMen\n    {\n        public delegate void findTheTruth(float time); // 发现真相所用时长\n        public event findTheTruth findDelegate; // 将委托变成了事件\n        \n        public delegate void die(bool hasFindTheTruth); // 在人造环境中死去时是否已经发现真相\n        public event die dieDelegate; // 将委托变为了事件            \n        public void FindTheTruth(float time)\n        {\n            Console.WriteLine(\"楚门用时 {0}years 发现了真相\", time);\n            if (findDelegate != null)\n            {\n                findDelegate(time);\n            }\n        }\n\n        public void Die(bool hasFindTheTruth)\n        {\n            Console.WriteLine(\"ChuMen Died\");\n            if(dieDelegate != null)\n            {\n                dieDelegate(hasFindTheTruth);\n            }\n        }\n\n\n    }\n}\n```\n\n``` cs\nusing System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace ChuMenEvent\n{\n    class Audience\n    {\n        private string identity;\n        private string name;\n\n        public Audience(string identity,string name,ChuMen chu) // 在构造函数里面注册事件\n        {\n            this.identity = identity;\n            this.name = name;\n            chu.dieDelegate += Regret;\n            chu.findDelegate += Celebrate;\n        }\n        public void Celebrate(float time)\n        {\n            if(time < 20)\n            {\n                Console.WriteLine(\"身为{0}的{1}说：不会吧不会吧，楚门不到20岁就发现了\", identity, name);\n            }\n            else\n            {\n                Console.WriteLine(\"身为{0}的{1}说：哎呀，被他发现了呢\", identity, name);\n            }\n        }\n\n        public void Regret(bool hasFindTheTruth)\n        {\n            if (hasFindTheTruth)\n            {\n                Console.WriteLine(\"身为{0}的{1}说：这是他的选择\", identity, name);\n            }\n            else\n            {\n                Console.WriteLine(\"身为{0}的{1}说：噶比（可惜）\", identity, name);\n            }\n        }\n\n    }\n}\n```\n``` cs\nusing System;\n\nnamespace ChuMenEvent\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            ChuMen chu = new ChuMen();\n            Audience director = new Audience(\"director\", \"aaa\",chu); // 将被观察者的引用传给构造函数，并在其中注册委托\n            // chu.dieDelegate += director.Regret; // 这些都不需要了\n            // chu.findDelegate += director.Celebrate;\n            \n            Audience doctor = new Audience(\"doctor\", \"bbb\",chu);\n            // chu.dieDelegate += doctor.Regret;\n            // chu.findDelegate += doctor.Celebrate;\n\n            // chu.dieDelegate(true); //事件不能在类的外部调用，当这个是委托的时候可以，但最好也不要这么用\n\n            chu.FindTheTruth(10);\n            chu.FindTheTruth(30);\n            chu.Die(true);\n            chu.Die(false);\n        }\n    }\n}\n```\n运行结果同上。","tags":["c-sharp"]},{"title":"单例脚本和定时器","url":"/2020/07/09/xys-4.4.8-4.4.9/","content":"\n# 单例脚本\n``` cs\n// 文件名：SingleScript.cs\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\n// 单例脚本\npublic class SingleScript : MonoBehaviour\n{\n    public static SingleScript instance;\n\n    // 静态构造函数\n    static SingleScript()\n    {\n        GameObject go = new GameObject(\"#Global#\");\n        DontDestroyOnLoad(go);\n        instance =  go.AddComponent<SingleScript>();\n        Debug.Log(\"static construct function has finished\");\n    }\n\n    // Start is called before the first frame update\n    void Start()\n    {\n        Debug.Log(\"Global script start\");\n    }\n    \n    void Awake()\n    {\n        Debug.Log(\"Global script Awake\");\n    }\n    \n    public void Dosomething()\n    {\n        Debug.Log(\"Global script do something\");\n    }\n}\n\n```\n``` cs\n// 文件名：SingleTestMain.cs\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class SingleTestMain : MonoBehaviour\n{\n    private void OnGUI()\n    {\n        if (GUILayout.Button(\"执行单例脚本中的方法\"))\n        {\n            SingleScript.instance.Dosomething();\n        }\n    }\n}\n\n```\n\n运行过程及说明：\nSingleTestMain.cs 需要挂载在物体身上，因为要用它来模拟调用 Global 脚本中的方法。SingleScript.cs 不需要在编辑器模式下就挂载在物体身上，但是依然需要继承自 Monobehaviour，因为在点击 \"执行单例脚本中的方法\" 的 Button 时，会在场景中创建一个 \"#Global#\" 的 GameObject，并添加一个 SingleScript 的组件，并将 instance 指向该组件。输出如下：\n\n> - Global script Awake\n> - static construct function has finished\n> - Global script do something\n> - Global script start\n\n可以看到，在没有点 Button 之前是没有任何输出的，并且官网上也提到 [静态构造函数](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/static-constructors) 的调用时机不受我们控制。暂时只需要记住静态构造函数用于初始化任何静态数据，或执行仅需执行一次的特定操作。 将在创建第一个实例或引用任何静态成员之前自动调用静态构造函数。\n还需要注意一下 4 个函数的执行顺序，Awake 是在 `go.AddComponent<SingleScript>()` 时执行的，然后静态构造函数执行完，再执行成员方法，最后才是 Start 方法。\n\n# 定时器\n# UnityAction\n`public delegate void UnityAction();`\n类似于 c# 中的 `Action` ，是一个没有返回值，没有参数的委托。\n# 协程\n注意：禁用 MonoBehaviour 时，不会停止协程，仅在明确销毁 MonoBehaviour 时才会停止协程。可以使用 MonoBehaviour.StopCoroutine 和 MonoBehaviour.StopAllCoroutines 来停止协程。销毁 MonoBehaviour 时，也会停止协程。\n# 定时器实现\n定时器可以使用协程来完成，但是这样就必须依赖于脚本，但是我们可以使用一个继承自 MonoBehaviour 的空的内部类来封装一个不依赖于脚本的定时器。\n代码如下：\n``` cs\n// 文件名： Script_04_18.cs\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Events; // UnityAction\n\n// 利用继承自 Monobehaviour 的内部类做一个不依赖于脚本的定时器\n// 类名可以换成 WaitTimeManager 之类的\npublic class Script_04_18\n{\n    private static TaskBehaviour m_task;\n\n    // 用编写单例脚本的方法完成新建一个全局的 WaitTimeManager，他是一个物体，但主要功能是在其他代码中方便的使用定时器。\n    static Script_04_18()\n    {\n        GameObject go = new GameObject(\"#WaitTimeManager#\");\n        GameObject.DontDestroyOnLoad(go);\n        TaskBehaviour t = go.AddComponent<TaskBehaviour>();\n        m_task = t;\n    }\n\n    // 供外部调用的开启定时器任务函数\n    public static Coroutine WaitTime(float time,UnityAction callback)\n    {\n        return m_task.StartCoroutine(Coroutine(time, callback));\n    }\n\n    // 供外部调用的停止定时器任务的函数，这里使用 ref 是因为函数内需要将传过来的协程置空\n    public static void StopCoroutine(ref Coroutine coroutine)\n    {\n        if (coroutine != null)\n        {\n            m_task.StopCoroutine(coroutine);\n            coroutine = null;\n        }\n    }\n\n    private static IEnumerator Coroutine(float time,UnityAction callback)\n    {\n        yield return new WaitForSeconds(time);\n        if(callback != null)\n        {\n            callback();\n        }\n    }\n\n    // 工具人哈哈哈\n    class TaskBehaviour:MonoBehaviour\n    {}\n}\n```\n\n``` cs\n// 文件名：Script_04_18_main.cs\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Events;\n\npublic class Script_04_18_main : MonoBehaviour\n{\n    private Coroutine coroutine;\n    private void OnGUI()\n    {\n        if (GUILayout.Button(\"开启定时任务\"))\n        {\n            Debug.Log(\"10 秒之后打印一段 Rap\");\n            \n            // 第二个参数是 UnityAction（委托） ，但是可以直接传递函数\n            coroutine = Script_04_18.WaitTime(10, PrintRap);\n        }\n\n        if (GUILayout.Button(\"停止定时任务\"))\n        {\n            Script_04_18.StopCoroutine(ref coroutine);\n        }\n    }\n\n    static void PrintRap()\n    {\n        Debug.Log(\"一段 Rap\");\n    }\n}\n```\n\n运行效果：\n在点击了 “开启定时任务” 十秒之后，会打印出\n> - 10 秒之后打印一段 Rap\n> - 一段 Rap\n\n如果在十秒之前，点击了 “停止定时任务”，那么不会有 “一段 Rap” 的输出","tags":["Unity","宣雨松"]},{"title":"脚本的 Attributes 特性","url":"/2020/07/08/xys-4.4.7/","content":"\n# 脚本的 Attributes 特性\n## 运行结果\n只需要声明变量的时候加上 `[RangeIntAttribution(1.0f,100.0f)]` 就可以设置成员变量的范围了，并且在 Inspector 面板上如下显示：\n![](/img/xys_4.4.7.png)\n\n## 代码实现\n``` cs\n// 文件名：Script_04_13\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Script_04_13 : MonoBehaviour\n{   // 使用 Range 可以直接创建一个有范围的 Int 或者 Float 值，并且在 Inspector 中显示一个滑动条\n    // [Range(1, 100)]\n\n    // 这里演示自定义 Attribution,为了实验官网的例子，都改成了 float 类型\n    [RangeIntAttribution(1.0f,100.0f)]\n    public float rangeFloat;\n\n    [RangeIntAttribution(10, 60)]\n    public int  rangeInt;\n\n    [RangeIntAttribution('a','z')]\n    public int rangeInt2;\n}\n\n```\n\n``` cs\n// 文件名：RangeIntAttribution\nusing System.Collections;\nusing System.Collections.Generic;\nusing System;\nusing UnityEngine;\n#if UNITY_EDITOR\nusing UnityEditor;\n#endif\npublic sealed class RangeIntAttribution : PropertyAttribute\n{\n    // readonly 值类型只可在声明或者构造函数中改变值。\n    public readonly float minValue;\n    public readonly float maxValue;\n\n    public RangeIntAttribution(float minValue, float maxValue)\n    {\n        this.minValue = minValue;\n        this.maxValue = maxValue;\n    }\n}\n\n#if UNITY_EDITOR\n[CustomPropertyDrawer(typeof(RangeIntAttribution))]\npublic sealed class RangeIntDrawer:PropertyDrawer\n{\n    public override float GetPropertyHeight(SerializedProperty property, GUIContent label)\n    {\n        return 90; // 设置面板高度 \n    }\n    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)\n    {\n        // 错的，内含 attribute，不过要向下转型\n        // PropertyAttribute attribute = new RangeIntAttribution(1, 100);\n\n        RangeIntAttribution attribute = this.attribute as RangeIntAttribution;\n        property.floatValue = Mathf.Clamp(property.floatValue, attribute.minValue, attribute.maxValue);\n        \n        // 可以使用 positopn 的前三个值，高度要自己估算一下\n        EditorGUI.HelpBox(new Rect(position.x,position.y,position.width,35), string.Format(\n            \"请输入一个范围从{0}到{1}的整数\",attribute.minValue, attribute.maxValue), MessageType.Info);\n        EditorGUI.PropertyField(new Rect(position.x, position.y + 35, position.width, 20), property, label);\n\n        // 再按照官网上的画一个滑动条 https://docs.unity3d.com/ScriptReference/PropertyDrawer.html\n        if(property.propertyType == SerializedPropertyType.Float)\n        {\n            EditorGUI.Slider(new Rect(position.x, position.y + 65, position.width, 20),\n                property,attribute.minValue, attribute.maxValue);\n        }\n        else if (property.propertyType == SerializedPropertyType.Integer)\n        {\n            EditorGUI.IntSlider(new Rect(position.x, position.y + 65, position.width, 20), property,\n                Convert.ToInt32(attribute.minValue), Convert.ToInt32(attribute.maxValue));\n        }\n        else\n        {\n            EditorGUI.LabelField(new Rect(position.x, position.y + 65, position.width, 20),label.text,\n                \"use Range with int or float\");\n        }\n    }\n}\n#endif\n```\n# RangeAttribute\n上述实现了一个有范围的变量，但其实这个功能在 UnityEngine 里面已经有了，可见[RangeAttribute](https://docs.unity3d.com/ScriptReference/RangeAttribute.html)，这个主要是要训练一下自定义标签，可以看到其实这个标签调用的应该是 xxxAttribute 类的构造函数。\nUnity 里面自带了很多标签，API 可以在 UnityEngine.Attributes 和 UnityEditor.Attributes 中找到，","tags":["Unity","宣雨松"]},{"title":"传参与readonly","url":"/2020/07/08/csharpTest/","content":"\n# 传参\nc# 和 c++ 感觉很不同的一点就是关于 new 的使用，在 c++ 中，new 只是动态分配一块内存，比如 `Person p(10,\"zhangqr\");` 和 `Person *p = new Perspn(10,\"zhangqr\");` 前者 p 就是一个实体，后者 p 只是一个指向实体的指针。而在 c# 中，`Person p;` 表示申明了一个指向 null 的 Person 类型指针，想要在申明时就初始化需要使用 `Person p = new Person(10,\"zhangqr\");`，这里的 p 本质上是一个指针。\n\n``` cs\nusing System;\n\nnamespace csharpTest\n{\n    class Product\n    {\n        private static int constructTimes = 0;\n        public Product(string name, int newID)\n        {\n            ItemName = name;\n            ItemID = newID;\n            Console.WriteLine(\"product 被构造{0}次, name:{1},id:{2}\", ++constructTimes,this.ItemName,this.ItemID);\n        }\n        public Product( Product product)\n        {\n            Console.WriteLine(\"product 拷贝构造函数被调用一次\");\n        }\n\n        public string ItemName { get; set; }\n        public int ItemID { get; set; }\n    }\n\n    // This method displays the following output:\n    // Original values in Main.  Name: Fasteners, ID: 54321\n    // Back in Main.  Name: Stapler, ID: 12345\n    class Program\n    {\n        private static void ChangeByReference(/*ref*/ Product itemRef)\n        {\n            // Change the address that is stored in the itemRef parameter.\n            itemRef = new Product(\"Stapler\", 99999);\n\n            // You can change the value of one of the properties of\n            // itemRef. The change happens to item in Main as well.\n            itemRef.ItemID = 12345;\n        }\n\n        private static void ModifyProductsByReference()\n        {\n            // Declare an instance of Product and display its initial values.\n            Product item = new Product(\"Fasteners\", 54321);\n            System.Console.WriteLine(\"Original values in Main.  Name: {0}, ID: {1}\\n\",\n                item.ItemName, item.ItemID);\n\n            // Pass the product instance to ChangeByReference.\n            ChangeByReference(/*ref*/ item);\n            System.Console.WriteLine(\"Back in Main.  Name: {0}, ID: {1}\\n\",\n                item.ItemName, item.ItemID);\n\n            // Product item2 = new Product(item);\n        }\n        static void Main(string[] args)\n        {\n            ModifyProductsByReference();\n        }\n    }\n}\n```\n\n运行结果:\n>product 被构造1次, name:Fasteners,id:54321\n>Original values in Main.  Name: Fasteners, ID: 54321\n>\n>product 被构造2次, name:Stapler,id:99999\n>Back in Main.  Name: Fasteners, ID: 54321\n\n解释：\n![](/img/paramTransfer1.png)\n在函数传递的时候拷贝构造函数也没有被调用，这一点也跟 c++ 不一样，但理解了其实传递的是指针之后就会明白，其实还是一样的，拷贝构造是在用一个实例创建另一个实例的时候会调用，但其实从图中可以看出来从头到尾只有一个实例，增加的也只是指针而已。\n\n如果将 `itemRef = new Product(\"Stapler\", 99999);`注释掉的话，运行结果如下，这个从图中也很好理解，最后就是两个指针指向同一个实例。\n>product 被构造1次, name:Fasteners,id:54321\n>Original values in Main.  Name: Fasteners, ID: 54321\n>\n>Back in Main.  Name: Fasteners, ID: 12345\n\n将两个 ref 的注释去掉之后，运行结果为：\n>product 被构造1次, name:Fasteners,id:54321\n>Original values in Main.  Name: Fasteners, ID: 54321\n>\n>product 被构造2次, name:Stapler,id:99999\n>Back in Main.  Name: Stapler, ID: 12345\n\n解释：\n![](/img/paramTransfer2.png)\n当传参的时候申明了 ref ，我是将其理解成 c++ 的引用，也操作的是同一个指针，但是有两个不同的名字。\n\n以上并未加验证，本来是想通过 `unsafe` 来取地址验证一下，但是 `unsafe` 需要在声明时就加上 * ，也就是像 c++ 的写法一样，而我是想用 c# 的写法来取到地址，所以暂时没找到验证方法，因为目前猜测都合理，所以暂且这么理解。\n\n# readonly 与 ref\n先上实验代码\n\n``` cs\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class ReadonlyTest : MonoBehaviour\n{\n    public void OnGUI()\n    {\n        if(GUILayout.Button(\"测试 readonly \"))\n        {\n            // 使用声明 readonly 成员变量时赋的值\n            ReadOnlyData data = new ReadOnlyData();\n            Debug.LogFormat(\"使用申明时的赋值，value types:{0},reference types:a={1},b={2}\", data.age,data.refType.a,data.refType.b);\n            \n            // 使用构造函数给 readonly 成员变量赋值\n            ReadOnlyDataB dataB = new ReadOnlyDataB { a = 15, b = 25 };\n            data = new ReadOnlyData(15, ref dataB);\n            Debug.LogFormat(\"使用构造函数中的赋值，value types:{0},reference types:a={1},b={2}\", data.age,data.refType.a, data.refType.b);\n\n            // 改变局部变量的值\n            Debug.Log(\"局部变量是否与 reference type 相同（Equals函数）\"+ dataB.Equals(data.refType));\n            dataB.a = 25;\n            dataB.b = 35;\n            Debug.LogFormat(\"改变了局部变量所指的对象，value types:{0},reference types:a={1},b={2}，局部变量:a={3},b={4}\", \n                            data.age, data.refType.a, data.refType.b,dataB.a,dataB.b);\n\n            // 改变 reference type 所指的值\n            Debug.Log(\"局部变量是否与 reference type 相同（Equals函数）\" + dataB.Equals(data.refType));\n            data.refType.a = 35;\n            data.refType.b = 45;\n            Debug.LogFormat(\"改变 reference type 所指的对象，value types:{0},reference types:a={1},b={2}，局部变量:a={3},b={4}\",\n                            data.age, data.refType.a, data.refType.b, dataB.a, dataB.b);\n\n            // 改变局部变量的指向\n            dataB = new ReadOnlyDataB { a = 45, b = 55 };\n            Debug.Log(\"改变了局部变量的指向后，是否还与 reference type 相同（Equals函数）\" + dataB.Equals(data.refType));\n            Debug.LogFormat(\"改变了 readonly reference type 所指的对象，value types:{0},reference types:a={1},b={2}\", data.age, data.refType.a, data.refType.b);\n\n            // data.ChangeReferenceValue();\n            // Debug.Log(\"类内改变 reference type 之后，是否还与 reference type 相同（Equals函数）\" + dataB.Equals(data.refType));\n            // Debug.LogFormat(\"类内改变 reference type 之后，value types:{0},reference types:a={1},b={2}，局部变量:a={3},b={4}\",\n                            data.age, data.refType.a, data.refType.b, dataB.a, dataB.b);\n            // data.refType = new ReadOnlyDataB { a = 45, b = 55 };// 无法对只读字段进行赋值，初始化和构造函数除外。\n            // data1.age = 20; // 无法对只读字段进行赋值，初始化和构造函数除外。\n\n        }\n    }\n}\n\npublic class ReadOnlyData\n{\n    // readonly 变量直接在申明的时候赋值。\n    public readonly int age;\n\n    // reference types 用 readonly 修饰\n    public readonly ReadOnlyDataB refType = new ReadOnlyDataB { a = 10, b = 20 };\n\n    public ReadOnlyData(int age,ref ReadOnlyDataB refType)\n    {\n        this.age = age; // 可以， readonly 变量可以在构造函数中赋值。\n        this.refType = refType;\n    }\n\n    public ReadOnlyData()// :this(10,new ReadOnlyDataB { a=10,b=20})\n    {\n    }\n\n    public void ChangeAge(int age)\n    {\n        // this.age = age; // 错误，除了申明和构造函数中不能对 readonly 赋值\n    }\n\n    public void ChangeReferenceValue()\n    {\n        // this.refType = new ReadOnlyDataB { a = 45, b = 55 };// 错误，除了申明和构造函数中不能对 readonly 赋值\n    }\n}\n\npublic class ReadOnlyDataB\n{\n    public int a;\n    public int b;\n}\n\n\n```\n\n运行结果为：\n\n> - 使用声明时的赋值，value types:10,reference types:a=10,b=20\n> - 使用构造函数中的赋值，value types:15,reference types:a=15,b=25\n> - 局部变量是否与 reference type 相同（Equals函数）True\n> - 改变了局部变量所指的对象，value types:15,reference types:a=25,b=35，局部变量:a=25,b=35\n> - 局部变量是否与 reference type 相同（Equals函数）True\n> - 改变 reference type 所指的对象，value types:15,reference types:a=35,b=45，局部变量:a=35,b=45\n> - 改变了局部变量的指向后，是否还与 reference type 相同（Equals函数）False\n> - 改变了局部变量的指向后，value types:15,reference types:a=35,b=45，局部变量:a=45,b=55\n\n上面结果都是合理的，然后我在传参的时候将引用类型设置为了 ref，具体是：\n- ` data = new ReadOnlyData(15, dataB);` 改为 `data = new ReadOnlyData(15, ref dataB);`\n- `public readonly ReadOnlyDataB refType;` 改为 `public readonly ReadOnlyDataB refType = new ReadOnlyDataB { a = 10, b = 20 };`\n- `public ReadOnlyData() :this(10,new ReadOnlyDataB { a=10,b=20})` 改为 `public ReadOnlyData() // :this(10,new ReadOnlyDataB { a=10,b=20})`\n- `public ReadOnlyData(int age,ReadOnlyDataB refType)` 改为 `    public ReadOnlyData(int age,ref ReadOnlyDataB refType)`\n按我的设想，此时 `成员变量 refType`、`ReadOnlyData 的二参 refType` 和 `局部变量data` 应该都是同一个指针，只是有不同的别名而已，所以在 `dataB = new ReadOnlyDataB { a = 45, b = 55 };` 之后，三者所指向的实例应该是一样的，结果并不是，运行结果是跟一次完全一样的，在梳理了 ref 的用法之后才惊觉 `ReadOnlyData 的二参 refType` 和 `局部变量data` 是同一个指针，但 `成员变量 refType` 并不是，因为他是直接用赋值符号得到的。验证如下：\n``` cs\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class ReadonlyTest : MonoBehaviour\n{\n    public void OnGUI()\n    {\n        if(GUILayout.Button(\"测试 readonly \"))\n        {\n            // 使用声明 readonly 成员变量时赋的值\n            ReadOnlyData data = new ReadOnlyData();\n            Debug.LogFormat(\"使用申明时的赋值，value types:{0},reference types:a={1},b={2}\", data.age,data.refType.a,data.refType.b);\n            \n            // 使用构造函数给 readonly 成员变量赋值\n            ReadOnlyDataB dataB = new ReadOnlyDataB { a = 15, b = 25 };\n            data = new ReadOnlyData(15, ref dataB);\n            Debug.LogFormat(\"使用构造函数中的赋值，value types:{0},reference types:a={1},b={2}\", data.age,data.refType.a, data.refType.b);\n\n            // 改变局部变量的值\n            //Debug.Log(\"局部变量是否与 reference type 相同（Equals函数）\"+ dataB.Equals(data.refType));\n            //dataB.a = 25;\n            //dataB.b = 35;\n            //Debug.LogFormat(\"改变了局部变量所指的对象，value types:{0},reference types:a={1},b={2}，局部变量:a={3},b={4}\", \n            //                data.age, data.refType.a, data.refType.b,dataB.a,dataB.b);\n\n            //// 改变 reference type 所指的值\n            //Debug.Log(\"局部变量是否与 reference type 相同（Equals函数）\" + dataB.Equals(data.refType));\n            //data.refType.a = 35;\n            //data.refType.b = 45;\n            //Debug.LogFormat(\"改变 reference type 所指的对象，value types:{0},reference types:a={1},b={2}，局部变量:a={3},b={4}\",\n            //                data.age, data.refType.a, data.refType.b, dataB.a, dataB.b);\n\n            // 改变局部变量的指向\n            // dataB = new ReadOnlyDataB { a = 45, b = 55 };\n            Debug.Log(\"改变了局部变量的指向后，是否还与 reference type 相同（Equals函数）\" + dataB.Equals(data.refType));\n            Debug.LogFormat(\"改变了局部变量的指向后，value types:{0},reference types:a={1},b={2}，局部变量:a={3},b={4}\",\n                            data.age, data.refType.a, data.refType.b, dataB.a, dataB.b);\n\n            // data.refType = new ReadOnlyDataB { a = 45, b = 55 };// 无法对只读字段进行赋值，初始化和构造函数除外。\n            // data1.age = 20; // 无法对只读字段进行赋值，初始化和构造函数除外。\n\n        }\n    }\n}\n\npublic class ReadOnlyData\n{\n    // readonly 变量直接在申明的时候赋值。\n    public readonly int age  = 10;\n\n    // reference types 用 readonly 修饰\n    public readonly ReadOnlyDataB refType = new ReadOnlyDataB { a = 10, b = 20 };\n\n    public ReadOnlyData(int age,ref ReadOnlyDataB refType)\n    {\n        refType = new ReadOnlyDataB { a = 100, b = 101 };\n        this.age = age; // 可以， readonly 变量可以在构造函数中赋值。\n        this.refType = refType;\n        this.refType.a = 120;\n        this.refType.b = 121;\n    }\n\n    public ReadOnlyData() // :this(10,new ReadOnlyDataB { a=10,b=20})\n    {\n    }\n\n    public void ChangeAge(int age)\n    {\n        // this.age = age; // 错误，除了申明和构造函数中不能对 readonly 赋值\n    }\n\n    public void ChangeReferenceValue()\n    {\n        // this.refType = new ReadOnlyDataB { a = 45, b = 55 };// 错误，除了申明和构造函数中不能对 readonly 赋值\n    }\n}\n\npublic class ReadOnlyDataB\n{\n    public int a;\n    public int b;\n}\n```\n\n运行结果：\n> - 使用申明时的赋值，value types:10,reference types:a=10,b=20\n> - 使用构造函数中的赋值，value types:15,reference types:a=120,b=121\n> - 改变了局部变量的指向后，是否还与 reference type 相同（Equals函数）True\n> - 改变了局部变量的指向后，value types:15,reference types:a=120,b=121，局部变量:a=120,b=121\n\n解释如图：\n![](/img/paramTransfer3.png)\n\n将 ref 修饰词给去掉之后：\n> - 使用申明时的赋值，value types:10,reference types:a=10,b=20\n> - 使用构造函数中的赋值，value types:15,reference types:a=120,b=121    \n> - 改变了局部变量的指向后，是否还与 reference type 相同（Equals函数）False\n> - 改变了局部变量的指向后，value types:15,reference types:a=120,b=121，局部变量:a=15,b=25\n\n解释如图：\n![](/img/paramTransfer4.png)\n\n","tags":["c-sharp"]},{"title":"ScriptableObject","url":"/2020/07/05/xys-4.4.6/","content":"\n# ScriptableObject 的使用\n## 运行结果\n可以在 Aseets/Create 创建 “类对象资源”，也可以在 Assets 面板的 “+” 中创建。如果需要在游戏运行时加载可以将它放到 Resources 文件夹中。\n![](/img/xys_4.4.6_1.png)\n创建完成后，生成 “New Script_04_12.asset”，并且点击的话会在  Inspector 面板显示如下。可以看到显示了我们在继承了 ScriptableObject 的类中定义的成员变量( 代码见 Script_04_12.cs )。并且可以在 Inspector 面板修改对应的值。\n![](/img/xys_4.4.6_2.png)\n上述方法是点击一下 Aseets/Create/Script_04_12 创建一个空的 “类对象资源” ，然后需要自己手动在 Inspector面板赋值，这样的话需要大批量的生成这种资源就很麻烦，所以可以在代码中将赋值好，然后只点击一个按钮就可以生成赋值好的资源。代码见 Script_04_12_create.cs\n![](/img/xys_4.4.6_4.png)\n\n## 代码实现\n``` cs\n// 文件名：Script_04_12.cs\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\n[CreateAssetMenu]\npublic class Script_04_12 : ScriptableObject\n{\n    [SerializeField]\n    public List<PlayInfo> m_playInfo;\n\n    [System.Serializable]\n    public class PlayInfo\n    {\n        public int id;\n        public string name;\n    }\n}\n```\n\n``` cs\n// 文件名：Script_04_12_main.cs\n// 可以在运行时加载 “类对象资源”，详情如图。\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Script_04_12_main : MonoBehaviour\n{\n    private void OnGUI()\n    {\n        if (GUILayout.Button(\"加载Script_04_12\"))\n        {\n            // New Script_04_12 是通过[CreateAssetMenu],然后在Asset右击新建的。\n            // 要将 New Script_04_12 放到资源的 Resources 文件夹下面\n            Script_04_12 script = Resources.Load<Script_04_12>(\"New Script_04_12\");\n            Debug.LogFormat(\"加载的 script 第一个元素的 id 为 {0}，name 为 {1}\", script.m_playInfo[0].id, script.m_playInfo[0].name);\n        }\n    }\n}\n```\n![](/img/xys_4.4.6_3.png)\n\n``` cs\n// 文件名: Script_04_12_create.cs\n// 要放在 Editor 文件夹下。Editor 文件夹位置和数量不限\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEditor;\n\npublic class Script_04_12_create\n{\n    [MenuItem(\"Assets/Create script_04_12\")]\n    static void Create()\n    {\n        Script_04_12 script = ScriptableObject.CreateInstance<Script_04_12>();\n\n        // 填充数据\n        script.m_playInfo = new List<Script_04_12.PlayInfo>();\n\n        //Script_04_12.PlayInfo info = new Script_04_12.PlayInfo();\n        //info.id = 10086;\n        //info.name = \"张思\";\n        //script.m_playInfo.Add(info);\n        //上面可化简为\n        script.m_playInfo.Add(new Script_04_12.PlayInfo() { id = 10086, name = \"张思\" });\n\n        // 储存数据\n        AssetDatabase.CreateAsset(script, \"Assets/Resources/Create Script_04_12.asset\");\n        AssetDatabase.SaveAssets();\n        AssetDatabase.Refresh();\n    }\n}\n\n```\n## 感想\n### 命名规范\n雨松大大用的命名规范有点让人迷惑，一开始我以为它是将私有成员变量都使用 `m_` 为前缀，然后使用 Pascal 大小写，但是\n` [SerializeField] public List<PlayInfo> m_playInfo;` 就难以解释。\n\n### 关于 “类对象资源” \n这个名字是我自己取的哈哈，因为很好理解，就是类的一个实例化对象被以资源的形式存储。一般有三种操作方式：\n- 在运行时使用 `Resources.load<>()` 来加载并使用\n- 使用在继承了 ScriptableObject 的类上用 `[CreateAssetMenu]` 来修饰，但这样创建出来的 “类对象资源” 是空的，需要自己在 Inspector 面板上再赋值\n- 使用 `ScriptableObject.CreateInstance<>()`、`AssetDatabase.CreateAssets()`、`AssetDatabase.SaveAssets()`、`AssetDatabase.Refresh()` 组合拳，代码中填充好将要保存的 “类对象资源” 的数值之后再保存到 Assets 里面。\n\n### markdown 代码高亮\n不能用 c-sharp 或者 c# ，应该写成 cs（震惊）","tags":["Unity","宣雨松"]},{"title":"序列化/反序列化监听","url":"/2020/07/03/xys-4.4.5/","content":"\n# 实现字典的序列化\n## 运行结果\n![](/img/picture4-18.png)\n点一下 “+” Button可以新增一个键值对，可以在 Inspector 面板设置键值的值，但不知道为什么 key 到输入框的距离不可控，只有将 inspector 面板变大才能完全看到，而且也没有禁用组件的勾选框了。\n\n## 代码实现\n``` cs\n// Script_04_11.cs 文件\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n#if UNITY_EDITOR\nusing UnityEditor;\n#endif\n\n// 继承 ISerializationCallbackReceiver 接口，实现 OnBeforeSerialize 和 OnAfterDeserialize\npublic class Script_04_11 : MonoBehaviour,ISerializationCallbackReceiver\n{\n    [SerializeField]\n    // [HideInInspector] 加了SerializeField会显示在Inspector面板上，除非再加上一个 HideInInspector\n    private List<string> key_list = new List<string>();\n    [SerializeField]\n    private List<Sprite> value_list = new List<Sprite>();\n\n    //这里是 public 是因为下面要用 (target as Script04_11).m_spriteDic，这里最好也不要用 m_ 命名。\n    public Dictionary<string, Sprite> m_spriteDic = new Dictionary<string, Sprite>();\n\n    #region ISerializationCallbackReceiver implementation\n    // 序列化之前将字典里的内容传递到两个列表\n    void ISerializationCallbackReceiver.OnBeforeSerialize()\n    // public void OnBeforeSerialize()\n    {\n        key_list.Clear();\n        value_list.Clear();\n        foreach(KeyValuePair<string,Sprite> pair in m_spriteDic)\n        {\n            key_list.Add(pair.Key);\n            value_list.Add(pair.Value);\n        }\n    }\n\n    //反序列化之后将两个列表里的内容传递到词典里\n    void ISerializationCallbackReceiver.OnAfterDeserialize()\n    // public void OnAfterDeserialize()\n    {\n        m_spriteDic.Clear();\n        int size = key_list.Count;\n        if (size != value_list.Count)\n        {\n            Debug.LogError(\"反序列化时键值对数量不匹配\");\n            return;\n        }\n        for(int i = 0; i < size; i++)\n        {\n            m_spriteDic[key_list[i]] = value_list[i];\n        }\n    }\n    #endregion\n}\n\n#if UNITY_EDITOR\n[CustomEditor(typeof(Script_04_11))]\npublic class Script04_11_editor : Editor\n{\n    public override void OnInspectorGUI()\n    {\n        // base.OnInspectorGUI();\n        serializedObject.Update();\n        SerializedProperty keyProperty = serializedObject.FindProperty(\"key_list\");\n        SerializedProperty valueProperty = serializedObject.FindProperty(\"value_list\");\n        GUILayout.BeginVertical();\n\n        // ? 是因为反序列化已经完成了所以不需要再次判断键值列表数量是否相等？\n        int size = keyProperty.arraySize;\n        for(int i = 0; i < size; i++)\n        {\n            GUILayout.BeginHorizontal();\n            //x 此时 keyProperty 是一个数组，要先获取每个 string 元素\n            //keyProperty.stringValue = EditorGUILayout.TextField(\"主键\", keyProperty.GetArrayElementAtIndex(i).stringValue);\n            //valueProperty.objectReferenceValue = EditorGUILayout.ObjectField(\"图片\",valueProperty.GetArrayElementAtIndex(i).objectReferenceValue, typeof(Sprite), false);\n\n            SerializedProperty key = keyProperty.GetArrayElementAtIndex(i);\n            SerializedProperty value = valueProperty.GetArrayElementAtIndex(i);\n            key.stringValue = EditorGUILayout.TextField(\"key\", key.stringValue);\n            value.objectReferenceValue = EditorGUILayout.ObjectField(\"value\", value.objectReferenceValue, typeof(Sprite), true);\n\n            GUILayout.EndHorizontal();        \n        }\n        //GUILayout.EndVertical();\n        //GUILayout.BeginHorizontal();\n        if (GUILayout.Button(\"+\"))\n        {\n            (target as Script_04_11).m_spriteDic[size.ToString()] = null;\n        }\n        //GUILayout.EndHorizontal();\n        GUILayout.EndVertical();\n        serializedObject.ApplyModifiedProperties();\n    }\n}\n#endif\n\n```\n## 感想\n### 命名规范\n雨松大大用的命名规范貌似不是Pascal(BackColor),Camel(backColor)或者匈牙利命名法(m_bFlag)。所以打算遇到一个总结一下：\n私有成员变量： m_Keys\n公有成员变量: spriteDic\n\n### 代码规范\n1、在关于编辑器的地方使用 `#if UNITY_EDITOR` and `#endif` ，比如在`using UnityEditor;` 和拓展编辑器的部分。\n2、合理使用 `#region xxxxx` and `#endregion`,比如在接口的实现函数时。","tags":["Unity","宣雨松"]},{"title":"pygame simple example","url":"/2020/02/16/punch/","content":"# copy\n\n```python\n# config.py 存放配置\nimport os,sys\nresource_path = os.path.join(os.path.dirname(__file__),'..','data')\nfist_image = os.path.join(resource_path,'fist.bmp')\nwhimp_image = os.path.join(resource_path,'nut.bmp')\n\npunch_sound = os.path.join(resource_path,'punch.wav')\nwhiff_sound = os.path.join(resource_path,'whiff.wav')\n\nwhimp_speed = 8\nwhimp_rotate = 12\n```\n\n```python\n# fist.py \nimport os,sys\nimport pygame\nimport config\nfrom config import fist_image\nfrom pygame.locals import *\nfrom tool import load_image\n\n\nclass Fist(pygame.sprite.Sprite):\n    '''拳头类，可出击'''\n    def __init__(self):\n        pygame.sprite.Sprite.__init__(self)\n        self.image , self.rect = load_image(fist_image,-1)\n        self.punching = False \n\n    def update(self):\n        ''' 重写父类的 update '''\n        mouse_pos = pygame.mouse.get_pos()\n        # self.rect.midtop = mouse_pos\n        if self.punching:\n            self.rect.midtop = ( mouse_pos[0] + 5 , mouse_pos[1] + 5)\n        else:\n            self.rect.midtop = mouse_pos\n            \n    def punch(self,target):\n        ''' 出击函数，检测是否与 target 产生碰撞'''\n        self.punching = True\n        if(self.rect.colliderect(target.rect)):\n            return True\n        else:\n            return False\n\n    def unpunch(self):\n        '''恢复'''\n        self.punching = False\n\n```\n\n``` python\n# whimp.py\nimport os,sys\nimport pygame\nfrom config import whimp_image,whimp_rotate,whimp_speed\nfrom pygame.locals import *\nfrom tool import load_image\n\n\nclass Whimp(pygame.sprite.Sprite):\n    '''猴子类，不要问为什么图片是个坚果，就是可爱'''\n    def __init__(self):\n        pygame.sprite.Sprite.__init__(self)\n        self.image ,self.rect = load_image(whimp_image,-1)\n        self.origin = self.image\n        # 设置初始位置\n        self.rect.midtop = (self.rect.width / 2 , 0)\n        screen = pygame.display.get_surface()\n        self.right_limit = screen.get_rect().right - self.rect.width / 2\n        self.left_limit = self.rect.width / 2\n        self.angle = 0\n        self.speed = whimp_speed\n        \n    def update(self):\n        ''' 重写父类的 update '''\n        if self.angle:\n            self._spin()\n        else:\n            self._walk()\n            \n    def _walk(self):\n        ''' 猴子跑步 '''\n        # if not self.angle:\n        target_x = self.rect.centerx + self.speed\n        if target_x > self.right_limit or target_x < self.left_limit:\n            self.speed = -self.speed\n            self.image = pygame.transform.flip(self.image,-1,0)\n        else:\n            self.rect.centerx = target_x\n                \n    def _spin(self):\n        ''' 猴子眩晕 '''\n        center = self.rect.center\n        self.angle += whimp_rotate\n        if self.angle >= 360:\n            self.angle = 0\n            self.image = self.origin\n        self.image = pygame.transform.rotate(self.origin,self.angle)\n        self.rect = self.image.get_rect(center = center)\n\n    def punched(self):\n        ''' 被锤了，QAQ '''\n        self.angle = 1\n\n```\n\n```python\n# tool.py \nimport os,sys\nimport pygame\nfrom pygame.locals import *\nfrom pygame.compat import geterror\n\ndef load_image(name, colorkey=None):\n    fullname = name\n    try:\n        image = pygame.image.load(fullname)\n    except pygame.error as message:\n        print(\"Cannot load image:\", fullname)\n        raise SystemExit(message)\n    image = image.convert()\n    if colorkey is not None:\n        if colorkey == -1:\n            colorkey = image.get_at((0, 0))\n        image.set_colorkey(colorkey, RLEACCEL)\n    return image, image.get_rect()\n\ndef load_sound(name):\n    class NoneSound:\n        def play(self):\n            pass\n\n    if not pygame.mixer or not pygame.mixer.get_init():\n        return NoneSound()\n    fullname = name\n    try:\n        sound = pygame.mixer.Sound(fullname)\n    except pygame.error:\n        print(\"Cannot load sound: %s\" % fullname)\n        raise SystemExit(str(geterror()))\n    return sound\n```\n\n```python\n# main.py\nimport os,sys\nimport time\nimport pygame\nfrom whimp import Whimp\nfrom fist import Fist\nfrom pygame.locals import *\nfrom tool import load_sound\nfrom config import whiff_sound,punch_sound\n\ndef main():\n\n    if not pygame.font:\n        print('sorry, this game no font')\n    if not pygame.mixer.Sound:\n        print('sorry,this game no sound')\n\n    # 初始化背景，文字等\n    pygame.init()\n    screen = pygame.display.set_mode((400,80))\n    bg = pygame.Surface(screen.get_size())\n    bg = bg.convert()\n    bg.fill((250,250,250))\n    pygame.mouse.set_visible(0)\n    # screen.blit(bg,(0,0)) 要从前往后画\n\n    if pygame.font:\n        text = pygame.font.Font(None,32).render('Hit The Nut And Win $$$',1,(10,10,10))\n        bg.blit(text,(screen.get_width() / 2 - text.get_width() /2,30))\n    screen.blit(bg,(0,0))\n    pygame.display.flip()\n    print(text.get_rect())\n        \n    \n    # 准备资源，精灵，音效等\n    clock = pygame.time.Clock()\n    whimp = Whimp()\n    fist = Fist()\n    punch_s = load_sound(punch_sound)\n    whiff_s = load_sound(whiff_sound)\n\n    allsprite = pygame.sprite.RenderPlain((whimp,fist))\n\n    # 主循环\n    while True:\n        clock.tick(60)\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT or event.type == pygame.K_ESCAPE:\n                exit()\n            if event.type == pygame.MOUSEBUTTONDOWN:\n                if fist.punch(whimp):\n                    whimp.punched()\n                    punch_s.play()\n                else:\n                    whiff_s.play()\n            if event.type == pygame.MOUSEBUTTONUP:\n                fist.unpunch()\n        \n        allsprite.update()\n\n        screen.blit(bg,(0,0))\n        allsprite.draw(screen)\n        pygame.display.flip()\n\n    \n\nif __name__ == \"__main__\":\n    main()\n```\n\n# official\n[chimp](https://www.pygame.org/docs/tut/chimp.py.html)\n\n# show\n![](/img/fist_and_chimp.gif)\n\n# thinking\n1、分清楚每一层需要干什么，比如一开始企图在 chimp 的 update 里写 event。。。但实际上应该是先获得当前帧的所有 event，然后再更新数据，最后在 update(更新渲染)\n2、如果一时间不能接受那么多函数的话，可以用自己的方式代替，比如 move_ip 可以写成 x=xx, y=yy\n\n# remaining\n`pygame.transform.rotate()` 每次变化都会有锯齿，然后如果一直用变换后的去变换，不到 10 次就会内存溢出，所以代码中一直是使用的原始图像变换","tags":["python","game"]},{"title":"python 杂记","url":"/2020/02/15/python_skill/","content":"\n1、if not x & if x is not y\n\n在 python 中 None, False, 空字符串 \"\", 0, 空列表 [], 空字典 {}, 空元组 () 都相当于 False ,所以如果你想区分 x==[] 和 x==None 两种情况的话, 此时 `if not x:` 将会出现问题\n```python\n>>> a=[]\n>>> not a\nTrue\n>>> a is not None\nTrue\n>>> a= None\n>>> not a\nTrue\n>>> a is not None\nFalse\n``` \n","tags":["python"]},{"title":"判断是否为连续数组","url":"/2020/01/12/judge_continuous/","content":"\n### 题目\n给定n个整数（0-100），其中0可以替换成任意其他数字，要求判断这n个整数是否连续？(存在重复数字也判定为连续)\n\n例：\n输入：0，5，6，7，8，10\n解释：将0替换成9，这n个整数可判定为连续\n输出：True\n输入：5，6，7，9，8，10\n解释：顺序无关\n输出：True\n输入：5，5，6，7，8\n输出：True\n```c++\n#include <iostream>\n#include <cstring>\n\nint main(){\n    const int kMaxNum = 100;\n    bool flag[kMaxNum];\n    memset(flag,0, sizeof(flag));\n\n    int num;\n    int zero_num = 0;\n    // 将数据存到 bool 的数组中，存取的时候已经排除了重复元素的影响\n    while(std::cin>>num) {\n        if (!num) {\n            ++zero_num;\n        } else {\n            flag[num - 1] = true;\n        }\n        if (std::cin.get() == '\\n')\n            break;\n    }\n    // 标记开始和结束为止\n    int32_t start = 0;\n    int32_t  end = 99;\n    for (int i = 0; i < kMaxNum; i++) {\n        if(flag[i]) {\n            start = i;\n            break;\n        }\n    }\n    for (int i = kMaxNum - 1; i >=0; i--) {\n        if(flag[i]) {\n            end = i;\n            break;\n        }\n    }\n    // 再次遍历有效区间，假设用 0 来填充所有空白，一旦 0 的数量不够，就说明不是连续数组\n    for (int i = start; i <= end; ++i) {\n        if(!flag[i] && (zero_num--)<0){\n            std::cout<<\"False\"<<std::endl;\n            return 0;\n        }\n    }\n    std::cout<<\"True\"<<std::endl;\n    return 0;\n}\n\n```\n\n### 进阶\n增加难度的额外需求：\n若98，99，100，1，2，3，也当作连续数组，即最大数字100后接上最小数字1也计为连续，如何修改代码实现？\n例：\n输入：98，99，100，1，2，3\n输出：True\n输入：0，98，99，1，2，3\n输出：True\n\n\n >写个思路吧。。\n 存数据的过程是一样的。。然后随便取一个 1 为起点，然后递增遍历 100 个，每次记录下一个 1 之间的 0 的个数，如果剩余 0 的个数足够填满这些个 1 ，就继续；不够的话，就记录目前 1 的位置，然后返回起点，递减按同样的方式处理，如果到了不够填满 0 的位置正好是上一次记录的，那么输出 true，否则输出 false\n\n","tags":["algorithm"]},{"title":"一句话备忘","url":"/2020/01/05/c++skill/","content":"\n1、定义变量的时候尽量把相同大小的数据类型放在一起，并且按顺序声明哈，因为有传说中的 alignment(内存对齐)~ [vc内存对齐准则](http://www.roading.org/develop/cpp/vc%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E5%87%86%E5%88%99%EF%BC%88memory-alignment%EF%BC%89.html)\n\n2、函数直接返回局部变量是不会有拷贝构造的，下面的代码段两个地址是一样的。\n```c++\nTest miao(){\n\tTest t;\n\tcout<<&t<<endl;\n\tcout<<\"miao\"<<endl;\n\treturn t;\n}\n\nint main(){\n\tTest t = miao();\n\tcout<<&t<<endl;\n}\n```\n但是类成员函数返回类成员，是会有一次拷贝构造的。\n```c++\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nusing namespace std;\nclass Test\n{\nprivate:\n    /* data */\npublic:\n    Test(){\n        cout<<\"construct1\"<<endl;\n    }\n    Test(const Test &t){\n        cout<<\"copy assignment1\"<<endl;\n    }\n    void operator=(const Test &t){\n        cout<<\"========1\"<<endl;\n    }\n    ~Test(){};\n};\n\nclass Test2\n{\nprivate:\n    Test t;\npublic:\n    Test2(){\n        cout<<\"construct2\"<<endl;\n    }\n    Test2(const Test2 &t){\n        cout<<\"copy assignment2\"<<endl;\n    }\n    void operator=(const Test2 &t){\n        cout<<\"========2\"<<endl;\n    }\n    Test get(){\n        return t;\n    }\n    ~Test2(){};\n};\n\n\n\nTest miao(){\n    Test t;\n    cout<<&t<<endl;\n    cout<<\"miao\"<<endl;\n    return t;\n}\n\nint main(){\n    // Test t = miao();\n    // cout<<&t<<endl;\n    Test2 m;\n    Test t = m.get();\n}\n\n// construct1\n// construct2\n// copy assignment1\n```\n其实仔细想想还是比较合理的，因为普通的调用函数，一旦返回了，那那个栈帧就被释放了，不会有其他因素去影响其中的局部变量; 既然如此，编译器没道理要把这种注定要返回的变量放到栈顶函数的栈帧，然后释放之后再拷贝一次到返回的函数；但成员变量就不一样了，因为返回之后，他依然会收到其他因素的影响，所以只能拷贝一份回去。\n\n","tags":["c++"]},{"title":"一起来画画叭~","url":"/2020/01/05/draw_a_picture/","content":"\n# 缘起\n起因是我在一个函数里面开了一个 socket，大概像。。这样~\n```c++\nint fun(){\n    int s = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);\n    /* ... */\n    if (/* ...*/){\n        close(s);\n        return -1;\n    }\n    if(/* ... */){\n        close(s);\n        return xx;\n    }\n}\n```\n显而易见的一个问题就是必须在每个 return 之前都要手写一个 close(s)，不然调用多次之后就会产生句柄泄露(当我发现这个问题的时候，`lsof -p my_pid` 已经有一千多条啦)，这样写其实是比较麻烦的，于是 leader 建议可以利用 shared_ptr 的特性——离开作用域的时候释放，来化简代码。处理之后就变成这样~\n```c++\nint fun(){\n    int s = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);\n    std::shared_ptr<int> p(&s,[](int *s){\n        close(*s);\n    });\n    /* ... */\n    if (/* ...*/){\n        return -1;\n    }\n    if(/* ... */){\n        return xx;\n    }\n}\n```\n下面是这个技巧的简单模型：\n```c++\n#include <iostream>\n#include <memory>\n\nint test(){\n    int hh =10;\n    {\n        std::shared_ptr<int> p(&hh,[](int *hh){\n            *hh = 15;\n            std::cout<<*hh<<std::endl;\n        });\n    }\n    std::cout<<\"jiujiu\"<<hh<<std::endl;\n    return hh;\n}\nint main(){\n    std::cout<<\"miaomiao\"<<test()<<std::endl;\n    std::cout<<\"wangwang\"<<std::endl;\n}\n```\n按我的理解输出应该是这样：\n```output\n15\njiujiu15\nmiaomiao15\nwangwang\n```\n但实际上输出是这样~\n```output\nmiaomiao15\njiujiu15\n15\nwangwang\n```\n刺激，让我们来看看汇编代码叭~\n```armasm\nDump of assembler code for function main():\n   0x00401531 <+0>:\tlea    0x4(%esp),%ecx\n   0x00401535 <+4>:\tand    $0xfffffff0,%esp\n   0x00401538 <+7>:\tpushl  -0x4(%ecx)\n   0x0040153b <+10>:\tpush   %ebp\n   0x0040153c <+11>:\tmov    %esp,%ebp\n   0x0040153e <+13>:\tpush   %ebx\n   0x0040153f <+14>:\tpush   %ecx\n   0x00401540 <+15>:\tsub    $0x10,%esp\n   0x00401543 <+18>:\tcall   0x402180 <__main>\n=> 0x00401548 <+23>:\tmovl   $0x406071,0x4(%esp)\n   0x00401550 <+31>:\tmovl   $0x6ff03a20,(%esp)\n   0x00401557 <+38>:\tcall   0x401c24 <std::basic_ostream<char, std::char_traits<char> >& std::operator<< <std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, char const*)>\n   0x0040155c <+43>:\tmov    %eax,%ebx\n   0x0040155e <+45>:\tcall   0x4014c7 <test()>\n   0x00401563 <+50>:\tmov    %eax,(%esp)\n   0x00401566 <+53>:\tmov    %ebx,%ecx\n   0x00401568 <+55>:\tcall   0x401c4c <std::ostream::operator<<(int)>\n   0x0040156d <+60>:\tsub    $0x4,%esp\n   0x00401570 <+63>:\tmovl   $0x401c2c,(%esp)\n   0x00401577 <+70>:\tmov    %eax,%ecx\n   0x00401579 <+72>:\tcall   0x401c54 <std::ostream::operator<<(std::ostream& (*)(std::ostream&))>\n   0x0040157e <+77>:\tsub    $0x4,%esp\n   0x00401581 <+80>:\tmovl   $0x40607a,0x4(%esp)\n   0x00401589 <+88>:\tmovl   $0x6ff03a20,(%esp)\n   0x00401590 <+95>:\tcall   0x401c24 <std::basic_ostream<char, std::char_traits<char> >& std::operator<< <std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, char const*)>\n   0x00401595 <+100>:\tmovl   $0x401c2c,(%esp)\n   0x0040159c <+107>:\tmov    %eax,%ecx\n   0x0040159e <+109>:\tcall   0x401c54 <std::ostream::operator<<(std::ostream& (*)(std::ostream&))>\n   0x004015a3 <+114>:\tsub    $0x4,%esp\n   0x004015a6 <+117>:\tmov    $0x0,%eax\n   0x004015ab <+122>:\tlea    -0x8(%ebp),%esp\n   0x004015ae <+125>:\tpop    %ecx\n   0x004015af <+126>:\tpop    %ebx\n   0x004015b0 <+127>:\tpop    %ebp\n   0x004015b1 <+128>:\tlea    -0x4(%ecx),%esp\n   0x004015b4 <+131>:\tret    \nEnd of assembler dump.\n\nDump of assembler code for function test():\n   0x004014c7 <+0>:\tpush   %ebp\n   0x004014c8 <+1>:\tmov    %esp,%ebp\n   0x004014ca <+3>:\tsub    $0x28,%esp\n   0x004014cd <+6>:\tmovl   $0xa,-0x10(%ebp)\n   0x004014d4 <+13>:\tlea    -0x18(%ebp),%eax\n   0x004014d7 <+16>:\tmov    %dl,0x4(%esp)\n   0x004014db <+20>:\tlea    -0x10(%ebp),%edx\n   0x004014de <+23>:\tmov    %edx,(%esp)\n   0x004014e1 <+26>:\tmov    %eax,%ecx\n   0x004014e3 <+28>:\tcall   0x4015b6 <std::shared_ptr<int>::shared_ptr<int, test()::<lambda(int*)> >(int *, <lambda(int*)>)>\n   0x004014e8 <+33>:\tsub    $0x8,%esp\n   0x004014eb <+36>:\tlea    -0x18(%ebp),%eax\n   0x004014ee <+39>:\tmov    %eax,%ecx\n   0x004014f0 <+41>:\tcall   0x4043c8 <std::shared_ptr<int>::~shared_ptr()>\n   0x004014f5 <+46>:\tmovl   $0x40606a,0x4(%esp)\n   0x004014fd <+54>:\tmovl   $0x6ff03a20,(%esp)\n   0x00401504 <+61>:\tcall   0x401c24 <std::basic_ostream<char, std::char_traits<char> >& std::operator<< <std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, char const*)>\n   0x00401509 <+66>:\tmov    %eax,%edx\n   0x0040150b <+68>:\tmov    -0x10(%ebp),%eax\n   0x0040150e <+71>:\tmov    %eax,(%esp)\n   0x00401511 <+74>:\tmov    %edx,%ecx\n   0x00401513 <+76>:\tcall   0x401c4c <std::ostream::operator<<(int)>\n   0x00401518 <+81>:\tsub    $0x4,%esp\n   0x0040151b <+84>:\tmovl   $0x401c2c,(%esp)\n   0x00401522 <+91>:\tmov    %eax,%ecx\n   0x00401524 <+93>:\tcall   0x401c54 <std::ostream::operator<<(std::ostream& (*)(std::ostream&))>\n   0x00401529 <+98>:\tsub    $0x4,%esp\n   0x0040152c <+101>:\tmov    -0x10(%ebp),%eax\n   0x0040152f <+104>:\tleave  \n   0x00401530 <+105>:\tret    \nEnd of assembler dump.\n```\n\n```\nsourece code:\n  std::cout<<\"miaomiao\"<<test()<<std::endl;\nasm:\n   0x00401531 <+0>:\tlea    0x4(%esp),%ecx\n   0x00401535 <+4>:\tand    $0xfffffff0,%esp\n   0x00401538 <+7>:\tpushl  -0x4(%ecx)\n   0x0040153b <+10>:\tpush   %ebp\n   0x0040153c <+11>:\tmov    %esp,%ebp\n   0x0040153e <+13>:\tpush   %ebx\n   0x0040153f <+14>:\tpush   %ecx\n   0x00401540 <+15>:\tsub    $0x10,%esp\n   0x00401543 <+18>:\tcall   0x402180 <__main>\n=> 0x00401548 <+23>:\tmovl   $0x406071,0x4(%esp)\n\ngdb:s\nsource code:\n  int hh =10;\nasm:\n   0x004014c7 <+0>:\tpush   %ebp\n   0x004014c8 <+1>:\tmov    %esp,%ebp\n   0x004014ca <+3>:\tsub    $0x28,%esp\n=> 0x004014cd <+6>:\tmovl   $0xa,-0x10(%ebp)\n\n可以看到 int hh = 10; 正好对应的就是 movl   $0xa,-0x10(%ebp)\n\n此时看一下栈的状态:(大地址是栈底，小地址是栈顶哈)\n0x29fee0:\t0x70\t0x7d\t0x79\t0x66\t0x00\t0xe0\t0xfd\t0x7f\n0x29fee8:\t0x08\t0xff\t0x29\t0x00\t0xa9\t0x49\t0xef\t0x6f\n0x29fef0:\t0x20\t0x3a\t0xf0\t0x6f\t0x71\t0x60\t0x40\t0x00\n0x29fef8:\t0x08\t0x00\t0x00\t0x00\t0xcc\t0xff\t0x29\t0x00\n0x29ff00:\t0xd0\t0xd1\t0xf0\t0x76\t0x44\t0x0a\t0xa5\t0x10\n可以看到很熟悉的两个地址 0x20\t0x3a\t0xf0\t0x6f(对应 0x00401550 指令)，0x71\t0x60\t0x40\t0x00(对应 0x00401548 指令),顺便一提，0x406071里是猫猫哦~\n(gdb) x/16cb 0x406071\n0x406071 <std::ignore+8>:\t109 'm'\t105 'i'\t97 'a'\t111 'o'\t109 'm'\t105 'i'\t97 'a'\t111 'o'\n0x406079 <std::ignore+16>:\t0 '\\000'\t119 'w'\t97 'a'\t110 'n'\t103 'g'\t119 'w'\t97 'a'\t110 'n'\n\n后面 shared_ptr 就不咋能看懂了，直接跳到\nsource code:\n    std::cout<<\"jiujiu\"<<hh<<std::endl;\nasm:\n=> 0x004014f5 <+46>:\tmovl   $0x40606a,0x4(%esp)\n   0x004014fd <+54>:\tmovl   $0x6ff03a20,(%esp)\n\n   跟上面一样，0x40606a 里面是 jiujiu,顺便怀疑一下，0x6ff03a20是栈的边界保护符！\n   \n   然后比较诡异的事情就出现了，此时，控制台输出了 miaomiao15。。。\n\n   然后到\n  source code:\n       return hh;\n  sam:\n  => 0x0040152c <+101>:\tmov    -0x10(%ebp),%eax\n  这个时候控制台输出了 jiujiu15，可以理解哈\n\n  继续：\n  source code:\n  }\n  sam:\n  => 0x0040152f <+104>:\tleave  \n  继续：\n  source code:\n      std::cout<<\"wangwang\"<<std::endl;\n  asm:\n  => 0x00401581 <+80>:\tmovl   $0x40607a,0x4(%esp)\n  这个时候控制台输出了：15\n\n```\nok，总结一下目前发现的不合理的点：\n1、` *hh = 15; std::cout<<*hh<<std::endl;`这两句没有一起执行，而且在离开 shared_ptr 作用域的时候，第一句是肯定执行了的。\n2、test 没有 返回之前，miaomiao15 就已经输出了。\n\n这一切诡异的背后，都指向了一个关键词\"缓冲区\"，于是我把所有的 cout 换成了 printf，再次运行，快乐的事情发生了\n```output\n15\njiujiu15\nmiaomiao15\nwangwang\n```\n或者像这个样子，结果也是一样哈\n```c++\n#include <iostream>\n#include <stdio.h>\n#include <memory>\n\nint test(){\n    int hh =10;\n    {\n        std::shared_ptr<int> p(&hh,[](int *hh){\n            *hh = 15;\n            std::cout<<*hh<<std::endl;\n            //printf(\"%d\\n\",*hh);\n        });\n    }\n    std::cout<<\"jiujiu\"<<hh<<std::endl;\n    //printf(\"jiujiu%d\\n\",hh);\n    return hh;\n}\nint main(){\n    int xixi = test();\n    std::cout<<\"miaomiao\"<<xixi<<std::endl;\n    //printf(\"miaomiao%d\\n\",test());\n    std::cout<<\"wangwang\"<<std::endl;\n}\n```\n\n# 画图\n>If I can，I wish to see the stream of every bit.  所以透明什么的最讨厌了。。\n\n恰完饭再画图叭~！(或许是明年了。。)","tags":["c++"]},{"title":"关于析构的无聊小实验","url":"/2020/01/01/virtual/","content":"\n# 喵？\n## delete 干了啥~\n```c++\nint main(){\n    int *hh = new int(5);\n    delete hh;\n}\n```\n```gdb\n(gdb) p hh # int *hh = new int(5); 未执行\n$1 = (int *) 0x400080\n(gdb) p &hh\n$2 = (int **) 0x29ff2c\n(gdb) p *hh\n$3 = 17744\n(gdb) n \n87\t    delete hh; \n(gdb) p hh # int *hh = new int(5); 执行了\n$4 = (int *) 0xdf11a8\n(gdb) p *hh\n$5 = 5\n(gdb) p &hh\n$6 = (int **) 0x29ff2c\n(gdb) n\n88\t}\n(gdb) p hh  # delete hh; 执行了\n$7 = (int *) 0xdf11a8\n(gdb) p &hh\n$8 = (int **) 0x29ff2c\n(gdb) p *hh\n$9 = 14618544\n```\n\n分析(瞎): hh 的地址在 hh 没定义之前就存在了，因为是用clion直接加断点然后开debug，所以看这个现象会比较奇怪，但其实如果自己编译的话，应该是知道要先编一个debug版本，在用gdb调试，所以在用gdb的时候，该有的符号就已经存在了。\n可见下面的小程序哈\n```c++\nint miao(){\n    int miaoo = 10;\n}\n\nint main(){\n    int *hh = new int(5);\n    delete hh;\n    int xixi = 10;\n}\n```\n在入口时，gdb显示如下\n```gdb\n(gdb) p miaoo\nNo symbol \"miaoo\" in current context.\n(gdb) p miao\n$1 = {int (void)} 0x401410 <miao()>\n(gdb) p xixi\n$2 = 2147344384\n(gdb) p wangwang\nNo symbol \"wangwang\" in current context.\n```\n第二个现象：delete之后，hh的地址不变，hh的值(存储的地址)不变，但hh存的那块地址的值变了？？一开始我还挺奇怪的，因为如果我是一个计算机，对delete最理想的处理方式应该是，一旦hh被delete了，那么后面再有用到hh的地方就是异常的，也就是hh这个symbol就应该彻底被消灭。但仔细想想话，这有点“强机所难”了，因为对计算机来说，是不存在hh这个东西的，他只是按照指令来将数据在内存，寄存器和IO中进行传输。那么我刚刚的构想可以理解为，一旦hh被delete，那么再用到 0xdf11a8 这块地址就是异常的，那。。这不是系统性的内存泄漏嘛(笑)。这样一想，我倒是能理解为什么delete选择对 0xdf11a8 这块内存的数据动手了，而且也不能不动手，因为delete就是希望不再让人获得原数据；而且也不能全部刷新为 0，出了问题比较难debug吧。\n真是难为编译器的用心良苦了喵~！\n\n## 继续探索\n测试代码就是酱紫啦，主要的目的是探索如果基类的析构函数不是virtual的，就不会调用子类的析构函数，那么怎么能再次使用子类的成员嘞？(感觉自己离黑客又近了一步呐)\n```c++\n#include <string>\n#include <iostream>\n\nclass BaseClass\n{\npublic:\n    BaseClass()\n            : m_pValue(NULL)\n    {\n    }\n\n   /*virtual*/ ~BaseClass()\n   // virtual ~BaseClass()\n    {\n        delete m_pValue;\n        m_pValue = NULL;\n        std::cout << \"BaseClass virtual construct.\" << std::endl;\n    }\n\n    void SetValue(int v)\n    {\n        if (!m_pValue)\n        {\n            m_pValue = new int(v);\n        }\n        else\n        {\n            *m_pValue = v;\n        }\n    }\n\nprivate:\n    int* m_pValue;\n};\n\nclass SubClass : public BaseClass\n{\npublic:\n    SubClass()\n            : BaseClass()\n            , m_pstrName(NULL)\n    {\n    }\n\n    /*virtual*/ ~SubClass()\n    {\n        delete m_pstrName;\n        m_pstrName = NULL;\n        std::cout << \"SubClass virtual construct.\" << std::endl;\n    }\n\n    void SetName(const std::string& name)\n    {\n        if (!m_pstrName)\n        {\n            m_pstrName = new std::string(name);\n        }\n        else\n        {\n            *m_pstrName = std::string(name);\n        }\n    }\n    const std::string *get_string(){\n        return m_pstrName;\n    }\n\nprivate:\n    std::string* m_pstrName;\n};\n\n\nint main()\n{\n    BaseClass* pObj = new SubClass();\n    pObj->SetValue(10);\n    ((SubClass*)pObj)->SetName(\"zhangsan\");\n    std::cout<<*(((SubClass*)pObj)->get_string())<<std::endl;\n    delete pObj;\n    std::cout<<*(((SubClass*)pObj)->get_string())<<std::endl;\n    pObj = NULL;\n    return 0;\n}\n```\n\n基类的析构函数不是virtual的情况\n```gdb\n(gdb) p pObj # 没有 delete 之前\n$1 = (BaseClass *) 0xd311a8\n(gdb) p pObj->m_pstrName\nThere is no member or method named m_pstrName.\n(gdb) p ((SubClass*)pObj)->m_pstrName\n$2 = 0xd311e8\n(gdb) p *(((SubClass*)pObj)->m_pstrName)\n$3 = \"zhangsan\"\n(gdb) x/64cb 0xd311e8 # 按单字节，字符形式打印64个单位\n0xd311e8:\t-16 '\\360'\t17 '\\021'\t-45 '\\323'\t0 '\\000'\t8 '\\b'\t0 '\\000'\t0 '\\000'\t0 '\\000'\n0xd311f0:\t122 'z'\t104 'h'\t97 'a'\t110 'n'\t103 'g'\t115 's'\t97 'a'\t110 'n'\n0xd311f8:\t0 '\\000'\t-16 '\\360'\t-83 '\\255'\t-70 '\\272'\t13 '\\r'\t-16 '\\360'\t-83 '\\255'\t-70 '\\272'\n0xd31200:\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\n0xd31208:\t0 '\\000'\t0 '\\000'\t0 '\\000'\t0 '\\000'\t0 '\\000'\t0 '\\000'\t0 '\\000'\t0 '\\000'\n0xd31210:\t-19 '\\355'\t-103 '\\231'\t-110 '\\222'\t80 'P'\t-42 '\\326'\t-91 '\\245'\t0 '\\000'\t0 '\\000'\n0xd31218:\t40 '('\t127 '\\177'\t-45 '\\323'\t0 '\\000'\t-40 '\\330'\t18 '\\022'\t-45 '\\323'\t0 '\\000'\n0xd31220:\t-18 '\\356'\t-2 '\\376'\t-18 '\\356'\t-2 '\\376'\t-18 '\\356'\t-2 '\\376'\t-18 '\\356'\t-2 '\\376'\n(gdb) p pObj->m_pValue\n$4 = (int *) 0xd311c8\n(gdb) p *(pObj->m_pValue)\n$5 = 10\n(gdb) x/64dw 0xd311c8 # 按4字节，十进制的形式打印64个单位\n0xd311c8:\t10\t-1414812757\t-1414812757\t-17891602\n0xd311d8:\t0\t0\t1100061183\t402695636\n0xd311e8:\t13832688\t8\t1851877498\t1851880295\n0xd311f8:\t-1163005952\t-1163005939\t-1414812757\t-1414812757\n0xd31208:\t0\t0\t1351784941\t42454\n0xd31218:\t13860648\t13832920\t-17891602\t-17891602\n0xd31228:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd31238:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd31248:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd31258:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd31268:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd31278:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd31288:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd31298:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd312a8:\t-17891602\t-17891602\t1133615613\t436250052\n0xd312b8:\t2\t-1414856637\t-1414812757\t-17912917\n(gdb) n\n79\t    std::cout<<*(((SubClass*)pObj)->get_string())<<std::endl;\n(gdb) p pObj # delete 之后\n$6 = (BaseClass *) 0xd311a8\n(gdb) p pObj->m_pstrName\nThere is no member or method named m_pstrName.\n(gdb) p ((SubClass*)pObj)->m_pstrName\n$7 = 0xd312d8\n(gdb) p *(((SubClass*)pObj)->m_pstrName)\n$8 = \"\\030\\022\\323\\000\\330\\022\\323\\000\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\377\\231\\221A\\330\\245\\000\\030\\360\\021\\323\\000\\b\\000\\000\\000zhangsan\\000\\360\\255\\272\\r\\360\\255\\272\\253\\253\\253\\253\\253\\253\\253\\253\\000\\000\\000\\000\\000\\000\\000\\000\\355\\231\\222P\\326\\245\\000\\000(\\177\\323\\000\\250\\021\\323\\000\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\375\\231\\221C\\304\\245\\000\\032\\002\\000\\000\\000C\\000\\253\\253\\253\\253\\253\\253\\253\\253\\356\\376\\000\\000\\000\\000\\000\\000\\000\\000\\372\\231\\222G\\324\\245\\000\\000\\250\\021\\323\\000\\300\\000\\323\\000\\356\\376\\356\\376\\356\\376\\356\\376\\276\\231\\221\\000\\323\\245\\000\\030\\002\\000\\000\\000\\250\\003\\000\\000\\001\\000\\000\\000\\004\\b\\000\\000\\301\\243\\332\\243 \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\b\\030\\030\\030\\030\\030\\030\\030\\030\\030\\030\\030\\030\\030\\030\\030\\030\\030\\030\\030\\030\\030\\030\\030\\030\\030\\030\\b\\b\\b\\b\\b\\b((((((((((((((((((((((((((\\b\\b\\b\\b\\b\\b\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000abcdefghijklmnopqrstuvwxyz\\000\\000\\000\\000\\000\\000ABCDEFGHIJKLMNOPQRSTUVWXYZ\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\253\\253\\253\\253\\253\\253\\253\\253\\000\\000\\000\\000\\000\\000\\000\\000\\035\\231\\221\\243\\227\\245\\000\\035\\330\\025\\323\\000\\367\\025\\323\\000 \\026\\323\\000=\\026\\323\\000H\\026\\323\\000\\204\\026\\323\\000\\273\\026\\323\\000\\354\\026\\323\\000\\t\\027\\323\\000-\\027\\323\\000^\\027\\323\\000\\206\\027\\323\\000\\223\\027\\323\\000\\253\\027\\323\\000\\330\\027\\323\\000\\341\\027\\323\\000\\r\\030\\323\\000+\\030\\323\\000B\\030\\323\\000e\\030\\323\\000s\\030\\323\\000V\\031\\323\\000\\224\\031\\323\\000\\257\\031\\323\\000\\314\\031\\323\\000\\024\\032\\323\\000\"...\n(gdb) x/64cb 0xd311e8\n0xd311e8:\t-16 '\\360'\t17 '\\021'\t-45 '\\323'\t0 '\\000'\t8 '\\b'\t0 '\\000'\t0 '\\000'\t0 '\\000'\n0xd311f0:\t122 'z'\t104 'h'\t97 'a'\t110 'n'\t103 'g'\t115 's'\t97 'a'\t110 'n'\n0xd311f8:\t0 '\\000'\t-16 '\\360'\t-83 '\\255'\t-70 '\\272'\t13 '\\r'\t-16 '\\360'\t-83 '\\255'\t-70 '\\272'\n0xd31200:\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\n0xd31208:\t0 '\\000'\t0 '\\000'\t0 '\\000'\t0 '\\000'\t0 '\\000'\t0 '\\000'\t0 '\\000'\t0 '\\000'\n0xd31210:\t-19 '\\355'\t-103 '\\231'\t-110 '\\222'\t80 'P'\t-42 '\\326'\t-91 '\\245'\t0 '\\000'\t0 '\\000'\n0xd31218:\t40 '('\t127 '\\177'\t-45 '\\323'\t0 '\\000'\t-88 '\\250'\t17 '\\021'\t-45 '\\323'\t0 '\\000'\n0xd31220:\t-18 '\\356'\t-2 '\\376'\t-18 '\\356'\t-2 '\\376'\t-18 '\\356'\t-2 '\\376'\t-18 '\\356'\t-2 '\\376'\n(gdb) p pObj->m_pValue\n$9 = (int *) 0xd31218\n(gdb) p *(pObj->m_pValue)\n$10 = 13860648\n(gdb) x/64dw 0xd311c8\n0xd311c8:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd311d8:\t-17891602\t-17891602\t1100061183\t402695640\n0xd311e8:\t13832688\t8\t1851877498\t1851880295\n0xd311f8:\t-1163005952\t-1163005939\t-1414812757\t-1414812757\n0xd31208:\t0\t0\t1351784941\t42454\n0xd31218:\t13860648\t13832616\t-17891602\t-17891602\n0xd31228:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd31238:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd31248:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd31258:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd31268:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd31278:\t-17891602\t-17891602\t-17891602\t-17891602\n```\n\n可以看到，如果基类的析构函数不是virtual，那么在多态的时候就不会调用子类的析构函数，所以0xd311f0这块内存是没有被刷新的，理论上来说，p *(((SubClass*)pObj)->m_pstrName) 依然能够得到“zhangsan”才对，但是可以看到p出来的是却是0xd311e8的前面的很长一段内存到很大的内存地址。(挠头)\n```gdb\n0xd311e0:\t-1 '\\377'\t-103 '\\231'\t-111 '\\221'\t65 'A'\t-40 '\\330'\t-91 '\\245'\t0 '\\000'\t24 '\\030'\n0xd311e8:\t-16 '\\360'\t17 '\\021'\t-45 '\\323'\t0 '\\000'\t8 '\\b'\t0 '\\000'\t0 '\\000'\t0 '\\000' # 对应 p *(((SubClass*)pObj)->m_pstrName) 结果的“zhangsan”前面那一段数据\n0xd311f0:\t122 'z'\t104 'h'\t97 'a'\t110 'n'\t103 'g'\t115 's'\t97 'a'\t110 'n'\n```\n嘛。。估计就是一种保护机制吧，目前为止情况还在控制之中(起码还能自己骗过自己。。。)\n\n基类的析构函数加上 virtual 的情况：\n```gdb\n(gdb)  p pObj\n$4 = (SubClass *) 0xd611a8\n(gdb) p pObj->m_pstrName\n$5 = 0xd611f0\n(gdb) p ((SubClass*)pObj)->m_pstrName\n$6 = 0xd611f0\n(gdb) p *(pObj->m_pstrName)\n$7 = \"zhangsan\"\n(gdb) p *(((SubClass*)pObj)->m_pstrName)\n$8 = \"zhangsan\"\n(gdb) x/64cb 0xd611f0\n0xd611f0:\t-8 '\\370'\t17 '\\021'\t-42 '\\326'\t0 '\\000'\t8 '\\b'\t0 '\\000'\t0 '\\000'\t0 '\\000'\n0xd611f8:\t122 'z'\t104 'h'\t97 'a'\t110 'n'\t103 'g'\t115 's'\t97 'a'\t110 'n'\n0xd61200:\t0 '\\000'\t-16 '\\360'\t-83 '\\255'\t-70 '\\272'\t13 '\\r'\t-16 '\\360'\t-83 '\\255'\t-70 '\\272'\n0xd61208:\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\n0xd61210:\t0 '\\000'\t0 '\\000'\t0 '\\000'\t0 '\\000'\t0 '\\000'\t0 '\\000'\t0 '\\000'\t0 '\\000'\n0xd61218:\t-43 '\\325'\t21 '\\025'\t23 '\\027'\t-5 '\\373'\t-62 '\\302'\t-54 '\\312'\t0 '\\000'\t0 '\\000'\n0xd61220:\t40 '('\t127 '\\177'\t-42 '\\326'\t0 '\\000'\t-40 '\\330'\t18 '\\022'\t-42 '\\326'\t0 '\\000'\n0xd61228:\t-18 '\\356'\t-2 '\\376'\t-18 '\\356'\t-2 '\\376'\t-18 '\\356'\t-2 '\\376'\t-18 '\\356'\t-2 '\\376'\n(gdb) p pObj->m_pValue\n$9 = (int *) 0xd611d0\n(gdb) p *(pObj->m_pValue)\n$10 = 10\n(gdb) x/64dw 0xd611d0\n0xd611d0:\t10\t-1414812757\t-1414812757\t-17891602\n0xd611e0:\t0\t0\t-317450816\t402705088\n0xd611f0:\t14029304\t8\t1851877498\t1851880295\n0xd61200:\t-1163005952\t-1163005939\t-1414812757\t-1414812757\n0xd61210:\t0\t0\t-82373163\t51906\n0xd61220:\t14057256\t14029528\t-17891602\t-17891602\n0xd61230:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd61240:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd61250:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd61260:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd61270:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd61280:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd61290:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd612a0:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd612b0:\t-283896382\t436259543\t2\t-1414856637\n0xd612c0:\t-1414812757\t-17912917\t0\t0\n(gdb) n\n79\t    std::cout<<*(((SubClass*)pObj)->get_string())<<std::endl;\n(gdb) p pObj\n$11 = (BaseClass *) 0xd611a8\n(gdb) p pObj->m_pstrName\nThere is no member or method named m_pstrName.\n(gdb) p ((SubClass*)pObj)->m_pstrName\n$12 = (std::__cxx11::string *) 0xfeeefeee\n(gdb) p *(((SubClass*)pObj)->m_pstrName)\nCannot access memory at address 0xfeeefeee\n(gdb) x/64cb 0xd311e8\n0xd311e8:\tCannot access memory at address 0xd311e8\n(gdb) x/64cb 0xfeeefeee\n0xfeeefeee:\tCannot access memory at address 0xfeeefeee\n(gdb) p pObj->m_pValue\n$13 = (int *) 0xd67f28\n(gdb) p *(pObj->m_pValue)\n$14 = 14029224\n(gdb) x/64dw 0xd611d0\n0xd611d0:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd611e0:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd611f0:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd61200:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd61210:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd61220:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd61230:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd61240:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd61250:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd61260:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd61270:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd61280:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd61290:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd612a0:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd612b0:\t-283896382\t436259558\t2\t-1414856637\n0xd612c0:\t-1414812757\t-17912917\t0\t0\n(gdb) x/64dw 0xd67f28\n0xd67f28:\t14029224\t14029528\t-17891602\t-17891602\n0xd67f38:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd67f48:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd67f58:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd67f68:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd67f78:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd67f88:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd67f98:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd67fa8:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd67fb8:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd67fc8:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd67fd8:\t-17891602\t-17891602\t-384690750\t50383580\n0xd67fe8:\t14024844\t14024844\t14024760\t14024760\n0xd67ff8:\t14057472\t28672\tCannot access memory at address 0xd68000\n```\n\n加上虚函数之后，情况就有点不受控制了，首先是基类指针不用转成子类就可以直接引用子类成员变量；二是析构时基类子类的成员变量都指向了其他内存，在没有加入虚函数时只是刷新指向的那块内存的数据哦~地址本身是不变滴。更诡异的是，实验两次，析构后那个字符串的地址都是0xfeeefeee，int的地址却每次都不同。\n\n## 先睡了，有时间看看虚函数表是怎么实现的估计会有新发现\n\n## 遗留问题\n### 神秘偏移\n在没有虚函数的时候，delete 之后` p (((SubClass)pObj)->m_pstrName)` 的结果有一段很奇怪的偏移。。\n### 基类直接引用\n加上虚函数之后，基类指针不用转成子类就可以直接引用子类成员变量，delete 之后就不可以啦\n### 0xfeeefeee(已解决)\n长得奇怪，必有猫腻\n\n---\n\n>0xcccccccc : Used by Microsoft's C++ debugging runtime library to mark uninitialised stack memory\n> 0xcdcdcdcd : Used by Microsoft's C++ debugging runtime library to mark uninitialised heap memory\n>0xfeeefeee : Used by Microsoft's HeapFree() to mark freed heap memory\n>0xabababab : Used by Microsoft's HeapAlloc() to mark \"no man's land\" guard bytes after allocated heap memory\n>0xabadcafe : A startup to this value to initialize all free memory to catch errant pointers\n>0xbaadf00d : Used by Microsoft's LocalAlloc(LMEM_FIXED) to mark uninitialised allocated heap memory\n>0xbadcab1e : Error Code returned to the Microsoft eVC debugger when connection is severed to the debugger\n>0xbeefcace : Used by Microsoft .NET as a magic number in resource files\n>对于0xcccccccc和0xcdcdcdcd，在 Debug 模式下，VC 会把未初始化的栈内存上的指针全部填成 0xcccccccc ，当字符串看就是 “烫烫烫烫……”；会把未初始化的堆内存上的指针全部填成 0xcdcdcdcd，当字符串看就是 “屯屯屯屯……”。那么调试器为什么要这么做呢？VC的DEBUG版会把未初始化的指针自动初始化为0xcccccccc或0xcdcdcdcd，而不是就让取随机值，那是为了方便我们调试程序，如果野指针的初值不确定，那么每次调试同一个程序就可能出现不一样的结果，比如这次程序崩掉，下次却能正常运行，这样显然对我们解bug是非常不利的，所以自动初始化的目的是为了让我们一眼就能确定我们使用了未初始化的野指针了。\n>对于0xfeeefeee，是用来标记堆上已经释放掉的内存。注意，如果指针指向的内存被释放了，变量变量本身的地址如未做改动，还是之前指向的内存的地址。如果该指针是一个类的指针，并且类中包含有指针变量，则内存被释放后（对于C++类，通常是执行delete操作），类中的指针变量就会被赋值为0xfeeefeee。如果早调试代码过程中，发现有值为0xfeeefeee的指针，就说明对应的内存被释放掉了，我们的代码已经出问题了。\n\n\n\n### Cannot access memory at address\n当我以为可以用gdb p 出内存的全部地址数据的时候。。`Cannot access memory at address`真是狠狠打脸了呐，所以能访问的地址有什么条件咧？\n猜测：能p出来的都是存在物理内存中的，但 `0xd67ff8:\t14057472\t28672\tCannot access memory at address 0xd68000`有点说不过去啊。。","tags":["c++","experiment"]},{"title":"《深入探索c++对象模型》1生万 小试验","url":"/2019/12/22/one_create_wan/","content":"\n# 引入\n在C中将一个一个元素的数组放在struct的末尾，可以令每个struct的对象拥有可变数组\n## code\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nstruct Test{\n    int xixi ;\n    char haha[1];\n};\n\nint main() {\n    const char *str = \"hhhhhhh\";\n    struct Test *test = (struct Test*)(malloc(sizeof(struct Test) + strlen(str) + 1));\n    test->xixi = 15;\n    strcpy(test->haha,str);\n    return 0;\n}\n```\n## gdb 分析\n```gdb\n(gdb) p &test\n$1 = (struct Test **) 0x29ff28 \n(gdb) p &test->xixi \n$2 = (int *) 0x9a1180 \n(gdb) x/32xb test\n0x9a1180:\t0x0f\t0x00\t0x00\t0x00\t0x68\t0x68\t0x68\t0x68 # 从 0f 可以看出是大端序\n0x9a1188:\t0x68\t0x68\t0x68\t0x00\t0x0d\t0xf0\t0xad\t0xba # 连续7个 0x68 对应的是 \"hhhhhhh\"\n0x9a1190:\t0xab\t0xab\t0xab\t0xab\t0xab\t0xab\t0xab\t0xab\n0x9a1198:\t0x00\t0x00\t0x00\t0x00\t0x00\t0x00\t0x00\t0x00\n(gdb) p test->haha[0]\n$4 = 104 'h'\n(gdb) p test->haha[3]\n$5 = 104 'h'\n```\n在代码中也可以使用 `printf(\"%c\",test->haha[0])` 来访问 ( 我记得应该有边界保护的呀？？？ )\n这个小技巧基本不能在 c++ 中使用，因为 class 中 可以保证相同 access section(public, private,protected) 的数据排列是按照声明顺序排列在内存中，但跨 access section 的数据却不一定是按声明顺序。\n\n```\n...\nprivate:\n /** date1 **/\npublic:\n /** date2 **/\n...\n```\n在内存中 date2 并不一定都排列在 date1 后面。再加上 virtual function ，使得这个方法的有效性更加不确定。(不用就行啦 嘻嘻) \n\n# 遗留问题\n## 一、c++ 到底干了啥？？\n`strcpy(&test->haha,str);` and `strcpy(test->haha,str);` 在 c99 中都可，但 c++14 只支持后者。同样，c++ 中 `strcpy(&(test->haha),str);` 也不行\n``` c++\nint main() {\n    const char *str = \"hhhhhhh\";\n    struct Test *test = (struct Test*)(malloc(sizeof(struct Test) + strlen(str) + 1));\n    test->xixi = 15;\n    strcpy(test->haha,str);\n    printf(\"%x\\n\",test->haha);\n    fflush(stdout); // 不强制刷新缓冲区的话，debug 看不到 console 输出\n    return 0;\n}\n```\n``` output\nprintf(\"%x\\n\",test->haha); -> 55121c\n\n(gdb) p &(test->haha)\n$1 = (char (*)[2]) 0x55121c\n```\n可以看到这俩都是 haha 的地址，但后者就是编译不过，所以 c++ 在兼容 c 的时候又干了啥呐？\n## 二、反黑技术哪家强。。\n之前有看到，为了防止黑客推理出内存中的数据，所以每次 main帧都不是从栈的最低部开始存的，这个很好验证，每次重新运行，`(gdb) p &test` 可以看到每次地址都不一样就对了。but ... 为什么我 p 出来每次都是一样的？？(含泪微笑)  \n猜测一：领会错了该反黑秘籍  \n猜测二：需要 release 模式，或者编译优化\n## 三、说好的边界保护呐\n\n","tags":["c++"]},{"title":"Letter from an Unknown Woman p2","url":"/2019/07/05/letter-2/","content":"\n>你一个漫不经心的眼神，\n>　　如大火席卷麦田，\n>　　我把所有收成抵挡给一场虚妄。\n>　　可是，即便是虚妄，我都极尽热爱，\n>　　因为，我爱你……从未停止……\n\n我点了第五只蜡烛，坐在桌前给你写这封信。如果我不将心内的感情倾泻出来，就无法忍受独自和我死去的孩子待在一起。如果不是向你——一个曾今并且仍是我最心爱的人，倾诉这些，那还能跟谁说呐？也许你不能理解我。我的心如此沉重，太阳穴在不住颤动，四肢在忍受疼痛。我想我一定发烧了，流行病在这个季度扩散，我可能已经受到了感染。相对于轻生，如果能用这种方式再见到我的孩子，我更不会感到愧疚。有时我的眼前会一片黑暗，或许我不能坚持到完成这封信；但是，我的爱人，我会用尽所有力气，在这一次，并且是唯一的一次向你对话，尽管你从来不知道我是谁。\n\n对你我只想说，我将告诉你以前从未说过的所有事。我想让你知道我整个人生，并且也是你从未知道的有关你的一生。你应该只会在我死后才有可能知道我的秘密，那个时候你不需要回答任何人的问题；那个时候你也该知道，现在受着四肢冷热交加的痛苦的我，是否正经历着人生最后的时光。如果我决定继续活着，我会撕碎这封信，保持着一如既往的沉默。如果有一天你将这封信拿在手上，就该知道这是一个已故女人寄来的信，来告诉你她的故事，一个从一开始到最后，只要是她清醒的时刻，就与你有关的故事。你不必对我的话感到恐惧，一个死去的女人什么都不需要，既不需要爱，也不需要同情，更不需要安慰。我只想请求你一件事，请你相信我所说的一切，在沉重痛苦驱动下说出的一切。相信我的话。除此之外，我别无所求。一个母亲，不会在她死去的孩子旁说谎。\n\n我将告诉你我整个的人生，在第一次见到你之前，我的人生并不算开始。在那之前，我能回忆起的只有灰暗和迷茫，记忆就像是一个落满灰尘，充斥黑暗和有很多布着蜘蛛网的人事的地窖——那是一个我毫不关心的地方。我 13 岁时，你走进了我的生活，当时我就住在你现在住的房子，也就是你现在拿着信，听着我生命最后一声叹息的地方。我们当时住在公寓的同一层，并且是门对门。你一定已经忘了我和我的母亲了，一定很早就忘了在一个枯燥的追悼会上，那个死者会计的遗孀和她瘦弱的，未长开的女儿。我们一直很安静，是落寞的上流阶层的典型。你不可能听过我们的名字，因为我们没有在门前挂名牌，也没有任何人来拜访我们。再说了，已经过了那么久，十五、十六年了。你不可能记得的。但是，我强烈的记着每一个细节。我记得那一年，那一个时辰，我第一次听到你说话，第一次见到你。我怎么可能记不住呐？那标志着我人生的开始啊。请你再耐心的等待一下，我马上就告诉你从头到尾的所有事。在你空闲的时间听我说这些就感到厌烦了吗？但我用尽一生来爱你也未有丝毫疲倦啊。","tags":["reading"]},{"title":"Letter from an Unknown Woman p1","url":"/2019/07/04/letter-1/","content":"\n>Now I have only you left in the world;\n>　　Only you, who have never known me,\n>　　and whom I have never ceased to love.\n\n\nR. 最著名的小说家刚结束他在山上的一个短暂的假期。他清晨很早就到达了维也纳，并且买了一份报纸在车站，当他看到日期的时候才意识到今天是他的生日“41岁”。对此R.并没有很开心，也没有很遗憾，他找了一辆出租，并且在回去的路上快速扫了一遍报纸。他的管家报告说：“在他不在的期间，除了一些电话之外，还有几个拜访者和一大捆信在等着他。他对这些漠不关心，并打开了一两封对寄件人有兴趣的信。同时把一个巨大的用一个奇怪的笔迹写的信放在一旁。R. 惬意的坐在椅子里，喝着他的早茶，看完报纸，又读了几则传单，然后，他点了一支雪茄，转身去看剩下的信件。\n　　这是一封手稿而不是打印的信件，里面有几打女士笔迹匆忙写下的信纸，他不由自主的多次检查这个信封，以防忽视了被盖住的纸张，但并没有，在信封或者目录上，都没有署名也没有地址。“真奇怪” 他想，同时他开始读信。第一句话是标题。\n　　“对你而言，从来都不知道我是谁” R. 很疑惑，这是专门寄给他的信，还是寄给想象中的人？他的好奇心瞬间被唤起，他继续读着：\n　　我的孩子昨天死了。我为了这个虚弱的小生命与死神斗争了三天三夜，流行性感冒带来的发烧折磨了他整整40个小时。期间，我一直坐在他床边陪着他，我将冰绷带放在了他的额头上，过了一天又一夜，一夜又一天，我一直抓着他不安的小手，第三天晚上，我的力气耗尽了，我没意识到自己闭上了眼睛，我想我一定在硬板凳上睡了三四个小时，死神趁机带走了他。我亲爱的孩子，他躺在狭窄的婴儿床内，就像刚离开的样子，他那聪明的，黑色的眼睛永远闭上了，他的双手交叉放在胸前。四只蜡烛在床的四角燃烧，我不忍去看，不忍去移动，因为当蜡烛在闪烁，阴影投射在他的脸上，投射在他紧闭的嘴唇上，烛火摇曳。这看起来像是他的表情在变化，我几乎可以幻想他根本就没有死去，他会醒来并且用清晰地声音诉说着孩子气的爱。但是我知道他死了，我再也看不到那个场景了。我不止一次的乞求，却又一次次的失望。我知道，我的孩子，在昨天死了。在这个世上，我只剩下你了。你，不知道我是谁；你，毫无察觉的享乐；你，与其他人冒险。只剩你了，一个从来不知道我是谁，我却从未停止去爱的人。","tags":["reading"]},{"title":"《TCP/IP 详解》whois 试验","url":"/2019/06/24/TCP-IP-1/","content":"\n这里有一个ip地址为：47.90.78.76\n\n地址栏输入：http://whois.arin.net/rest/ip/47.90.78.76.txt\n\n查询结果为：\n```\n \n#\n# ARIN WHOIS data and services are subject to the Terms of Use\n# available at: https://www.arin.net/resources/registry/whois/tou/\n#\n# If you see inaccuracies in the results, please report at\n# https://www.arin.net/resources/registry/whois/inaccuracy_reporting/\n#\n# Copyright 1997-2019, American Registry for Internet Numbers, Ltd.\n#\n \nNetRange:       47.90.0.0 - 47.90.127.255\nCIDR:           47.90.0.0/17\nNetName:        ALICLOUD-HK\nNetHandle:      NET-47-90-0-0-1\nParent:         AL-3 (NET-47-88-0-0-1)\nNetType:        Reassigned\nOriginAS:       AS45102\nCustomer:       ALICLOUD-HK (C06961495)\nRegDate:        2018-04-20\nUpdated:        2018-04-20\nComment:        1.For AliCloud IPR Infringement and Abuse Claim, please use below link with browser to report: https://intl.aliyun.com/report\nComment:        \nComment:        2.For Alibaba.com and Aliexpress.com's IPR Infringement , please use below link with browser to report: https://ipp.alibabagroup.com\nComment:        \nComment:        3.For Alibaba.com and Aliexpress.com's Abuse, please send email to those two mail lists to report: intl-abuse@list.alibaba-inc.com and abuse@alibaba-inc.com\nComment:        \nComment:        4. For network issue, please send email to this mail list: aliops-goc@list.alibaba-inc.com\nRef:            https://whois.arin.net/rest/net/NET-47-90-0-0-1\n \n#\n# ARIN WHOIS data and services are subject to the Terms of Use\n# available at: https://www.arin.net/resources/registry/whois/tou/\n#\n# If you see inaccuracies in the results, please report at\n# https://www.arin.net/resources/registry/whois/inaccuracy_reporting/\n#\n# Copyright 1997-2019, American Registry for Internet Numbers, Ltd.\n#\n```\n可以看到该ip属于 47.90.0.0/17 地址块的，所以如果下面没有在划分，同样的主机有 2^15 个，所属状态是被分配，归属ALICLOUD-HK（香港阿里云）。这个地址块属于 AL-3 (NET-47-88-0-0-1)，所以继续往上查询。\n\n \n\n地址栏输入：http://whois.arin.net/rest/net/NET-47-88-0-0-1.txt\n\n查询结果为：\n```\n \n#\n# ARIN WHOIS data and services are subject to the Terms of Use\n# available at: https://www.arin.net/resources/registry/whois/tou/\n#\n# If you see inaccuracies in the results, please report at\n# https://www.arin.net/resources/registry/whois/inaccuracy_reporting/\n#\n# Copyright 1997-2019, American Registry for Internet Numbers, Ltd.\n#\n \nNetRange:       47.88.0.0 - 47.91.255.255\nCIDR:           47.88.0.0/14\nNetName:        AL-3\nNetHandle:      NET-47-88-0-0-1\nParent:         NET47 (NET-47-0-0-0-0)\nNetType:        Direct Allocation\nOriginAS:       \nOrganization:   Alibaba.com LLC (AL-3)\nRegDate:        2015-05-18\nUpdated:        2017-04-26\nRef:            https://whois.arin.net/rest/net/NET-47-88-0-0-1\n \n#\n# ARIN WHOIS data and services are subject to the Terms of Use\n# available at: https://www.arin.net/resources/registry/whois/tou/\n#\n# If you see inaccuracies in the results, please report at\n# https://www.arin.net/resources/registry/whois/inaccuracy_reporting/\n#\n# Copyright 1997-2019, American Registry for Internet Numbers, Ltd.\n#\n```\n可以看到前缀又变短了，这个地址块可以容纳 2^18 个主机，所属组织依然是阿里。继续往上查询\n\n地址栏输入：http://whois.arin.net/rest/net/NET-47-0-0-0-0.txt\n\n查询结果：\n```\n \n#\n# ARIN WHOIS data and services are subject to the Terms of Use\n# available at: https://www.arin.net/resources/registry/whois/tou/\n#\n# If you see inaccuracies in the results, please report at\n# https://www.arin.net/resources/registry/whois/inaccuracy_reporting/\n#\n# Copyright 1997-2019, American Registry for Internet Numbers, Ltd.\n#\n \nNetRange:       47.0.0.0 - 47.255.255.255\nCIDR:           47.0.0.0/8\nNetName:        NET47\nNetHandle:      NET-47-0-0-0-0\nParent:          ()\nNetType:        Early Registrations, Maintained by ARIN\nOriginAS:       \nOrganization:   American Registry for Internet Numbers (ARIN)\nRegDate:        1989-01-06\nUpdated:        2012-02-29\nRef:            https://whois.arin.net/rest/net/NET-47-0-0-0-0\n \n#\n# ARIN WHOIS data and services are subject to the Terms of Use\n# available at: https://www.arin.net/resources/registry/whois/tou/\n#\n# If you see inaccuracies in the results, please report at\n# https://www.arin.net/resources/registry/whois/inaccuracy_reporting/\n#\n# Copyright 1997-2019, American Registry for Internet Numbers, Ltd.\n#\n```\n前缀变为8，也就是一个 A 类网络。所属于 ARIN，也就是美洲 internet 号码注册机构。","tags":["网络"]},{"title":"单例模式","url":"/2019/04/26/singleton/","content":"### 介绍\n单例模式要点：\n- 构造函数私有化\n- 保证只会实例化一个对象\n\n### 种类\n#### 饱汉式\n优点：实现简单，安全  \n缺点：唯一的对象在类本身完成实例化的时候就会被构造，但如果从未使用过这个对象，就会造成内存浪费。  \n比如下面代码，只是使用了静态方法，未使用过对象，但对象也被构造了，并且会自始至终都存在。\n```java\n//饱汉式\nclass SingleTon {\n\t\n\t //构造函数私有化\n     private SingleTon() \n     {\n    \t System.out.println(\"构造函数被调用\");\n     }\n     \n     //将唯一的对象设置为常量\n     private final static SingleTon INSTANCE=new SingleTon();\n     \n     //提供获取对象的外部接口\n     public static SingleTon getInstance()\n     {\n    \t return INSTANCE;\n     }\n     \n     public static void method()\n     {\n    \t System.out.println(\"method方法被调用\");\n     }\n}\n \npublic class MyTest\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tSingleTon.method();\n\t}\n}\n```\n\n执行结果：\n\n>构造函数被调用\n>method方法被调用\n\n#### 懒汉式[不可用]\n优点：实现了 Lazy Loading，在下面代码中可以看出，不使用 INSTANCE 的时候 INSTANCE 是不会初始化的。  \n缺点：多线程下不安全，如果线程 A 进入了 if(INSTANCE == null) 的判断后被打断，线程B又进入了 if(INSTANCE == null) ，并且继续执行，这时已经实例化了一个对象。A 再回来执行时，因为已经判断过了，所以又实例化了一个对象，就违反了单例的原则。\n```java\nclass SingleTon\n{\n\tprivate SingleTon() \n\t{\n\t\tSystem.out.println(\"构造函数被调用\");\n\t}\n\t\n\tprivate static SingleTon INSTANCE;\n\t\n    public static SingleTon getInstance()\n    {\n    \tif(INSTANCE==null)\n    \t{\n    \t\tINSTANCE=new SingleTon();\n    \t}\n    \treturn INSTANCE;\n    }\n    \n    public static void method()\n    {\n    \tSystem.out.println(\"method方法被调用\");\n    }\n}\n \npublic class LazySingleTon {\n\tpublic static void main(String[] args)\n\t{\n\t\tSingleTon.method();\n\t}\n}\n```\n执行结果：\n\n>method方法被调用\n\n#### 懒汉式双重判断\n针对懒汉式线程不安全问题有一个逐步的完善过程，双重判断是最终可用并且不影响效率的版本  \n优点：Lazy Loading 并且线程安全   \n缺点：书写麻烦(如果算的话)\n```java\nclass SingleTon {\n\tprivate SingleTon() {\n\t}\n \n\tprivate static SingleTon INSTANCE;\n \n\tpublic static SingleTon getInstance() {\n\t\tif (INSTANCE == null)\n\t\t\tsynchronized (SingleTon.class) {\n\t\t\t\tif (INSTANCE == null)\n\t\t\t\t\tINSTANCE = new SingleTon();\n\t\t\t}\n\t\treturn INSTANCE;\n\t}\n}\n```\n#### 内部静态类实现单例\n优点：安全，高效，Lazy Loading\n```java\nclass SingleTon\n{\n\tprivate SingleTon() {}\n\t\n\tprivate static class SingleTonInstance\n\t{\n\t\tprivate final static SingleTon INSTANCE=new SingleTon();\n\t}\n \n\tpublic static SingleTon getInstance() {\n\t\treturn SingleTonInstance.INSTANCE;\n\t}\n}\n```\n### Reference\nhttps://www.cnblogs.com/zhaoyan001/p/6365064.html\n\n*如有错误，请多指教*\n","tags":["Java","Pattern"]},{"title":"生产者消费者问题","url":"/2019/04/25/producer-and-consumer/","content":"### 代码\n```java\n/**\n * 生产者消费者问题\n */\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Random;\n \npublic class MyTest {\n \n\tprivate static int maxSize = 10;\n \n\tpublic static void main(String[] args) {\n\t\t// 存储数据\n\t\tLinkedList<Integer> storage = new LinkedList<Integer>();\n \n\t\t// 创建生产者消费者\n\t\tProductor p1 = new Productor(storage, \"1号生产者\");\n\t\tProductor p2 = new Productor(storage, \"2号生产者\");\n\t\tProductor p3 = new Productor(storage, \"3号生产者\");\n\t\tConsumer c1 = new Consumer(storage, \"1号消费者\");\n\t\tConsumer c2 = new Consumer(storage, \"2号消费者\");\n\t\t//Consumer c3 = new Consumer(storage, \"3号消费者\");\n \n\t\t// 创建线程\n\t\tThread t1 = new Thread(p1);\n\t\tThread t2 = new Thread(p2);\n\t\tThread t3 = new Thread(p3);\n\t\tThread t4 = new Thread(c1);\n\t\tThread t5 = new Thread(c2);\n\t\t//Thread t6 = new Thread(c3);\n \n\t\t// 开启线程\n\t\tt1.start();\n\t\tt2.start();\n\t\tt3.start();\n\t\tt4.start();\n\t\tt5.start();\n\t\t//t6.start();\n\t}\n \n\t/*\n\t * 生产者类\n\t */\n\tstatic class Productor implements Runnable {\n\t\tprivate String name;\n\t\tprivate List<Integer> list;\n \n\t\tprivate Productor(List<Integer> list, String name) {\n\t\t\tthis.list = list;\n\t\t\tthis.name = name;\n\t\t}\n \n\t\t@Override\n\t\tpublic void run() {\n\t\t\twhile (true) {\n\t\t\t\tsynchronized (list) {\n\t\t\t\t\twhile (list.size() >= maxSize) {\n\t\t\t\t\t\tSystem.out.println(name + \"因空间不足，无法生产，进入等待\");\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.wait();\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// 这里也可以随机生成一个数字当成是商品\n\t\t\t\t\tlist.add(1);\n\t\t\t\t\tSystem.out.println(name + \"生产了1个商品,现库存:\" + list.size());\n \n\t\t\t\t\t// 生产完成后唤醒所有等待线程\n\t\t\t\t\tlist.notifyAll();\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \n\t}\n \n\t/*\n\t * 消费者类\n\t */\n\tstatic class Consumer implements Runnable {\n\t\tprivate String name;\n\t\tprivate List<Integer> list;\n \n\t\tprivate Consumer(List<Integer> list, String name) {\n\t\t\tthis.list = list;\n\t\t\tthis.name = name;\n\t\t}\n \n\t\t@Override\n\t\tpublic void run() {\n\t\t\twhile (true) {\n\t\t\t\tsynchronized (list) {\n\t\t\t\t\twhile (list.size() == 0) {\n\t\t\t\t\t\tSystem.out.println(name + \"因余量不足，无法消费，进入等待队列\");\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.wait();\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// 删除list的第一个元素\n\t\t\t\t\tlist.remove(0);\n\t\t\t\t\tSystem.out.println(name + \"消费了一个商品，现库存：\" + list.size());\n \n\t\t\t\t\t// 消费完成后唤醒所有的线程\n\t\t\t\t\tlist.notifyAll();\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n \n\t\t}\n \n\t}\n \n}\n```\n代码中创建了 3 个生产者，2 个消费者，一直进行生产/消费行为。\n\n并且设置仓储的最大容量为 10。\n\n运行结果如下：\n\n>1号生产者生产了1个商品,现库存:1\n2号生产者生产了1个商品,现库存:2\n2号消费者消费了一个商品，现库存：1\n3号生产者生产了1个商品,现库存:2\n1号消费者消费了一个商品，现库存：1\n2号生产者生产了1个商品,现库存:2\n1号生产者生产了1个商品,现库存:3\n1号消费者消费了一个商品，现库存：2\n2号消费者消费了一个商品，现库存：1\n3号生产者生产了1个商品,现库存:2\n1号生产者生产了1个商品,现库存:3\n2号生产者生产了1个商品,现库存:4\n3号生产者生产了1个商品,现库存:5\n1号消费者消费了一个商品，现库存：4\n2号消费者消费了一个商品，现库存：3\n1号生产者生产了1个商品,现库存:4\n2号生产者生产了1个商品,现库存:5\n2号消费者消费了一个商品，现库存：4\n3号生产者生产了1个商品,现库存:5\n1号消费者消费了一个商品，现库存：4\n1号生产者生产了1个商品,现库存:5\n2号生产者生产了1个商品,现库存:6\n2号消费者消费了一个商品，现库存：5\n3号生产者生产了1个商品,现库存:6\n1号消费者消费了一个商品，现库存：5\n2号生产者生产了1个商品,现库存:6\n1号生产者生产了1个商品,现库存:7\n1号消费者消费了一个商品，现库存：6\n3号生产者生产了1个商品,现库存:7\n2号消费者消费了一个商品，现库存：6\n2号生产者生产了1个商品,现库存:7\n1号生产者生产了1个商品,现库存:8\n2号消费者消费了一个商品，现库存：7\n3号生产者生产了1个商品,现库存:8\n1号消费者消费了一个商品，现库存：7\n2号生产者生产了1个商品,现库存:8\n1号生产者生产了1个商品,现库存:9\n3号生产者生产了1个商品,现库存:10\n2号消费者消费了一个商品，现库存：9\n1号消费者消费了一个商品，现库存：8\n2号生产者生产了1个商品,现库存:9\n1号生产者生产了1个商品,现库存:10\n2号消费者消费了一个商品，现库存：9\n3号生产者生产了1个商品,现库存:10\n1号消费者消费了一个商品，现库存：9\n2号生产者生产了1个商品,现库存:10\n1号生产者因空间不足，无法生产，进入等待\n3号生产者因空间不足，无法生产，进入等待\n2号消费者消费了一个商品，现库存：9\n1号消费者消费了一个商品，现库存：8\n3号生产者生产了1个商品,现库存:9\n1号生产者生产了1个商品,现库存:10\n2号生产者因空间不足，无法生产，进入等待\n1号消费者消费了一个商品，现库存：9\n2号生产者生产了1个商品,现库存:10\n3号生产者因空间不足，无法生产，进入等待\n1号生产者因空间不足，无法生产，进入等待\n2号消费者消费了一个商品，现库存：9\n1号生产者生产了1个商品,现库存:10\n3号生产者因空间不足，无法生产，进入等待\n......\n\n### 注意点\n1、wait 外面一般要套用一个 while (条件判断)\n如果不加，那么notify过早，线程会陷入等待；如果用 if(条件判断)，那么线程在判断条件后，进入等待；这时条件已经被更改，该线程被唤醒后会继续执行，而不会重新判断是否符合现在的条件。\n2、应使用 notifyAll 而不是 notify  \n如果仓储已满，而被唤醒的一直是生产者，那么所有线程都将陷入等待。\n\n### Reference\nhttps://www.jianshu.com/p/e29632593057\n","tags":["Java","OS"]},{"title":"Java 初始化顺序","url":"/2019/04/23/Java-init.1/","content":"\n### 实验过程\n\n#### 结论一\n静态代码块并不一定初始化在静态成员前，两者顺序关系与代码的顺序有关，依据如下实验\n```java\n/**\n * 测试类的初始化顺序\n * @author 神奇女侠\n *\n */\n \npublic class MyTest {\n \n\t\n\t//静态成员\n\tpublic static MyTest t=new MyTest();\n\t\n\t//静态代码块\n\tstatic\n\t{\n\t\tSystem.out.println(\"这里是MyTest类的静态代码块\");\n\t}\n\t\n\t//构造函数\n\tpublic MyTest()\n\t{\n\t\tSystem.out.println(\"构造函数被执行\");\n\t}\n\t\n\t//主函数\n\tpublic static void main(String[] args)\n\t{\n\t\t\n\t}\n \n}\n```\n执行结果：\n\n构造函数被执行\n这里是MyTest类的静态代码块\n\n```java\n/**\n * 测试类的初始化顺序\n * @author 神奇女侠\n *\n */\n \npublic class MyTest {\n\t//静态代码块\n\tstatic\n\t{\n\t\tSystem.out.println(\"这里是MyTest类的静态代码块\");\n\t}\n\t\t\n\t//静态成员\n\tpublic static MyTest t=new MyTest();\n\t\n\t//构造函数\n\tpublic MyTest()\n\t{\n\t\tSystem.out.println(\"构造函数被执行\");\n\t}\n\t\n\t//主函数\n\tpublic static void main(String[] args)\n\t{\n\t\t\n\t}\n}\n```\n执行结果：\n\n这里是MyTest类的静态代码块\n构造函数被执行\n\n#### 结论二\n内部类的静态代码块与静态成员的初始化顺序也与代码中的顺序有关\n```java\npublic class MyTest {\n\t//静态代码块\n\tstatic\n\t{\n\t\tSystem.out.println(\"这里是MyTest类的静态代码块\");\n\t}\n\t\t\n\t//静态成员\n\t//public static MyTest t=new MyTest();\n\t\n\t//构造函数\n\tpublic MyTest()\n\t{\n\t\tSystem.out.println(\"构造函数被执行\");\n\t}\n\t\n\t//内部类\n\tpublic static class Inner\n\t{\n\t\t//内部类的静态代码块\n\t\tstatic\n\t\t{\n\t\t\tSystem.out.println(\"这里是Inner类的静态代码块\");\n\t\t}\n\t\t\t\n\t\t//静态成员\n\t\tpublic static MyTest t=new MyTest();\n\t\t\n\t\tpublic static void Method()\n\t\t{\n\t\t\tSystem.out.println(\"Method()被执行\");\n\t\t}\n\t}\n\t\n\t//主函数\n\tpublic static void main(String[] args)\n\t{\n\t\tMyTest.Inner.Method();\n\t}\n}\n```\n执行结果：\n\n这里是MyTest类的静态代码块\n这里是Inner类的静态代码块\n构造函数被执行\nMethod()被执行\n\n```java\npublic class MyTest {\n\t//静态代码块\n\tstatic\n\t{\n\t\tSystem.out.println(\"这里是MyTest类的静态代码块\");\n\t}\n\t\t\n\t//静态成员\n\t//public static MyTest t=new MyTest();\n\t\n\t//构造函数\n\tpublic MyTest()\n\t{\n\t\tSystem.out.println(\"构造函数被执行\");\n\t}\n\t\n\t//内部类\n\tpublic static class Inner\n\t{\n\t\t\n\t\t//静态成员\n\t\tpublic static MyTest t=new MyTest();\n\t\t\n\t\t//内部类的静态代码块\n\t\tstatic\n\t\t{\n\t\t\tSystem.out.println(\"这里是Inner类的静态代码块\");\n\t\t}\n\t\t\t\t\t\n\t\t\n\t\tpublic static void Method()\n\t\t{\n\t\t\tSystem.out.println(\"Method()被执行\");\n\t\t}\n\t}\n\t\n\t//主函数\n\tpublic static void main(String[] args)\n\t{\n\t\tMyTest.Inner.Method();\n\t}\n}\n```\n\n这里是MyTest类的静态代码块\n构造函数被执行\n这里是Inner类的静态代码块\nMethod()被执行\n\n#### 结论三\n类的使用需经过加载(将二进制文件，即.class文件加载进内存)，链接，初始化。静态代码块的执行与静态成员的初始化都在类的初始化时期；也就是说，类只有被使用时才会完成初始化。\n分析：MyTest的静态代码块始终首先被执行，是因为jvm使用了MyTest内的main方法。所以MyTest在执行初的时候就完成了加载，链接，初始化三步。\n\n而Inner可以理解为是MyTest的静态成员，应该在一开始就完成了初始化，但是Inner内的静态代码块却没有在MyTest的静态成员初始化的时候执行，说明这时的Inner只是完成了加载，链接两步。直到调用了Inner内的Method方法，Inner的初始化才被完成。    \n\n#### 结论四\n只有类完成初始化之后（加载，链接，初始化）,才可以new对象。new对象的初始化顺序为：构造代码块，成员变量初始化，构造函数（先父后子）\n\n总结：类的初始化与对象的初始化是不一样的，也就可以理解为什么静态的只会执行一次，而非静态new多少次就执行多少次。因为静态的初始化是在类本身的初始化时期进行的，与对象的初始化不同。     \n\n### 总结\n引用一下别人的总结：\n>顺序是：父类静态属性->父类静态代码块->子类静态变量->子类静态代码块->父类非静态变量->父类非静态代码块->父类构造函数->子类非静态变量->子类非静态代码块->子类构造函数\n>这样的加载顺序不是绝对的 因为静态变量和静态代码块跟声明顺序有关。\n>对于如果静态代码块中调用静态变量，那么静态变量必须在静态代码块前面声明；如果静态代码块中没有调用静态变量，那么就跟顺序有关了，谁先声明谁先被加载。说白了还是顺序加载，之所以会出现“如果静态代码块中调用静态变量，那么静态变量必须在静态代码块前面声明”，是因为变量是声明，所以出现编译错误。\n>应用到内部类中 静态变量和静态代码块跟声明顺序有关。 这样就可以解释你的问题了。内部类也是类。\n>测试所用jdk版本1.8.0_20\n>类静态块-类静态属性这个跟顺序有关系 如果类静态属性在类静态代码块之前 那么类静态属性先初始化\n\n### Reference：\nhttps://www.oschina.net/question/2273217_217864   \nhttp://www.cnblogs.com/yahokuma/p/3668138.html   \n\n*如有错误，请多指教*\n\n\n\n","tags":["Java"]},{"title":"局域网聊天室","url":"/2018/08/04/lanChat/","content":"### 效果展示\n\n一个局域网内的聊天室，一个客户端发送了信息之后，服务端将其广播给当前连接的所有客户端。\n![](/img/lanchat.gif)\n\n### 服务端部分\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading;\n \nnamespace Unity聊天室服务端\n{\n    class Client\n    {\n        private Socket clientSkt;\n        private Thread t;\n        private byte[] rcvData;\n        private string massage;\n \n \n        public Client(Socket client)\n        {\n            this.clientSkt = client;\n            t = new Thread(ReceiveData);\n            t.Start();\n            rcvData = new byte[1024];\n            Console.WriteLine(\"一个客户端已连接\");\n        }\n \n \n        public bool Connected { get { return clientSkt.Connected; } }\n        /*connected返回的只是服务器是否断开和客户端的连接\n         *如果客户端单方断开了连接，这里的connected依然是true\n         * 所以要用poll来判断是否处于连通状态\n         */\n \n \n        /// <summary>\n        /// 接受客户端发来的信息，并调用广播方法\n        /// </summary>\n        private void ReceiveData()\n        {\n            while (true)\n            {\n \n                if (clientSkt.Poll(10, SelectMode.SelectRead))\n                {\n \n                    Program.accptClientList.Remove(this);\n                    clientSkt.Close();\n                    Console.WriteLine(\"一条连接已中断\");\n                    break;\n                }\n                else\n                {\n                    int lenth = clientSkt.Receive(rcvData);\n                    massage = Encoding.UTF8.GetString(rcvData, 0, lenth);\n                    Console.WriteLine(\"服务端收到了一条消息：\" + massage);\n                    Program.BroadcastMsg(massage);\n                }\n            }\n        }\n        /// <summary>\n        /// 发送消息给该客户端\n        /// </summary>\n        /// <param name=\"msg\"></param>\n        public void SendMsg(string msg)\n        {\n \n            clientSkt.Send(Encoding.UTF8.GetBytes(msg));\n        }\n \n \n \n    }\n}\n```\n\n```c#\nusing System;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nusing System.Collections.Generic;\n \nnamespace Unity聊天室服务端\n{\n    \n    class Program\n    {\n        public static List<Client> accptClientList = new List<Client>();\n        /// <summary>\n        /// 将msg广播给所有现在仍然连接的客户端\n        /// </summary>\n        /// <param name=\"msg\"></param>\n        public static void BroadcastMsg(string msg)\n        {\n           \n \n            /*foreach是只读模式，在里面不能删除自己，因为一旦删除，就会重新排序\n             * 比如原来的索引0被删除了，下一次foreach的索引0就会变成原来的1\n             * 1就会变成2，所以会报“集合已修改；可能无法执行枚举操作”的错误\n             */\n \n            //foreach(Client clt in accptClientList)\n            //{\n            //    if(clt.Connected)\n            //    {\n            //        clt.SendMsg(msg);\n            //        Console.WriteLine(\"发送消息成功\");\n            //    }\n            //    else\n            //    {\n            //        accptClientList.Remove(clt);\n            //    }\n            //}\n    \n            for (int i = 0; i < accptClientList.Count; i++)\n            {\n                accptClientList[i].SendMsg(msg);\n            }\n        }\n \n        static void Main(string[] args)\n        {\n            Socket serveSkt = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n \n            //绑定ip和端口\n            serveSkt.Bind(new IPEndPoint(IPAddress.Parse(\"192.168.1.4\"), 10086));\n \n            //开始监听消息\n            serveSkt.Listen(10);\n            Console.WriteLine(\"服务端正在运行\");\n \n            while (true)\n            {\n                Socket client = serveSkt.Accept();\n                accptClientList.Add(new Client(client));\n            }\n \n        }\n    }\n}\n```\n\n### Unity 部分\n```c#\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing System.Net.Sockets;\nusing System.Net;\nusing System.Text;\nusing UnityEngine.UI;\nusing System.Threading;\n \npublic class ChatManage : MonoBehaviour {\n    \n    private Socket client;\n    private Thread t;\n    private byte[] receiveMsg;\n    private byte[] sendMsg;\n    private string receiveSting;\n \n    public InputField inputField;\n    public Button sendBtn;\n    public Text msgText;\n \n \n    private void Awake()\n    {\n       \n    }\n    // Use this for initialization\n    void Start () {\n \n        sendMsg = new byte[1024];\n        receiveMsg = new byte[1024];\n        client = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n        client.Connect(new IPEndPoint(IPAddress.Parse(\"192.168.1.4\"), 10086));\n        \n \n        t = new Thread(ReceiveMsg);\n        t.Start();\n \n        /*\n         * receive不要写在主线程里面，不然服务端那边如果一直不传递消息过来的话\n         * 主线程就会一直堵塞\n         */\n    }\n\t\n\t// Update is called once per frame\n\tvoid Update () {\n        Debug.Log(\"收到消息为\"+receiveSting);\n        if (receiveSting != \"\")\n        {\n            msgText.text += (\"\\n\" + receiveSting);\n            receiveSting = \"\";\n        }\n    }\n \n    void ReceiveMsg()\n    {\n        while (true)\n        {\n            if (client.Connected)\n            {\n                int lenth = client.Receive(receiveMsg);\n                receiveSting = Encoding.UTF8.GetString(receiveMsg, 0, lenth);\n            }\n            else break;\n        }\n    }\n \npublic void OnSendBtn()\n    {\n        if(inputField.text!=\"\")\n        {\n            sendMsg = Encoding.UTF8.GetBytes(inputField.text);\n            client.Send(sendMsg);\n            inputField.text = \"\";\n        }\n        \n    }\n    private void OnDestroy()\n    {\n        //t.Abort();\n        client.Shutdown(SocketShutdown.Both);\n        client.Close();\n    }\n}\n```","tags":["网络","Unity"]},{"title":"CF Robot Vacuum Cleaner","url":"/2018/03/18/CF-Robot-Vacuum-Cleaner/","content":"\n### 题号\nCodeForces - 922D\n### 思路\ns/h越大的越往前排，这样整体的字符串才是s/h值由大变小。\n\n### 代码\n```c++\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int MAX=100005;\nstruct T\n{\n\tint sNum;\n\tint hNum;\n\tfloat sDh;\n\tint sh;\n}tManager[MAX];\nbool cmp(T a,T b)\n{\n\treturn a.sDh>b.sDh;\n}\nint main()\n{\n\tint total,id=0;\n\tchar str[MAX];\n\tcin>>total;\n\twhile(id<total)\n\t{\n\t    cin>>str;\n\t    int i=0;\n\t    while(str[i]!='\\0')\n\t    {\n\t    \tif(str[i]=='s')\n\t\t\t\ttManager[id].sNum++;\n\t    \telse if(str[i]=='h')\n\t\t\t\t{\n\t    \ttManager[id].hNum++;\n\t\t\t\ttManager[id].sh+=tManager[id].sNum;\n\t\t\t  }\n\t\t\t\ti++;\n\t    }\n\t\t\tif(!tManager[id].hNum)\n\t\t\t{\n\t\t\t\ttManager[id].sDh=MAX;//s的数量与h的数量的比值最大有可能为99999；\n\t\t\t\t//所以用MAX就足够了\n\t\t\t}\n\t\t\telse\n\t    tManager[id].sDh=(float)tManager[id].sNum/tManager[id].hNum;\n\t\t\tid++;\n\t}\n\tsort(tManager,tManager+id,cmp);\n  long long ans=0,sCot=0;//ans最大有可能是5w*5w，所以要用long long\n  for(int i=0;i<id;i++)\n\t{\n\t\tans+=sCot*tManager[i].hNum;\n\t\tans+=tManager[i].sh;\n\t\tsCot+=tManager[i].sNum;\n\t}\n   cout<<ans<<endl;\n \n}\n```\n","tags":["algorithm"]},{"title":"最长回文子串","url":"/2018/03/16/longest-palindromic-substring.1/","content":"\n### HDOJ3068\n```c++\n#include<iostream>\n#include<cstring>\n#include<algorithm> \nconst int MAX=110005;\nchar s1[MAX];\nchar s[2*MAX+2];//增加MAX+1个‘#’和一个‘$’ \nint d[2*MAX+2];\nusing namespace std;\nint main()\n{\n\twhile(cin>>s1)\n\t{\n\t\tmemset(d,0,sizeof(d));\n\t\tmemset(s,0,sizeof(s));\n\t\t\n\t\t//字符串预处理 \n\t   int ans=1;\n\t   int len=strlen(s1);\n\t   s[0]='&';\n\t   for(int i=1;i<=2*len+1;i+=2)\n\t   {\n\t   \ts[i]='#';\n\t   }\n\t   int k=0;\n\t   for(int i=2;i<=2*len;i+=2)\n\t   {\n\t   \ts[i]=s1[k++];\n\t   }\n\t   \n\t   //debug\n\t   /*for(int i=0;i<strlen(s);i++)\n\t   {\n\t   \tcout<<s[i]<<\" \";\n\t   }\n\t   cout<<endl;*/\n\t   \n\t   \n\t   \n\t   int id=0,mx=0;\n\t   d[0]=1;d[1]=1;d[2]=2;\n\t   //mx是以id为中心的回文字串的右边缘（不在字串内） \n\t   //id是已知的回文字串中，右边缘最靠右的子串的中心\n\t   id=2;mx=id+d[id];\n\t   \n\t   for(int i=3;s[i]!='\\0';i++)\n\t   {\n\t   \t\n\t   \t//j是i关于id的对称点\n\t   \tint j=2*id-i;\n\t   \t\n\t   \t//当i<mx,d[i]>=min(mx-i,d[j]) \n\t   \tif(i<mx)\n\t   \t{\n\t\t\tif(d[j]<mx-i)\n\t\t\t{\n\t\t\t\td[i]=d[j];\n\t\t\t}  \n\t\t  \n\t\t\telse\n\t\t\t{\n\t\t\t\td[i]=mx-i;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//当i>=mx的时候，的d[i]=1; \n\t\telse d[i]=1;\n\t\t\n\t\t/*\n\t\t上13行可写成d[i]=i<mx?min(d[2*id-i],mx-i):1; \n\t\t*/ \n\t\t\n\t\t//确定了d[i]的最小值之后，超出部分逐个比较 \n\t\twhile(s[i+d[i]]==s[i-d[i]])\n\t\t\td[i]++;\n\t\t\n\t\t//更新id，mx的值 \n\t\tif(i+d[i]>mx)\n\t\t{\n\t\t\tmx=i+d[i];\n\t\t\tid=i;\n\t\t}\n\t   \n        //更新最大值 \n\t\tif(d[i]-1>ans)\n\t\tans=d[i]-1;\n\t   } \n\t   \n\t   //输出答案 \n\t   cout<<ans<<endl;\n\t}\n\t\n}\n\n```\n\n### LeetCode: Longest Palindromic Substring\n```c++\nclass Solution {\npublic:\n    string longestPalindrome(string s) {\n         char pad='#';\n    int len=s.length();\n    int total_len=2*len+1;\n    char* cstr=new char[total_len];\n    int* rcd =new int[total_len];//记录以index为中心的最长回文子串长度\n    cstr[0]=pad;\n    int k=1;\n    for(int i=0;i<len;i++)\n    {\n      cstr[k++]=s[i];\n      cstr[k++]=pad;\n    }\n\n    int max_index=0;\n    for(int i=0;i<total_len;i++)\n    {\n      rcd[i]=1;\n      for(int j=i/2;j<i;j++)\n      {\n        if(2*j-i<0)continue;\n        if(rcd[j]==i-j&&cstr[2*j-i]==cstr[i])\n        rcd[j]++;\n        if(rcd[j]>rcd[max_index])\n        max_index=j;\n      }\n    }\n\n    string sb=\"\";\n\n    //起始位置的下标\n\n    int t=max_index-rcd[max_index]+1;\n    for(int i=t;i<=2*max_index-t;i++)\n    {\n      if(cstr[i]!=pad)\n      //append会运行错\n      //sb.append(cstr,i,1);\n          sb+=cstr[i];\n    }\n    return sb;\n        \n    }\n};\n```\n\n","tags":["algorithm","LeetCode"]},{"title":"My Summer Holiday Lives","url":"/2017/09/06/2017-08-24-My-Summer-Holiday-Lives/","content":"\n参考资料：\n* [字符串参考资料](#1.1.1)\n* [数学参考资料](#1.1.2)\n* [数据结构参考资料](#1.1.3)\n* [图论参考资料](#1.1.4)\n* [计算几何参考资料](#1.1.5)\n\n代码强化训练\n* [代码强化训练1 p3-24](#1.2.1)\n* [代码强化训练2 p25-42](#1.2.2)\n* [代码强化训练3 p42-74](#1.2.3)\n* [代码强化训练4 p74-96](#1.2.4)\n* [代码强化训练5 p96-121](#1.2.5)\n* [代码强化训练6 p121-152](#1.2.6)\n\n组队训练\n* [Summer 2017 Team Training 1](#1.3.1)\n* [Summer 2017 Team Training 2](#1.3.2)\n* [Summer 2017 Team Training 3](#1.3.3)\n* [Summer 2017 Team Training 4](#1.3.4)\n* [Summer 2017 Team Training 5](#1.3.5)\n\n个人强化训练\n* [Summer 2017 Individual Training 1](#1.4.1)\n* [Summer 2017 Individual Training 2](#1.4.2)\n\n综合训练\n* [Summer 2017 Team Professional Contest 1](#1.5.1)\n* [Summer 2017 Team Professional Contest 2](#1.5.2)\n* [Summer 2017 Team Professional Contest 3](#1.5.3)\n\n<h4 id=\"1.1.1\"> 字符串参考资料</h4>\n\n>1、从头到尾彻底理解KMP\n><http://www.cnblogs.com/zhangtianq/p/5839909.html>\n>\n>2、最长回文子串\n><http://blog.csdn.net/kangroger/article/details/3774263>\n>\n>3、AC自动机最详细的讲解，让你一次学会AC自动机\n><http://blog.csdn.net/creatorx/article/details/71100840>\n>\n>4、后缀数组\n><http://www.cnblogs.com/shanchuan04/p/5324009.html>\n><http://blog.csdn.net/fp_hzq/article/details/8990932>\n>\n>5、后缀自动机\n><https://www.zhihu.com/question/34039162>\n\n<h4 id=\"1.1.2\">数学参考资料</h4>\n\n>1、素数有关算法\n><http://blog.csdn.net/snow_me/article/details/52588819>\n>\n>2、扩展欧几里德算法\n><http://blog.csdn.net/zhjchengfeng5/article/details/7786595>\n>\n>3、逆元\n><http://blog.csdn.net/acdreamers/article/details/8220787>\n>\n>4、Miller_rabin算法\n><http://blog.csdn.net/maxichu/article/details/45458569>\n>\n>5、欧拉函数\n><http://blog.csdn.net/sentimental_dog/article/details/52002608>\n>\n>6、模线性方程组\n><http://blog.csdn.net/qq_21120027/article/details/51340218>\n>\n>7、高斯消元法\n><http://blog.csdn.net/duanxian0621/article/details/7408887>\n>\n>8、FFT（快速傅氏变换）\n><http://www.gatevin.moe/acm/fft%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/>\n>\n>9、莫比乌斯反演\n><http://blog.csdn.net/acdreamers/article/details/8542292>\n>\n>10、离散对数（Baby Step Giant Step）\n><http://blog.csdn.net/acdreamers/article/details/8579511>\n\n<h4 id=\"1.1.3\">数据结构参考资料</h4>\n\n>1、划分树\n><http://blog.csdn.net/shiqi_614/article/details/8041390>\n>\n>2、主席树\n><http://blog.csdn.net/sprintfwater/article/details/9162041>\n>\n>3、区间最值查询（RMQ）\n><http://blog.csdn.net/liang5630/article/details/7917702>\n><http://blog.csdn.net/metalseed/article/details/7953260>\n>\n>4、树链剖分原理\n><http://blog.csdn.net/acdreamers/article/details/10591443>\n>\n>5、树状数组\n><http://blog.csdn.net/ljd4305/article/details/10101535>\n>\n>6、线段树\n><http://www.cnblogs.com/TenosDoIt/p/3453089.html>\n>\n>7、Splay Tree（伸展树）\n><http://blog.csdn.net/niuox/article/details/8018280>\n>\n>8、动态树\n><http://blog.csdn.net/d891320478/article/details/9181385>\n>\n>9、主席树\n><http://blog.csdn.net/sprintfwater/article/details/9162041>\n\n\n\n<h4 id=\"1.1.4\">图论参考资料</h4>\n\n>1、最短路：Dijkstra算法\n><http://www.cnblogs.com/skywang12345/p/3711512.html>\n>\n>2、最短路：Bellman-Ford算法\n><http://blog.csdn.net/niushuai666/article/details/6791765>\n>\n>3、最短路：SPFA算法\n><http://www.layz.net/LAOJ/suanfa/s9-4.html>\n>\n>4、最小生成树：Kruskal算法 ><http://blog.csdn.net/luomingjun12315/article/details/47700237>\n>\n>5、最小生成树：Prim算法\n><http://blog.csdn.net/yeruby/article/details/38615045>\n>\n>6、次小生成树\n><http://yzmduncan.iteye.com/blog/1018358>\n>\n>7、有向图的强连通分量：Tarjan算法\n><http://www.cnblogs.com/uncle-lu/p/5876729.html>\n>\n>8、有向图的强连通分量：Kosaraju算法\n><http://www.cnblogs.com/nullzx/p/6437926.html>\n>\n>9、最小树形图\n><http://www.cnblogs.com/Ash-ly/p/5536796.html>\n>\n>10、二分图\n><http://dsqiu.iteye.com/blog/1689505>\n><http://www.renfei.org/blog/bipartite-matching.html>\n>\n>11、二分图最大匹配：匈牙利算法\n><http://blog.csdn.net/dark_scope/article/details/8880547>\n><http://www.cnblogs.com/pony1993/archive/2012/07/25/2607738.html>\n>\n>12、二分图最大匹配：Hopcroft-Karp算法\n><http://blog.csdn.net/wall_f/article/details/8248373>\n>\n>13、生成树计数：Matrix-Tree定理\n><http://blog.csdn.net/longshuai0821/article/details/7764267>\n>\n>14、二分图多重匹配问题\n><http://blog.csdn.net/u014427196/article/details/48319639>\n>\n>15、二分图最大权匹配：Kuhn-Munkres算法\n><http://www.cnblogs.com/kuangbin/archive/2012/08/19/2646535.html>\n>\n>16、最大流问题\n><http://blog.csdn.net/yiqingnian28/article/details/23388633>\n><http://www.cnblogs.com/kuangbin/archive/2011/07/26/2117636.html>\n>\n>17、最小费用最大流\n><http://blog.csdn.net/stillxjy/article/details/52047189>\n>\n>18、2-SAT\n><http://blog.csdn.net/jarjingx/article/details/8521690>\n>\n>19、曼哈顿距离最小生成树\n><http://blog.csdn.net/acm_cxlove/article/details/8890003>\n>\n>20、莫队算法\n><http://blog.csdn.net/hzj1054689699/article/details/51866615>\n>\n>21、一般图匹配问题：带花树\n><http://blog.csdn.net/u014261987/article/details/41350003>\n><http://blog.csdn.net/jackyguo1992/article/details/11271497>\n>\n>22、LCA（最近公共祖先）\n><http://blog.csdn.net/liangzhaoyang1/article/details/52549822>\n><http://www.cnblogs.com/wuminye/p/3527176.html>\n><http://blog.csdn.net/Janis_z/article/details/52937631?locationNum=6&fps=1>\n\n<h4 id=\"1.1.5\">计算几何参考资料</h4>\n>1、计算几何\n><http://www.cnblogs.com/kuangbin/category/410309.html>\n\n<h4 id=\"1.1.6\">其他-参考资料</h4>\n>1、动态规划\n><http://blog.csdn.net/baidu_28312631/article/details/47418773>\n><http://blog.csdn.net/scythe666/article/details/50921628>\n>\n>2、莫队算法\n><http://blog.csdn.net/hnshhslsh/article/details/50582926>\n\n<h3 id=\"1.2.1\">7-20 代码强化训练1 《葵花宝典》P3-24</h3>\nA - Cow Patterns\n来源：POJ – 3167\n知识点：扩展KMP等\n[http://blog.csdn.net/tmeteorj/article/details/8693366](http://blog.csdn.net/tmeteorj/article/details/8693366)\n[http://www.cppblog.com/zxb/archive/2010/10/06/128782.aspx?opt=admin](http://www.cppblog.com/zxb/archive/2010/10/06/128782.aspx?opt=admin)\n\nB - Best Sequence\n来源：POJ – 1699\n知识点：扩展KMP+DFS等\n[http://blog.csdn.net/zzzz40/article/details/39186109](http://blog.csdn.net/zzzz40/article/details/39186109)\n\nC – Palindrome\n来源：POJ – 3974\n知识点：Manacher算法等\n[http://blog.csdn.net/u010885899/article/details/45366633](http://blog.csdn.net/u010885899/article/details/45366633)\n[http://blog.csdn.net/geniusluzh/article/details/8639759](http://blog.csdn.net/geniusluzh/article/details/8639759)\n\nD - Keywords Search\n来源：HDU – 2222\n知识点：AC自动机等\n[http://blog.csdn.net/hnust_xiehonghao/article/details/9130539](http://blog.csdn.net/hnust_xiehonghao/article/details/9130539)\n\nE - Longest Common Substring\n来源：HDU – 1403\n知识点：后缀数组DA算法（倍增算法）等\n[http://blog.csdn.net/xinag578/article/details/50164599](http://blog.csdn.net/xinag578/article/details/50164599)\n\nF - Power Strings\n来源：POJ – 2406\n知识点：后缀数组DC3算法等\n[http://blog.csdn.net/libin56842/article/details/46310425](http://blog.csdn.net/libin56842/article/details/46310425)\n\nG – String\n来源：CodeForces - 123D\n知识点：后缀自动机（SAM）等\n[http://blog.csdn.net/dyx404514/article/details/8713542](http://blog.csdn.net/dyx404514/article/details/8713542)\n[http://www.hankcs.com/program/algorithm/codeforces-123d-string.html](http://www.hankcs.com/program/algorithm/codeforces-123d-string.html)\n\nH - Prime Distance\n来源：POJ – 2689\n知识点：大区间素数筛选等\n[http://www.cnblogs.com/kuangbin/archive/2013/05/20/3089840.html](http://www.cnblogs.com/kuangbin/archive/2013/05/20/3089840.html)\n\nI - The Factor\n来源：HDU – 5428\n知识点：素数筛选合数分解等\n[http://www.bubuko.com/infodetail-1079772.html](http://www.bubuko.com/infodetail-1079772.html)\n[http://www.cnblogs.com/Apro/p/4784808.html](http://www.cnblogs.com/Apro/p/4784808.html)\n\nJ - A/B\n来源：HDU - 1576\n知识点：扩展欧几里得算法等\n[http://blog.csdn.net/ljd4305/article/details/26057385](http://blog.csdn.net/ljd4305/article/details/26057385)\n[http://blog.csdn.net/lyc1635566ty/article/details/50611246](http://blog.csdn.net/lyc1635566ty/article/details/50611246)\n\nK - X问题\n来源：HDU - 1573\n知识点：解一元线性同余方程组、中国剩余定理等\n[http://www.cnblogs.com/zhangmingcheng/p/4238407.html](http://www.cnblogs.com/zhangmingcheng/p/4238407.html)\n[http://blog.csdn.net/a601025382s/article/details/10296577](http://blog.csdn.net/a601025382s/article/details/10296577)\n\nL - Prime Test\n来源：POJ – 1811\n知识点：大素数判断和素因子分解等\n[http://www.cnblogs.com/kuangbin/archive/2012/08/19/2646404.html](http://www.cnblogs.com/kuangbin/archive/2012/08/19/2646404.html)\n\nM - Farey Sequence\n来源：POJ – 2478\n知识点：欧拉函数等\n[http://blog.csdn.net/aaaaacmer/article/details/47272037](http://blog.csdn.net/aaaaacmer/article/details/47272037)\n\n<h3 id=\"1.2.2\">7-21 代码强化训练2 《葵花宝典》P24-42</h3>\n\nA - Kind of a Blur\n来源：HDU - 3359\n知识点：高斯消元法等\n<http://blog.csdn.net/qwb492859377/article/details/47013321>\n\nB - A * B Problem Plus\n来源：HDU – 1402\n知识点：FFT、大整数乘法等\n<http://blog.csdn.net/sdj222555/article/details/9786527>\n\nC - 3-idiots\n来源：HDU – 4609\n知识点：FFT计数等\n<http://blog.csdn.net/qq_33184171/article/details/54427994>\n\nD - Painter's Problem\n来源：POJ – 1681\n知识点：高斯消元法（一类开关问题，对2取模的01方程组）等\n<http://www.cnblogs.com/kuangbin/archive/2012/08/31/2665913.html>\n\nE - Widget Factory\n来源：POJ – 2947\n知识点：高斯消元法（解同余方程组）等\n<http://www.cnblogs.com/gj-Acit/p/3903085.html>\n\nF - Partition\n来源：HDU – 4651\n知识点：整数拆分等\n<http://www.cnblogs.com/zhsl/archive/2013/08/07/3242268.html>\n\nG - Integer Partition\n来源：HDU – 4658\n知识点：整数划分、生成函数等\n<http://blog.csdn.net/a601025382s/article/details/10299367>\n\nH - Sumdiv\n来源：POJ – 1845\n知识点：求A^B的约数之和对MOD取模等\n<http://www.cnblogs.com/kuangbin/archive/2012/08/10/2631225.html>\n\nI - GCD\n来源：HDU – 1695\n知识点：莫比乌斯反演等\n<http://blog.csdn.net/lixuepeng_001/article/details/50577932>\n\nJ - Discrete Logging\n来源：POJ – 2417\n知识点：离散对数（Baby Step Giant Step）等\n<http://www.cnblogs.com/kuangbin/archive/2013/08/24/3278852.html>\n\nK - K-th Number\n来源：POJ – 2104\n知识点：经典划分树、主席树等\n<http://blog.csdn.net/pure_lady/article/details/46806833>\n<http://www.cnblogs.com/oyking/p/3230296.html>\n\nL - Sliding Window\n来源：POJ – 2823\n知识点：单调队列、线段树、一维RMQ等\n<http://blog.csdn.net/u013351484/article/details/45112271>\n\nM – Cornfields\n来源：POJ – 2019\n知识点：二维RMQ等\n<http://www.cnblogs.com/kuangbin/p/3227420.html>\n\n<h3 id=\"1.2.3\">7-23 代码强化训练3 《葵花宝典》P43-74</h3>\n\nA - Aragorn's Story\n来源： HDU – 3966\n知识点：树链剖分+树状数组等\n<http://www.cnblogs.com/kuangbin/archive/2013/08/14/3258736.html>\n\nB - Query on a tree\n来源： SPOJ – QTREE\n知识点：树链剖分+线段树等\n<http://blog.csdn.net/niuox/article/details/8145842>\n\nC - SuperMemo\n来源：POJ – 3580\n知识点：Splay Tree（伸展树）等\n<http://blog.csdn.net/jasonzhu8/article/details/5747811>\n\nD - Query on The Trees\n来源：HDU – 4010\n知识点：动态树等\n<http://www.cnblogs.com/kuangbin/archive/2013/09/04/3300251.html>\n\nE - D-query\n来源：SPOJ - DQUERY\n知识点：主席树-区间不同数的个数 等\n<http://blog.csdn.net/aozil_yang/article/details/65448883>\n\nF - K-th Number\n来源：POJ – 2104\n知识点：主席树-静态区间第k大 等\n<http://www.cnblogs.com/kuangbin/archive/2013/09/05/3302731.html>\n\nG - Count on a tree\n来源：SPOJ – COT\n知识点：LCA+主席树等\n<http://blog.csdn.net/acm_cxlove/article/details/8564167>\n<http://www.cnblogs.com/arbitrary/archive/2013/10/09/3360104.html>\n\n\nH - Dynamic Rankings\n来源： ZOJ - 2112\n知识点：树状数组+主席树-动态第k大等\n<http://www.cnblogs.com/kuangbin/p/3308118.html>\n\nI - MPI Maelstrom\n来源：POJ – 1502\n知识点：Dijkstra算法等\n<http://blog.csdn.net/u013446688/article/details/42708487>\n\nJ - Invitation Cards\n来源：POJ – 1511\n知识点：优先队列优化的Dijkstra算法等\n<http://www.cnblogs.com/kuangbin/p/3140958.html>\n\nK - Currency Exchange\n来源：POJ – 1860\n知识点：Bellman-Ford算法等\n<http://www.cnblogs.com/kuangbin/archive/2012/08/17/2644807.html>\n\nL - Wormholes\n来源：POJ - 3259\n知识点：SPFA等\n<http://blog.csdn.net/murmured/article/details/18669909>\n\nM - Highways\n来源：POJ – 2485\n知识点：最小生成树等\n<http://blog.csdn.net/mikasa3/article/details/51559191>\n<http://blog.csdn.net/fanesemyk/article/details/51137466?locationNum=1&fps=1>\n\nN - Design Tutorial: Inverse the Problem\n来源：CodeForces - 472D\n知识点：最小生成树等\n<http://blog.csdn.net/u010660276/article/details/39901287>\n\nO - Qin Shi Huang's National Road System\n来源：HDU - 4081\n知识点：次小生成树等\n<http://blog.csdn.net/shuangde800/article/details/7982106>\n\n<h3 id=\"1.2.4\">7-24 代码强化训练4 《葵花宝典》P74-96</h3>\n\nA - Popular Cows\n来源：POJ – 2186\n知识点：Tarjan算法等\n<http://www.dontcry-tat.com/2017/04/26/poj-2186-popular-cows/>\n\nB - 迷宫城堡\n来源：HDU – 1269\n知识点：Kosaraju算法等\n<http://blog.csdn.net/qq7366020/article/details/12943345>\n\nC - Critical Links\n来源：UVA – 796\n知识点：无向图求桥等\n<http://www.cnblogs.com/chenchengxun/p/4718717.html>\n\nD - Electricity\n来源：POJ – 2117\n知识点：无向图求割点\n<http://blog.csdn.net/liwen_7/article/details/7919220>\n\nE - Redundant Paths\n来源：POJ – 3177\n知识点：无向图的双连通问题等\n<http://mojijs.com/2014/11/165169/index.html>\n\nF - Knights of the Round Table\n来源：POJ – 2942\n知识点：点的双连通分量等\n<http://www.cnblogs.com/wangfang20/p/3201502.html>\n\nG - Command Network\n来源：POJ – 3164\n知识点：最小树形图等\n<http://blog.csdn.net/shuangde800/article/details/8039359>\n\nH - The Perfect Stall\n来源：POJ – 1274\n知识点：二分图最大匹配：匈牙利算法\n<http://blog.csdn.net/u013487051/article/details/37656979>\n\nI - Asteroids\n来源：POJ – 3041\n知识点：二分图最大匹配：匈牙利算法\n<http://blog.csdn.net/yeruby/article/details/39315713>\n\nJ - COURSES\n来源：POJ – 1469\n知识点：二分图最大匹配：Hopcroft-Karp算法\n<http://blog.csdn.net/u011466175/article/details/23709885>\n\nK - Lightning\n来源：HDU – 4305\n知识点：生成树计数：Matrix-Tree定理\n<http://blog.csdn.net/julyana_lin/article/details/8067024>\n\nL - Highways\n来源：SPOJ – HIGH\n知识点：生成树计数\n<http://blog.csdn.net/gatevin/article/details/48051879>\n\nM - Alice's Chance\n来源：POJ – 1698\n知识点：二分图多重匹配\n<http://blog.csdn.net/l123012013048/article/details/47295503>\n\nN - 奔小康赚大钱\n来源：HDU – 2255\n知识点：二分图最大权匹配、KM算法等\n<http://blog.csdn.net/sr_19930829/article/details/40650359>\n\n<h3 id=\"1.2.5\">7-26 代码强化训练5 《葵花宝典》P96-121</h3>\n\nA - Dual Core CPU\n来源：POJ - 3469\n知识点：网络流：SAP算法等\n<http://blog.csdn.net/discreeter/article/details/51591775>\n\nB - Drainage Ditches\n来源：POJ - 1273\n知识点：网络流：ISAP算法等\n<http://blog.csdn.net/lianai911/article/details/44964361>\n\n\nC - Island Transport\n来源：HDU - 4280\n知识点：网络流：ISAP算法、Dinic等\n<http://blog.csdn.net/wubaizhe/article/details/74046372>\n\nD - Minimum Cost\n来源：POJ - 2516\n知识点：最小费用最大流等\n<http://blog.csdn.net/lyy289065406/article/details/6742534>\n<http://blog.csdn.net/u014552756/article/details/49977887>\n\nE - Peaceful Commission\n来源：HDU - 1814\n知识点：2-SAT等\n<http://m.blog.csdn.net/EzCUfST/article/details/47008027>\n\nF - Wedding\n来源：POJ - 3648\n知识点：2-SAT等\n<http://blog.csdn.net/sdj222555/article/details/7718821>\n\nG - Object Clustering\n来源：POJ - 3241\n知识点：莫队算法、曼哈顿最小生成树等\n<http://www.cnblogs.com/mfrbuaa/p/5375000.html>\n\n\nH - Work Scheduling\n来源：URAL - 1099\n知识点：一般图匹配带花树等\n<http://blog.csdn.net/u010660276/article/details/48013013>\n\nI - Nearest Common Ancestors\n来源：POJ - 1330\n知识点：LCA：dft+ST在线算法等\n<http://www.cnblogs.com/kuangbin/archive/2013/09/05/3302493.html>\n\nJ - Closest Common Ancestors\n来源：POJ - 1470\n知识点：LCA：离线Tarjan算法等\n<http://www.cnblogs.com/kuangbin/p/3302571.html>\n\nK - The merchant\n来源：POJ - 3728\n知识点：LCA：倍增法等\n<http://blog.csdn.net/lanshui_yang/article/details/11746513>\n\nL - Intersecting Lines\n来源：POJ - 1269\n知识点：判断线段相交等\n<http://blog.csdn.net/acdreamers/article/details/8811201>\n\nM - Segments\n来源：POJ - 3304\n知识点：直线和线段相交判断等\n<http://www.cnblogs.com/kuangbin/p/3188863.html>\n\nN - The Doors\n来源：POJ - 1556\n知识点：线段交+最短路等\n<http://www.cnblogs.com/kuangbin/p/3189309.html>\n\nO - Area\n来源：POJ – 1654\n知识点：求多边形面积等\n<http://www.cnblogs.com/lv-2012/archive/2012/12/01/2797264.html>\n\n<h3 id=\"1.2.6\">7-28 代码强化训练6 《葵花宝典》P121-152</h3>\n\nA - Card\n来源：HDU - 4350\n知识点：模拟等\n<http://blog.csdn.net/wconvey/article/details/7848235>\n\nB - A Round Peg in a Ground Hole\n来源：POJ - 1584\n知识点：判断凸多边形、判断点在多边形内、判断圆在多边形内等\n<http://www.cnblogs.com/liuxin13/p/4799667.html>\n\nC - Cupid's Arrow\n来源：HDU - 1756\n知识点：判断点在多边形内外等\n<http://blog.csdn.net/lttree/article/details/24301607>\n\nD - Shape of HDU\n来源：HDU - 2108\n知识点：判断凸多边形等\n<http://blog.csdn.net/lttree/article/details/24241987>\n\nE - Wall\n来源：HDU - 1348\n知识点：求凸包周长等\n<http://blog.csdn.net/W1413882708/article/details/52191385>\n\nF - Quoit Design\n来源：HDU - 1007\n知识点：查找平面最近点对等\n<http://blog.csdn.net/sun1956/article/details/8294048>\n\nG - Beauty Contest\n来源：POJ - 2187\n知识点：求解平面最远点对等\n<http://blog.csdn.net/crazy_ac/article/details/10082403>\n\nH - Triangle\n来源：ZOJ - 2419\n知识点：求解平面点集最大三角形等\n<http://blog.csdn.net/zxy_snow/article/details/6595123>\n\nI - The widest road\n来源：HDU - 2823\n知识点：求解两凸包最小距离等\n<http://blog.csdn.net/clover_hxy/article/details/54022026>\n\nJ - Art Gallery\n来源：ZOJ- 1369\n知识点：半平面交等\n<http://blog.csdn.net/l04205613/article/details/6626844>\n\nK - Kindergarten Electiond\n来源：ZOJ-3715\n知识点：枚举、贪心等\n<http://blog.csdn.net/zy691357966/article/details/44853449>\n\nL - Attack on Titans\n来源：ZOJ-3747\n知识点：递推等\n<http://blog.csdn.net/summer__show_/article/details/70243332>\n\nM - Alignment\n来源：HDU - 1950\n知识点：最长上升子序列等\n<http://www.cnblogs.com/blueprintf/p/5773393.html>\n<http://blog.csdn.net/wall_f/article/details/8295812>\n\nN - Game of Connections\n来源：HDU - 1134\n知识点：卡特兰数等\n<http://blog.csdn.net/u013509299/article/details/19758565>\n\nO - Group\n来源：HDU 4638\n知识点：莫队算法、离线线段树等\n<http://blog.csdn.net/xlzhang223/article/details/51439180>\n\nP - Count on a tree II\n来源：SPOJ - COT2\n知识点：树上的莫队算法、树上区间查询等\n<http://blog.csdn.net/htt_h/article/details/47729479>\n\n<h3 id=\"1.3.1\">7-30 Summer 2017 Team Training 1</h3>\n\nA-zoj 3878 Convert QWERTY to Dvorak 暴力\n<http://blog.csdn.net/loy_184548/article/details/50592408>\n\nB-codeforces 765E Tree Folding 拓扑排序\n<http://blog.csdn.net/hjt_fathomless/article/details/56013633>\n\nC-Gym 101063K Dire, Dire Docks 构造\n\nD-hdu 5875 Function 二分+rmq\n<http://blog.csdn.net/miracle_ma/article/details/52504922>\n\nE-poj 3244 Difference between Triplets 数学公式推导\n<http://blog.csdn.net/acdreamers/article/details/12236319>\n\nF-hdu 5724 Chess 博弈+sg函数\n<http://blog.csdn.net/Danliwoo/article/details/51968789>\n\nG-gym 101156L Super 2048 模拟\n\nH-hdu 6031Innumerable Ancestors 二分+lca\n<http://blog.csdn.net/oranges_c/article/details/71698555>\n\nI-hdu 1538 A Puzzle for Pirates 经典的海盗分金推理\n<http://blog.csdn.net/acm_cxlove/article/details/7853916>\n\nJ-hdu 5791 Two dp\n<http://blog.csdn.net/s_black/article/details/52102668>\n\n<h3 id=\"1.3.2\">7-31 Summer 2017 Team Training 2</h3>\n\nA.Coins 贪心\n<http://www.cnblogs.com/autsky-jadek/p/7226706.html?utm_source=itdadao&utm_medium=referral>\n\nB.Business Cycle 贪心、二分\n<http://www.cnblogs.com/shimu/p/5948176.html>\n\nC.Triangle Formation 水题\n<http://blog.csdn.net/code12hour/article/details/51990060>\n\nD.Powerful array 莫队算法\n<http://blog.csdn.net/zearot/article/details/50835130>\n\nE.Profact 暴搜、剪枝（STL）\n<http://blog.csdn.net/lmhacm/article/details/61416851>\n\nF.Kevin's Problem 组合数学\n<http://mcginn.lofter.com/post/1d50332c_7f59909>\n\nG.Sequence Value Dp\n<https://media.hihocoder.com/contests/challenge29/sol.pdf>\n<http://blog.csdn.net/werkeytom_ftd/article/details/73740771>\n\nH.Snakes capturing the Mongoose Cities 树形dp\n<https://discuss.codechef.com/questions/100120/captciti-editorial>\n\nI.Robot Racing\n<http://blog.csdn.net/KEYboarderQQ/article/details/57135492>\n\nJ.codechef SNGRAPH 简单图论\n<https://discuss.codechef.com/questions/99946/sngraph-editorial>\n\n<h3 id=\"1.3.3\">8-4 Summer 2017 Team Training 3</h3>\n\nA.OO's Sequence  约数枚举\n<http://blog.csdn.net/maxichu/article/details/47611819>\n\nB.LRU  概率+状态压缩DP\n<http://blog.csdn.net/clove_unique/article/details/62233833>\n\nC.Devu and Flowers  组合数学+容斥\n<http://hzwer.com/3810.html>\n\nD.Just a Hook  线段树区间更新\n<http://blog.csdn.net/libin56842/article/details/13511181>\n\nE.The Frog's Games  二分+贪心\n<http://blog.csdn.net/non_cease/article/details/6769814>\n\nF.A Simple Math Problem  矩阵快速幂\n<http://blog.csdn.net/efreet9539/article/details/24538071>\n\nG.翻纸牌游戏  DFS\n<http://blog.csdn.net/libin56842/article/details/14104989>\n\nH.Unlucky Strings  快速幂+KMP\n<http://blog.csdn.net/u014664226/article/details/49110349>\n\nI.Get Out!  计算几何\n<http://blog.csdn.net/diary_yang/article/details/13880547>\n\nJ.Cracking' RSA  高斯消元\n<http://blog.csdn.net/ok_again/article/details/13776037>\n\n<h3 id=\"1.3.4\">8-6 Summer 2017 Team Training 4</h3>\n\nA. LCM from 1 to n  节省空间的素数筛法\n<http://blog.csdn.net/whyorwhnt/article/details/9397289>\n\nB. Antiarithmetic? 枚举等差数列\n<http://blog.csdn.net/keshuai19940722/article/details/18803443>\n\nC. What a Ridiculous Election  bfs预处理\n<http://blog.csdn.net/keyboardmagician/article/details/53246315>\n\nD. Jogging Trails   欧拉回路+状压DP\n<http://blog.csdn.net/no__stop/article/details/16943929>\n\nE.  Pocky  凑数\n<http://www.oyohyee.com/post/HDU/5984.html>\n\nF.  Alice and Bob 博弈找规律\n<http://m.blog.csdn.net/xlzhang223/article/details/51755303>\n\nG. zxa and leaf   二分+dfs\n<http://blog.csdn.net/hjt_fathomless/article/details/51413061>\n\nH.  连接的管道\n<http://www.bubuko.com/infodetail-1044544.html>\n\nI.  Caocao's Bridges\n<http://blog.csdn.net/mengzhengnan/article/details/11856435>\n\nJ . Communication System\n<http://www.cnblogs.com/nicetomeetu/p/5152291.html>\n\n<h3 id=\"1.3.5\">8-7 Summer 2017 Team Training 5</h3>\n\nA题 hdu 5819 概率dp\n<http://blog.csdn.net/v5zsq/article/details/52372939>\n\nB题 poj2706 模拟+BFS\n<http://blog.csdn.net/lyy289065406/article/details/6648663>\n\nC题 poj 1085 博弈+极大极小搜索，剪枝\n<http://blog.csdn.net/acm_cxlove/article/details/7997246>\n\nD题 zoj 1919 欧拉路径的输出\n<http://blog.csdn.net/axuan_k/article/details/45844491>\n\nE题 hdu 3094 博弈sg函数\n<http://blog.csdn.net/Vmurder/article/details/42653129>\n\nF题 zoj 1101 二分\n<http://blog.csdn.net/forever_wjs/article/details/51493515>\n\nG题 poj 3904 容斥原理，莫比乌斯反演\n<http://blog.csdn.net/lianai911/article/details/47609075>\n\nH题 poj 1472 栈模拟\n<http://blog.csdn.net/lyy289065406/article/details/6648640>\n\n<h3 id=\"1.4.1\">8-2 Summer 2017 Individual Training 1</h3>\n\nA-hdu 2095 find your present(2) 异或\n<http://blog.csdn.net/dgq8211/article/details/7455722>\n\nB-hdu 4869 Turn the pokers 组合数\n<http://blog.csdn.net/dyx404514/article/details/38239155>\n\nC-hdu 5592 ZYB's Premutation 线段树或树状数组\n<http://blog.csdn.net/lljjccsskk/article/details/50215631>\n\nD-hdu 5636 Shortest Path Floyd+暴力\n<http://blog.csdn.net/liuke19950717/article/details/50923293>\n\nE-hdu 3038 How Many Answers Are Wrong 并查集\n<http://blog.csdn.net/backforward/article/details/51889011>\n\nF-poj 3318 Matrix Multiplication 随机化\n<http://blog.csdn.net/sr_19930829/article/details/38236769>\n\nG-Codeforces 739B Alyona and a tree dfs + 二分\n<http://blog.csdn.net/harlow_cheng/article/details/53687480>\n\nH-csu 1473 递增子序列 离散化+树状数组\n\nI-hdu 5742 It's All In The Mind 贪心\n<http://blog.csdn.net/helloiamclh/article/details/52002580>\n\nJ-UVA 11210 Chinese Mahjong 暴力搜索\n<http://blog.csdn.net/keshuai19940722/article/details/10034505>\n\n<h3 id=\"1.4.2\">8-9 Summer 2017 Individual Training 2</h3>\n\nA - 渐变字符串 UESTC - 1510 贪心水题\n<http://blog.csdn.net/wyk1823376647/article/details/66478566>\n\nB - PolandBall and Game CodeForces - 755B 博弈水题\n<http://www.cnblogs.com/tyty-Somnuspoppy/p/6294030.html>\n\nC - Rikka with Tree HihoCoder - 1453 动态规划\n<http://blog.csdn.net/qq_28954601/article/details/53872423>\n\nD - 神秘组织的的分数 UESTC - 1707 数学爆搜\n<http://blog.csdn.net/Tribleave/article/details/77070964>\n\nE - Fast Multiplication HihoCoder - 1527 贪心或动态规划\n<http://blog.csdn.net/f_zyj/article/details/73754452>\n\nF - 完美数 51Nod - 1232 数论 数位dp\n<http://blog.csdn.net/u010885899/article/details/51264468>\n\nG - Non-Decreasing Sequence HihoCoder - 1529 优先队列和函数构造\n<https://media.hihocoder.com/contests/challenge29/sol.pdf>\n<http://blog.csdn.net/u014609452/article/details/73740861>\n\nH - 找朋友 51Nod - 1463 线段树\n<http://blog.csdn.net/u010885899/article/details/50211737>\n<http://blog.csdn.net/doyouseeman/article/details/53815828>\n\nI - Word Puzzles  POJ - 1204 字典树 AC自动机\n<http://blog.csdn.net/u013588639/article/details/38406283>\n<http://blog.csdn.net/dan__ge/article/details/51427825>\n\n<h3 id=\"1.5.1\">8-21 Summer 2017 Team Professional Contest 1</h3>\n\n题目来源：\nJAG Practice Contest for ACM-ICPC Asia Regional 2016\n<http://jag2016autumn.contest.atcoder.jp/assignments>\n题解参考：\n<https://post.icpc-camp.org/d/581-jag-practice-contest-for-acm-icpc-asia-regional-2016-hints>\n\n<h3 id=\"1.5.2\">8-23 Summer 2017 Team Professional Contest 2</h3>\n\n题目来源：\n2015 ACM-ICPC Asia EC-Final Contest\n<http://acmicpc.info/wp-content/uploads/2015/12/ecfinal_problems.pdf>\n题解参考：\n<http://www.cnblogs.com/clrs97/p/6136032.html>\n\n<h3 id=\"1.5.3\">8-25 Summer 2017 Team Professional Contest 3</h3>\n\n题目来源：KTU camp DAY1\n题解：Analysis.pptx\n","tags":["algorithm","record"]}]