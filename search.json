[{"title":"一起来画画叭~","url":"/2020/01/05/draw_a_picture/","content":"\n# 缘起\n起因是我在一个函数里面开了一个 socket，大概像。。这样~\n```c++\nint fun(){\n    int s = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);\n    /* ... */\n    if (/* ...*/){\n        close(s);\n        return -1;\n    }\n    if(/* ... */){\n        close(s);\n        return xx;\n    }\n}\n```\n显而易见的一个问题就是必须在每个 return 之前都要手写一个 close(s)，不然调用多次之后就会产生句柄泄露(当我发现这个问题的时候，`lsof -p my_pid` 已经有一千多条啦~)，这样写其实是比较麻烦的，于是 leader 建议可以利用 shared_ptr 的特性——离开作用域的时候释放，来化简代码。处理之后就变成这样~\n```c++\nint fun(){\n    int s = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);\n    std::shared_ptr<int> p(&s,[](int *s){\n        close(*s);\n    });\n    /* ... */\n    if (/* ...*/){\n        return -1;\n    }\n    if(/* ... */){\n        return xx;\n    }\n}\n```\n下面是这个技巧的简单模型：\n```c++\n#include <iostream>\n#include <memory>\n\nint test(){\n    int hh =10;\n    {\n        std::shared_ptr<int> p(&hh,[](int *hh){\n            *hh = 15;\n            std::cout<<*hh<<std::endl;\n        });\n    }\n    std::cout<<\"jiujiu\"<<hh<<std::endl;\n    return hh;\n}\nint main(){\n    std::cout<<\"miaomiao\"<<test()<<std::endl;\n    std::cout<<\"wangwang\"<<std::endl;\n}\n```\n按我的理解输出应该是这样：\n```output\n15\njiujiu15\nmiaomiao15\nwangwang\n```\n但实际上输出是这样~\n```output\nmiaomiao15\njiujiu15\n15\nwangwang\n```\n刺激，让我们来看看汇编代码叭~\n```armasm\nDump of assembler code for function main():\n   0x00401531 <+0>:\tlea    0x4(%esp),%ecx\n   0x00401535 <+4>:\tand    $0xfffffff0,%esp\n   0x00401538 <+7>:\tpushl  -0x4(%ecx)\n   0x0040153b <+10>:\tpush   %ebp\n   0x0040153c <+11>:\tmov    %esp,%ebp\n   0x0040153e <+13>:\tpush   %ebx\n   0x0040153f <+14>:\tpush   %ecx\n   0x00401540 <+15>:\tsub    $0x10,%esp\n   0x00401543 <+18>:\tcall   0x402180 <__main>\n=> 0x00401548 <+23>:\tmovl   $0x406071,0x4(%esp)\n   0x00401550 <+31>:\tmovl   $0x6ff03a20,(%esp)\n   0x00401557 <+38>:\tcall   0x401c24 <std::basic_ostream<char, std::char_traits<char> >& std::operator<< <std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, char const*)>\n   0x0040155c <+43>:\tmov    %eax,%ebx\n   0x0040155e <+45>:\tcall   0x4014c7 <test()>\n   0x00401563 <+50>:\tmov    %eax,(%esp)\n   0x00401566 <+53>:\tmov    %ebx,%ecx\n   0x00401568 <+55>:\tcall   0x401c4c <std::ostream::operator<<(int)>\n   0x0040156d <+60>:\tsub    $0x4,%esp\n   0x00401570 <+63>:\tmovl   $0x401c2c,(%esp)\n   0x00401577 <+70>:\tmov    %eax,%ecx\n   0x00401579 <+72>:\tcall   0x401c54 <std::ostream::operator<<(std::ostream& (*)(std::ostream&))>\n   0x0040157e <+77>:\tsub    $0x4,%esp\n   0x00401581 <+80>:\tmovl   $0x40607a,0x4(%esp)\n   0x00401589 <+88>:\tmovl   $0x6ff03a20,(%esp)\n   0x00401590 <+95>:\tcall   0x401c24 <std::basic_ostream<char, std::char_traits<char> >& std::operator<< <std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, char const*)>\n   0x00401595 <+100>:\tmovl   $0x401c2c,(%esp)\n   0x0040159c <+107>:\tmov    %eax,%ecx\n   0x0040159e <+109>:\tcall   0x401c54 <std::ostream::operator<<(std::ostream& (*)(std::ostream&))>\n   0x004015a3 <+114>:\tsub    $0x4,%esp\n   0x004015a6 <+117>:\tmov    $0x0,%eax\n   0x004015ab <+122>:\tlea    -0x8(%ebp),%esp\n   0x004015ae <+125>:\tpop    %ecx\n   0x004015af <+126>:\tpop    %ebx\n   0x004015b0 <+127>:\tpop    %ebp\n   0x004015b1 <+128>:\tlea    -0x4(%ecx),%esp\n   0x004015b4 <+131>:\tret    \nEnd of assembler dump.\n\nDump of assembler code for function test():\n   0x004014c7 <+0>:\tpush   %ebp\n   0x004014c8 <+1>:\tmov    %esp,%ebp\n   0x004014ca <+3>:\tsub    $0x28,%esp\n   0x004014cd <+6>:\tmovl   $0xa,-0x10(%ebp)\n   0x004014d4 <+13>:\tlea    -0x18(%ebp),%eax\n   0x004014d7 <+16>:\tmov    %dl,0x4(%esp)\n   0x004014db <+20>:\tlea    -0x10(%ebp),%edx\n   0x004014de <+23>:\tmov    %edx,(%esp)\n   0x004014e1 <+26>:\tmov    %eax,%ecx\n   0x004014e3 <+28>:\tcall   0x4015b6 <std::shared_ptr<int>::shared_ptr<int, test()::<lambda(int*)> >(int *, <lambda(int*)>)>\n   0x004014e8 <+33>:\tsub    $0x8,%esp\n   0x004014eb <+36>:\tlea    -0x18(%ebp),%eax\n   0x004014ee <+39>:\tmov    %eax,%ecx\n   0x004014f0 <+41>:\tcall   0x4043c8 <std::shared_ptr<int>::~shared_ptr()>\n   0x004014f5 <+46>:\tmovl   $0x40606a,0x4(%esp)\n   0x004014fd <+54>:\tmovl   $0x6ff03a20,(%esp)\n   0x00401504 <+61>:\tcall   0x401c24 <std::basic_ostream<char, std::char_traits<char> >& std::operator<< <std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, char const*)>\n   0x00401509 <+66>:\tmov    %eax,%edx\n   0x0040150b <+68>:\tmov    -0x10(%ebp),%eax\n   0x0040150e <+71>:\tmov    %eax,(%esp)\n   0x00401511 <+74>:\tmov    %edx,%ecx\n   0x00401513 <+76>:\tcall   0x401c4c <std::ostream::operator<<(int)>\n   0x00401518 <+81>:\tsub    $0x4,%esp\n   0x0040151b <+84>:\tmovl   $0x401c2c,(%esp)\n   0x00401522 <+91>:\tmov    %eax,%ecx\n   0x00401524 <+93>:\tcall   0x401c54 <std::ostream::operator<<(std::ostream& (*)(std::ostream&))>\n   0x00401529 <+98>:\tsub    $0x4,%esp\n   0x0040152c <+101>:\tmov    -0x10(%ebp),%eax\n   0x0040152f <+104>:\tleave  \n   0x00401530 <+105>:\tret    \nEnd of assembler dump.\n```\n\n```\nsourece code:\n  std::cout<<\"miaomiao\"<<test()<<std::endl;\nasm:\n   0x00401531 <+0>:\tlea    0x4(%esp),%ecx\n   0x00401535 <+4>:\tand    $0xfffffff0,%esp\n   0x00401538 <+7>:\tpushl  -0x4(%ecx)\n   0x0040153b <+10>:\tpush   %ebp\n   0x0040153c <+11>:\tmov    %esp,%ebp\n   0x0040153e <+13>:\tpush   %ebx\n   0x0040153f <+14>:\tpush   %ecx\n   0x00401540 <+15>:\tsub    $0x10,%esp\n   0x00401543 <+18>:\tcall   0x402180 <__main>\n=> 0x00401548 <+23>:\tmovl   $0x406071,0x4(%esp)\n\ngdb:s\nsource code:\n  int hh =10;\nasm:\n   0x004014c7 <+0>:\tpush   %ebp\n   0x004014c8 <+1>:\tmov    %esp,%ebp\n   0x004014ca <+3>:\tsub    $0x28,%esp\n=> 0x004014cd <+6>:\tmovl   $0xa,-0x10(%ebp)\n\n可以看到 int hh = 10; 正好对应的就是 movl   $0xa,-0x10(%ebp)\n\n此时看一下栈的状态:(大地址是栈底，小地址是栈顶哈)\n0x29fee0:\t0x70\t0x7d\t0x79\t0x66\t0x00\t0xe0\t0xfd\t0x7f\n0x29fee8:\t0x08\t0xff\t0x29\t0x00\t0xa9\t0x49\t0xef\t0x6f\n0x29fef0:\t0x20\t0x3a\t0xf0\t0x6f\t0x71\t0x60\t0x40\t0x00\n0x29fef8:\t0x08\t0x00\t0x00\t0x00\t0xcc\t0xff\t0x29\t0x00\n0x29ff00:\t0xd0\t0xd1\t0xf0\t0x76\t0x44\t0x0a\t0xa5\t0x10\n可以看到很熟悉的两个地址 0x20\t0x3a\t0xf0\t0x6f(对应 0x00401550 指令)，0x71\t0x60\t0x40\t0x00(对应 0x00401548 指令),顺便一提，0x406071里是猫猫哦~\n(gdb) x/16cb 0x406071\n0x406071 <std::ignore+8>:\t109 'm'\t105 'i'\t97 'a'\t111 'o'\t109 'm'\t105 'i'\t97 'a'\t111 'o'\n0x406079 <std::ignore+16>:\t0 '\\000'\t119 'w'\t97 'a'\t110 'n'\t103 'g'\t119 'w'\t97 'a'\t110 'n'\n\n后面 shared_ptr 就不咋能看懂了，直接跳到\nsource code:\n    std::cout<<\"jiujiu\"<<hh<<std::endl;\nasm:\n=> 0x004014f5 <+46>:\tmovl   $0x40606a,0x4(%esp)\n   0x004014fd <+54>:\tmovl   $0x6ff03a20,(%esp)\n\n   跟上面一样，0x40606a 里面是 jiujiu,顺便怀疑一下，0x6ff03a20是栈的边界保护符！\n   \n   然后比较诡异的事情就出现了，此时，控制台输出了 miaomiao15。。。\n\n   然后到\n  source code:\n       return hh;\n  sam:\n  => 0x0040152c <+101>:\tmov    -0x10(%ebp),%eax\n  这个时候控制台输出了 jiujiu15，可以理解哈\n\n  继续：\n  source code:\n  }\n  sam:\n  => 0x0040152f <+104>:\tleave  \n  继续：\n  source code:\n      std::cout<<\"wangwang\"<<std::endl;\n  asm:\n  => 0x00401581 <+80>:\tmovl   $0x40607a,0x4(%esp)\n  这个时候控制台输出了：15\n\n```\nok，总结一下目前发现的不合理的点：\n1、` *hh = 15; std::cout<<*hh<<std::endl;`这两句没有一起执行，而且在离开 shared_ptr 作用域的时候，第一句是肯定执行了的。\n2、test 没有 返回之前，miaomiao15 就已经输出了。\n\n这一切诡异的背后，都指向了一个关键词\"缓冲区\"，于是我把所有的 cout 换成了 printf，再次运行，快乐的事情发生了\n```output\n15\njiujiu15\nmiaomiao15\nwangwang\n```\n或者像这个样子，结果也是一样哈\n```c++\n#include <iostream>\n#include <stdio.h>\n#include <memory>\n\nint test(){\n    int hh =10;\n    {\n        std::shared_ptr<int> p(&hh,[](int *hh){\n            *hh = 15;\n            std::cout<<*hh<<std::endl;\n            //printf(\"%d\\n\",*hh);\n        });\n    }\n    std::cout<<\"jiujiu\"<<hh<<std::endl;\n    //printf(\"jiujiu%d\\n\",hh);\n    return hh;\n}\nint main(){\n    int xixi = test();\n    std::cout<<\"miaomiao\"<<xixi<<std::endl;\n    //printf(\"miaomiao%d\\n\",test());\n    std::cout<<\"wangwang\"<<std::endl;\n}\n```\n\n# 画图\n>If I can，I wish to see the stream of every bit.  所以透明什么的最讨厌了。。\n\n恰完饭再画图叭~！(或许是明年了。。)","tags":["c++"]},{"title":"关于析构的无聊小实验","url":"/2020/01/01/virtual/","content":"\n# 喵？\n## delete 干了啥~\n```c++\nint main(){\n    int *hh = new int(5);\n    delete hh;\n}\n```\n```gdb\n(gdb) p hh # int *hh = new int(5); 未执行\n$1 = (int *) 0x400080\n(gdb) p &hh\n$2 = (int **) 0x29ff2c\n(gdb) p *hh\n$3 = 17744\n(gdb) n \n87\t    delete hh; \n(gdb) p hh # int *hh = new int(5); 执行了\n$4 = (int *) 0xdf11a8\n(gdb) p *hh\n$5 = 5\n(gdb) p &hh\n$6 = (int **) 0x29ff2c\n(gdb) n\n88\t}\n(gdb) p hh  # delete hh; 执行了\n$7 = (int *) 0xdf11a8\n(gdb) p &hh\n$8 = (int **) 0x29ff2c\n(gdb) p *hh\n$9 = 14618544\n```\n\n分析(瞎): hh 的地址在 hh 没定义之前就存在了，因为是用clion直接加断点然后开debug，所以看这个现象会比较奇怪，但其实如果自己编译的话，应该是知道要先编一个debug版本，在用gdb调试，所以在用gdb的时候，该有的符号就已经存在了。\n可见下面的小程序哈\n```c++\nint miao(){\n    int miaoo = 10;\n}\n\nint main(){\n    int *hh = new int(5);\n    delete hh;\n    int xixi = 10;\n}\n```\n在入口时，gdb显示如下\n```gdb\n(gdb) p miaoo\nNo symbol \"miaoo\" in current context.\n(gdb) p miao\n$1 = {int (void)} 0x401410 <miao()>\n(gdb) p xixi\n$2 = 2147344384\n(gdb) p wangwang\nNo symbol \"wangwang\" in current context.\n```\n第二个现象：delete之后，hh的地址不变，hh的值(存储的地址)不变，但hh存的那块地址的值变了？？一开始我还挺奇怪的，因为如果我是一个计算机，对delete最理想的处理方式应该是，一旦hh被delete了，那么后面再有用到hh的地方就是异常的，也就是hh这个symbol就应该彻底被消灭。但仔细想想话，这有点“强机所难”了，因为对计算机来说，是不存在hh这个东西的，他只是按照指令来将数据在内存，寄存器和IO中进行传输。那么我刚刚的构想可以理解为，一旦hh被delete，那么再用到 0xdf11a8 这块地址就是异常的，那。。这不是系统性的内存泄漏嘛(笑)。这样一想，我倒是能理解为什么delete选择对 0xdf11a8 这块内存的数据动手了，而且也不能不动手，因为delete就是希望不再让人获得原数据；而且也不能全部刷新为 0，出了问题比较难debug吧。\n真是难为编译器的用心良苦了喵~！\n\n## 继续探索\n测试代码就是酱紫啦，主要的目的是探索如果基类的析构函数不是virtual的，就不会调用子类的析构函数，那么怎么能再次使用子类的成员嘞？(感觉自己离黑客又近了一步呐)\n```c++\n#include <string>\n#include <iostream>\n\nclass BaseClass\n{\npublic:\n    BaseClass()\n            : m_pValue(NULL)\n    {\n    }\n\n   /*virtual*/ ~BaseClass()\n   // virtual ~BaseClass()\n    {\n        delete m_pValue;\n        m_pValue = NULL;\n        std::cout << \"BaseClass virtual construct.\" << std::endl;\n    }\n\n    void SetValue(int v)\n    {\n        if (!m_pValue)\n        {\n            m_pValue = new int(v);\n        }\n        else\n        {\n            *m_pValue = v;\n        }\n    }\n\nprivate:\n    int* m_pValue;\n};\n\nclass SubClass : public BaseClass\n{\npublic:\n    SubClass()\n            : BaseClass()\n            , m_pstrName(NULL)\n    {\n    }\n\n    /*virtual*/ ~SubClass()\n    {\n        delete m_pstrName;\n        m_pstrName = NULL;\n        std::cout << \"SubClass virtual construct.\" << std::endl;\n    }\n\n    void SetName(const std::string& name)\n    {\n        if (!m_pstrName)\n        {\n            m_pstrName = new std::string(name);\n        }\n        else\n        {\n            *m_pstrName = std::string(name);\n        }\n    }\n    const std::string *get_string(){\n        return m_pstrName;\n    }\n\nprivate:\n    std::string* m_pstrName;\n};\n\n\nint main()\n{\n    BaseClass* pObj = new SubClass();\n    pObj->SetValue(10);\n    ((SubClass*)pObj)->SetName(\"zhangsan\");\n    std::cout<<*(((SubClass*)pObj)->get_string())<<std::endl;\n    delete pObj;\n    std::cout<<*(((SubClass*)pObj)->get_string())<<std::endl;\n    pObj = NULL;\n    return 0;\n}\n```\n\n基类的析构函数不是virtual的情况\n```gdb\n(gdb) p pObj # 没有 delete 之前\n$1 = (BaseClass *) 0xd311a8\n(gdb) p pObj->m_pstrName\nThere is no member or method named m_pstrName.\n(gdb) p ((SubClass*)pObj)->m_pstrName\n$2 = 0xd311e8\n(gdb) p *(((SubClass*)pObj)->m_pstrName)\n$3 = \"zhangsan\"\n(gdb) x/64cb 0xd311e8 # 按单字节，字符形式打印64个单位\n0xd311e8:\t-16 '\\360'\t17 '\\021'\t-45 '\\323'\t0 '\\000'\t8 '\\b'\t0 '\\000'\t0 '\\000'\t0 '\\000'\n0xd311f0:\t122 'z'\t104 'h'\t97 'a'\t110 'n'\t103 'g'\t115 's'\t97 'a'\t110 'n'\n0xd311f8:\t0 '\\000'\t-16 '\\360'\t-83 '\\255'\t-70 '\\272'\t13 '\\r'\t-16 '\\360'\t-83 '\\255'\t-70 '\\272'\n0xd31200:\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\n0xd31208:\t0 '\\000'\t0 '\\000'\t0 '\\000'\t0 '\\000'\t0 '\\000'\t0 '\\000'\t0 '\\000'\t0 '\\000'\n0xd31210:\t-19 '\\355'\t-103 '\\231'\t-110 '\\222'\t80 'P'\t-42 '\\326'\t-91 '\\245'\t0 '\\000'\t0 '\\000'\n0xd31218:\t40 '('\t127 '\\177'\t-45 '\\323'\t0 '\\000'\t-40 '\\330'\t18 '\\022'\t-45 '\\323'\t0 '\\000'\n0xd31220:\t-18 '\\356'\t-2 '\\376'\t-18 '\\356'\t-2 '\\376'\t-18 '\\356'\t-2 '\\376'\t-18 '\\356'\t-2 '\\376'\n(gdb) p pObj->m_pValue\n$4 = (int *) 0xd311c8\n(gdb) p *(pObj->m_pValue)\n$5 = 10\n(gdb) x/64dw 0xd311c8 # 按4字节，十进制的形式打印64个单位\n0xd311c8:\t10\t-1414812757\t-1414812757\t-17891602\n0xd311d8:\t0\t0\t1100061183\t402695636\n0xd311e8:\t13832688\t8\t1851877498\t1851880295\n0xd311f8:\t-1163005952\t-1163005939\t-1414812757\t-1414812757\n0xd31208:\t0\t0\t1351784941\t42454\n0xd31218:\t13860648\t13832920\t-17891602\t-17891602\n0xd31228:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd31238:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd31248:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd31258:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd31268:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd31278:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd31288:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd31298:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd312a8:\t-17891602\t-17891602\t1133615613\t436250052\n0xd312b8:\t2\t-1414856637\t-1414812757\t-17912917\n(gdb) n\n79\t    std::cout<<*(((SubClass*)pObj)->get_string())<<std::endl;\n(gdb) p pObj # delete 之后\n$6 = (BaseClass *) 0xd311a8\n(gdb) p pObj->m_pstrName\nThere is no member or method named m_pstrName.\n(gdb) p ((SubClass*)pObj)->m_pstrName\n$7 = 0xd312d8\n(gdb) p *(((SubClass*)pObj)->m_pstrName)\n$8 = \"\\030\\022\\323\\000\\330\\022\\323\\000\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\377\\231\\221A\\330\\245\\000\\030\\360\\021\\323\\000\\b\\000\\000\\000zhangsan\\000\\360\\255\\272\\r\\360\\255\\272\\253\\253\\253\\253\\253\\253\\253\\253\\000\\000\\000\\000\\000\\000\\000\\000\\355\\231\\222P\\326\\245\\000\\000(\\177\\323\\000\\250\\021\\323\\000\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\356\\376\\375\\231\\221C\\304\\245\\000\\032\\002\\000\\000\\000C\\000\\253\\253\\253\\253\\253\\253\\253\\253\\356\\376\\000\\000\\000\\000\\000\\000\\000\\000\\372\\231\\222G\\324\\245\\000\\000\\250\\021\\323\\000\\300\\000\\323\\000\\356\\376\\356\\376\\356\\376\\356\\376\\276\\231\\221\\000\\323\\245\\000\\030\\002\\000\\000\\000\\250\\003\\000\\000\\001\\000\\000\\000\\004\\b\\000\\000\\301\\243\\332\\243 \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\b\\030\\030\\030\\030\\030\\030\\030\\030\\030\\030\\030\\030\\030\\030\\030\\030\\030\\030\\030\\030\\030\\030\\030\\030\\030\\030\\b\\b\\b\\b\\b\\b((((((((((((((((((((((((((\\b\\b\\b\\b\\b\\b\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\f\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000abcdefghijklmnopqrstuvwxyz\\000\\000\\000\\000\\000\\000ABCDEFGHIJKLMNOPQRSTUVWXYZ\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\253\\253\\253\\253\\253\\253\\253\\253\\000\\000\\000\\000\\000\\000\\000\\000\\035\\231\\221\\243\\227\\245\\000\\035\\330\\025\\323\\000\\367\\025\\323\\000 \\026\\323\\000=\\026\\323\\000H\\026\\323\\000\\204\\026\\323\\000\\273\\026\\323\\000\\354\\026\\323\\000\\t\\027\\323\\000-\\027\\323\\000^\\027\\323\\000\\206\\027\\323\\000\\223\\027\\323\\000\\253\\027\\323\\000\\330\\027\\323\\000\\341\\027\\323\\000\\r\\030\\323\\000+\\030\\323\\000B\\030\\323\\000e\\030\\323\\000s\\030\\323\\000V\\031\\323\\000\\224\\031\\323\\000\\257\\031\\323\\000\\314\\031\\323\\000\\024\\032\\323\\000\"...\n(gdb) x/64cb 0xd311e8\n0xd311e8:\t-16 '\\360'\t17 '\\021'\t-45 '\\323'\t0 '\\000'\t8 '\\b'\t0 '\\000'\t0 '\\000'\t0 '\\000'\n0xd311f0:\t122 'z'\t104 'h'\t97 'a'\t110 'n'\t103 'g'\t115 's'\t97 'a'\t110 'n'\n0xd311f8:\t0 '\\000'\t-16 '\\360'\t-83 '\\255'\t-70 '\\272'\t13 '\\r'\t-16 '\\360'\t-83 '\\255'\t-70 '\\272'\n0xd31200:\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\n0xd31208:\t0 '\\000'\t0 '\\000'\t0 '\\000'\t0 '\\000'\t0 '\\000'\t0 '\\000'\t0 '\\000'\t0 '\\000'\n0xd31210:\t-19 '\\355'\t-103 '\\231'\t-110 '\\222'\t80 'P'\t-42 '\\326'\t-91 '\\245'\t0 '\\000'\t0 '\\000'\n0xd31218:\t40 '('\t127 '\\177'\t-45 '\\323'\t0 '\\000'\t-88 '\\250'\t17 '\\021'\t-45 '\\323'\t0 '\\000'\n0xd31220:\t-18 '\\356'\t-2 '\\376'\t-18 '\\356'\t-2 '\\376'\t-18 '\\356'\t-2 '\\376'\t-18 '\\356'\t-2 '\\376'\n(gdb) p pObj->m_pValue\n$9 = (int *) 0xd31218\n(gdb) p *(pObj->m_pValue)\n$10 = 13860648\n(gdb) x/64dw 0xd311c8\n0xd311c8:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd311d8:\t-17891602\t-17891602\t1100061183\t402695640\n0xd311e8:\t13832688\t8\t1851877498\t1851880295\n0xd311f8:\t-1163005952\t-1163005939\t-1414812757\t-1414812757\n0xd31208:\t0\t0\t1351784941\t42454\n0xd31218:\t13860648\t13832616\t-17891602\t-17891602\n0xd31228:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd31238:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd31248:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd31258:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd31268:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd31278:\t-17891602\t-17891602\t-17891602\t-17891602\n```\n\n可以看到，如果基类的析构函数不是virtual，那么在多态的时候就不会调用子类的析构函数，所以0xd311f0这块内存是没有被刷新的，理论上来说，p *(((SubClass*)pObj)->m_pstrName) 依然能够得到“zhangsan”才对，但是可以看到p出来的是却是0xd311e8的前面的很长一段内存到很大的内存地址。(挠头)\n```gdb\n0xd311e0:\t-1 '\\377'\t-103 '\\231'\t-111 '\\221'\t65 'A'\t-40 '\\330'\t-91 '\\245'\t0 '\\000'\t24 '\\030'\n0xd311e8:\t-16 '\\360'\t17 '\\021'\t-45 '\\323'\t0 '\\000'\t8 '\\b'\t0 '\\000'\t0 '\\000'\t0 '\\000' # 对应 p *(((SubClass*)pObj)->m_pstrName) 结果的“zhangsan”前面那一段数据\n0xd311f0:\t122 'z'\t104 'h'\t97 'a'\t110 'n'\t103 'g'\t115 's'\t97 'a'\t110 'n'\n```\n嘛。。估计就是一种保护机制吧，目前为止情况还在控制之中(起码还能自己骗过自己。。。)\n\n基类的析构函数加上 virtual 的情况：\n```gdb\n(gdb)  p pObj\n$4 = (SubClass *) 0xd611a8\n(gdb) p pObj->m_pstrName\n$5 = 0xd611f0\n(gdb) p ((SubClass*)pObj)->m_pstrName\n$6 = 0xd611f0\n(gdb) p *(pObj->m_pstrName)\n$7 = \"zhangsan\"\n(gdb) p *(((SubClass*)pObj)->m_pstrName)\n$8 = \"zhangsan\"\n(gdb) x/64cb 0xd611f0\n0xd611f0:\t-8 '\\370'\t17 '\\021'\t-42 '\\326'\t0 '\\000'\t8 '\\b'\t0 '\\000'\t0 '\\000'\t0 '\\000'\n0xd611f8:\t122 'z'\t104 'h'\t97 'a'\t110 'n'\t103 'g'\t115 's'\t97 'a'\t110 'n'\n0xd61200:\t0 '\\000'\t-16 '\\360'\t-83 '\\255'\t-70 '\\272'\t13 '\\r'\t-16 '\\360'\t-83 '\\255'\t-70 '\\272'\n0xd61208:\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\t-85 '\\253'\n0xd61210:\t0 '\\000'\t0 '\\000'\t0 '\\000'\t0 '\\000'\t0 '\\000'\t0 '\\000'\t0 '\\000'\t0 '\\000'\n0xd61218:\t-43 '\\325'\t21 '\\025'\t23 '\\027'\t-5 '\\373'\t-62 '\\302'\t-54 '\\312'\t0 '\\000'\t0 '\\000'\n0xd61220:\t40 '('\t127 '\\177'\t-42 '\\326'\t0 '\\000'\t-40 '\\330'\t18 '\\022'\t-42 '\\326'\t0 '\\000'\n0xd61228:\t-18 '\\356'\t-2 '\\376'\t-18 '\\356'\t-2 '\\376'\t-18 '\\356'\t-2 '\\376'\t-18 '\\356'\t-2 '\\376'\n(gdb) p pObj->m_pValue\n$9 = (int *) 0xd611d0\n(gdb) p *(pObj->m_pValue)\n$10 = 10\n(gdb) x/64dw 0xd611d0\n0xd611d0:\t10\t-1414812757\t-1414812757\t-17891602\n0xd611e0:\t0\t0\t-317450816\t402705088\n0xd611f0:\t14029304\t8\t1851877498\t1851880295\n0xd61200:\t-1163005952\t-1163005939\t-1414812757\t-1414812757\n0xd61210:\t0\t0\t-82373163\t51906\n0xd61220:\t14057256\t14029528\t-17891602\t-17891602\n0xd61230:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd61240:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd61250:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd61260:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd61270:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd61280:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd61290:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd612a0:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd612b0:\t-283896382\t436259543\t2\t-1414856637\n0xd612c0:\t-1414812757\t-17912917\t0\t0\n(gdb) n\n79\t    std::cout<<*(((SubClass*)pObj)->get_string())<<std::endl;\n(gdb) p pObj\n$11 = (BaseClass *) 0xd611a8\n(gdb) p pObj->m_pstrName\nThere is no member or method named m_pstrName.\n(gdb) p ((SubClass*)pObj)->m_pstrName\n$12 = (std::__cxx11::string *) 0xfeeefeee\n(gdb) p *(((SubClass*)pObj)->m_pstrName)\nCannot access memory at address 0xfeeefeee\n(gdb) x/64cb 0xd311e8\n0xd311e8:\tCannot access memory at address 0xd311e8\n(gdb) x/64cb 0xfeeefeee\n0xfeeefeee:\tCannot access memory at address 0xfeeefeee\n(gdb) p pObj->m_pValue\n$13 = (int *) 0xd67f28\n(gdb) p *(pObj->m_pValue)\n$14 = 14029224\n(gdb) x/64dw 0xd611d0\n0xd611d0:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd611e0:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd611f0:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd61200:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd61210:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd61220:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd61230:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd61240:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd61250:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd61260:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd61270:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd61280:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd61290:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd612a0:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd612b0:\t-283896382\t436259558\t2\t-1414856637\n0xd612c0:\t-1414812757\t-17912917\t0\t0\n(gdb) x/64dw 0xd67f28\n0xd67f28:\t14029224\t14029528\t-17891602\t-17891602\n0xd67f38:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd67f48:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd67f58:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd67f68:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd67f78:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd67f88:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd67f98:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd67fa8:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd67fb8:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd67fc8:\t-17891602\t-17891602\t-17891602\t-17891602\n0xd67fd8:\t-17891602\t-17891602\t-384690750\t50383580\n0xd67fe8:\t14024844\t14024844\t14024760\t14024760\n0xd67ff8:\t14057472\t28672\tCannot access memory at address 0xd68000\n```\n\n加上虚函数之后，情况就有点不受控制了，首先是基类指针不用转成子类就可以直接引用子类成员变量；二是析构时基类子类的成员变量都指向了其他内存，在没有加入虚函数时只是刷新指向的那块内存的数据哦~地址本身是不变滴。更诡异的是，实验两次，析构后那个字符串的地址都是0xfeeefeee，int的地址却每次都不同。\n\n## 先睡了，有时间看看虚函数表是怎么实现的估计会有新发现\n\n## 遗留问题\n### 神秘偏移\n在没有虚函数的时候，delete 之后` p (((SubClass)pObj)->m_pstrName)` 的结果有一段很奇怪的偏移。。\n### 基类直接引用\n加上虚函数之后，基类指针不用转成子类就可以直接引用子类成员变量，delete 之后就不可以啦\n### 0xfeeefeee(已解决)\n长得奇怪，必有猫腻\n\n---\n\n>0xcccccccc : Used by Microsoft's C++ debugging runtime library to mark uninitialised stack memory\n> 0xcdcdcdcd : Used by Microsoft's C++ debugging runtime library to mark uninitialised heap memory\n>0xfeeefeee : Used by Microsoft's HeapFree() to mark freed heap memory\n>0xabababab : Used by Microsoft's HeapAlloc() to mark \"no man's land\" guard bytes after allocated heap memory\n>0xabadcafe : A startup to this value to initialize all free memory to catch errant pointers\n>0xbaadf00d : Used by Microsoft's LocalAlloc(LMEM_FIXED) to mark uninitialised allocated heap memory\n>0xbadcab1e : Error Code returned to the Microsoft eVC debugger when connection is severed to the debugger\n>0xbeefcace : Used by Microsoft .NET as a magic number in resource files\n>对于0xcccccccc和0xcdcdcdcd，在 Debug 模式下，VC 会把未初始化的栈内存上的指针全部填成 0xcccccccc ，当字符串看就是 “烫烫烫烫……”；会把未初始化的堆内存上的指针全部填成 0xcdcdcdcd，当字符串看就是 “屯屯屯屯……”。那么调试器为什么要这么做呢？VC的DEBUG版会把未初始化的指针自动初始化为0xcccccccc或0xcdcdcdcd，而不是就让取随机值，那是为了方便我们调试程序，如果野指针的初值不确定，那么每次调试同一个程序就可能出现不一样的结果，比如这次程序崩掉，下次却能正常运行，这样显然对我们解bug是非常不利的，所以自动初始化的目的是为了让我们一眼就能确定我们使用了未初始化的野指针了。\n>对于0xfeeefeee，是用来标记堆上已经释放掉的内存。注意，如果指针指向的内存被释放了，变量变量本身的地址如未做改动，还是之前指向的内存的地址。如果该指针是一个类的指针，并且类中包含有指针变量，则内存被释放后（对于C++类，通常是执行delete操作），类中的指针变量就会被赋值为0xfeeefeee。如果早调试代码过程中，发现有值为0xfeeefeee的指针，就说明对应的内存被释放掉了，我们的代码已经出问题了。\n\n\n\n### Cannot access memory at address\n当我以为可以用gdb p 出内存的全部地址数据的时候。。`Cannot access memory at address`真是狠狠打脸了呐，所以能访问的地址有什么条件咧？\n猜测：能p出来的都是存在物理内存中的，但 `0xd67ff8:\t14057472\t28672\tCannot access memory at address 0xd68000`有点说不过去啊。。","tags":["c++","experiment"]},{"title":"向死而生","url":"/2019/12/22/whole_life1/","content":"\n# 我的人生，这段时光，叫做：怀疑与奠基\n我怀疑，自己的方法论是否如此糟糕  \n  我怀疑，学不会的利益交换是愚蠢还是恩赐  \n  我怀疑，明天是否会变得更好  \n  更怀疑，改变的必要\n\n这个阶段，每一个节点上的选择都是在为未来奠基，而我，犹抱浮木，水中浮沉，我不敢拼尽全力，亦不舍就此放弃。\n\n如此优柔寡断的我，能否到达梦的彼岸？  \n\n我的人生，这段时光，躲在沉默的缸\n\n( 努力想韵脚就会显得很中二。。。 )","tags":["life"]},{"title":"《深入探索c++对象模型》1生万 小试验","url":"/2019/12/22/one_create_wan/","content":"\n# 引入\n在C中将一个一个元素的数组放在struct的末尾，可以令每个struct的对象拥有可变数组\n## code\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nstruct Test{\n    int xixi ;\n    char haha[1];\n};\n\nint main() {\n    const char *str = \"hhhhhhh\";\n    struct Test *test = (struct Test*)(malloc(sizeof(struct Test) + strlen(str) + 1));\n    test->xixi = 15;\n    strcpy(test->haha,str);\n    return 0;\n}\n```\n## gdb 分析\n```gdb\n(gdb) p &test\n$1 = (struct Test **) 0x29ff28 \n(gdb) p &test->xixi \n$2 = (int *) 0x9a1180 \n(gdb) x/32xb test\n0x9a1180:\t0x0f\t0x00\t0x00\t0x00\t0x68\t0x68\t0x68\t0x68 # 从 0f 可以看出是大端序\n0x9a1188:\t0x68\t0x68\t0x68\t0x00\t0x0d\t0xf0\t0xad\t0xba # 连续7个 0x68 对应的是 \"hhhhhhh\"\n0x9a1190:\t0xab\t0xab\t0xab\t0xab\t0xab\t0xab\t0xab\t0xab\n0x9a1198:\t0x00\t0x00\t0x00\t0x00\t0x00\t0x00\t0x00\t0x00\n(gdb) p test->haha[0]\n$4 = 104 'h'\n(gdb) p test->haha[3]\n$5 = 104 'h'\n```\n在代码中也可以使用 `printf(\"%c\",test->haha[0])` 来访问 ( 我记得应该有边界保护的呀？？？ )\n这个小技巧基本不能在 c++ 中使用，因为 class 中 可以保证相同 access section(public, private,protected) 的数据排列是按照声明顺序排列在内存中，但跨 access section 的数据却不一定是按声明顺序。\n\n```\n...\nprivate:\n /** date1 **/\npublic:\n /** date2 **/\n...\n```\n在内存中 date2 并不一定都排列在 date1 后面。再加上 virtual function ，使得这个方法的有效性更加不确定。(不用就行啦 嘻嘻) \n\n# 遗留问题\n## 一、c++ 到底干了啥？？\n`strcpy(&test->haha,str);` and `strcpy(test->haha,str);` 在 c99 中都可，但 c++14 只支持后者。同样，c++ 中 `strcpy(&(test->haha),str);` 也不行\n``` c++\nint main() {\n    const char *str = \"hhhhhhh\";\n    struct Test *test = (struct Test*)(malloc(sizeof(struct Test) + strlen(str) + 1));\n    test->xixi = 15;\n    strcpy(test->haha,str);\n    printf(\"%x\\n\",test->haha);\n    fflush(stdout); // 不强制刷新缓冲区的话，debug 看不到 console 输出\n    return 0;\n}\n```\n``` output\nprintf(\"%x\\n\",test->haha); -> 55121c\n\n(gdb) p &(test->haha)\n$1 = (char (*)[2]) 0x55121c\n```\n可以看到这俩都是 haha 的地址，但后者就是编译不过，所以 c++ 在兼容 c 的时候又干了啥呐？\n## 二、反黑技术哪家强。。\n之前有看到，为了防止黑客推理出内存中的数据，所以每次 main帧都不是从栈的最低部开始存的，这个很好验证，每次重新运行，`(gdb) p &test` 可以看到每次地址都不一样就对了。but ... 为什么我 p 出来每次都是一样的？？(含泪微笑)  \n猜测一：领会错了该反黑秘籍  \n猜测二：需要 release 模式，或者编译优化\n## 三、说好的边界保护呐\n\n","tags":["c++"]},{"title":"Letter from an Unknown Woman p2","url":"/2019/07/05/letter-2/","content":"\n>你一个漫不经心的眼神，\n>　　如大火席卷麦田，\n>　　我把所有收成抵挡给一场虚妄。\n>　　可是，即便是虚妄，我都极尽热爱，\n>　　因为，我爱你……从未停止……\n\n我点了第五只蜡烛，坐在桌前给你写这封信。如果我不将心内的感情倾泻出来，就无法忍受独自和我死去的孩子待在一起。如果不是向你——一个曾今并且仍是我最心爱的人，倾诉这些，那还能跟谁说呐？也许你不能理解我。我的心如此沉重，太阳穴在不住颤动，四肢在忍受疼痛。我想我一定发烧了，流行病在这个季度扩散，我可能已经受到了感染。相对于轻生，如果能用这种方式再见到我的孩子，我更不会感到愧疚。有时我的眼前会一片黑暗，或许我不能坚持到完成这封信；但是，我的爱人，我会用尽所有力气，在这一次，并且是唯一的一次向你对话，尽管你从来不知道我是谁。\n\n对你我只想说，我将告诉你以前从未说过的所有事。我想让你知道我整个人生，并且也是你从未知道的有关你的一生。你应该只会在我死后才有可能知道我的秘密，那个时候你不需要回答任何人的问题；那个时候你也该知道，现在受着四肢冷热交加的痛苦的我，是否正经历着人生最后的时光。如果我决定继续活着，我会撕碎这封信，保持着一如既往的沉默。如果有一天你将这封信拿在手上，就该知道这是一个已故女人寄来的信，来告诉你她的故事，一个从一开始到最后，只要是她清醒的时刻，就与你有关的故事。你不必对我的话感到恐惧，一个死去的女人什么都不需要，既不需要爱，也不需要同情，更不需要安慰。我只想请求你一件事，请你相信我所说的一切，在沉重痛苦驱动下说出的一切。相信我的话。除此之外，我别无所求。一个母亲，不会在她死去的孩子旁说谎。\n\n我将告诉你我整个的人生，在第一次见到你之前，我的人生并不算开始。在那之前，我能回忆起的只有灰暗和迷茫，记忆就像是一个落满灰尘，充斥黑暗和有很多布着蜘蛛网的人事的地窖——那是一个我毫不关心的地方。我 13 岁时，你走进了我的生活，当时我就住在你现在住的房子，也就是你现在拿着信，听着我生命最后一声叹息的地方。我们当时住在公寓的同一层，并且是门对门。你一定已经忘了我和我的母亲了，一定很早就忘了在一个枯燥的追悼会上，那个死者会计的遗孀和她瘦弱的，未长开的女儿。我们一直很安静，是落寞的上流阶层的典型。你不可能听过我们的名字，因为我们没有在门前挂名牌，也没有任何人来拜访我们。再说了，已经过了那么久，十五、十六年了。你不可能记得的。但是，我强烈的记着每一个细节。我记得那一年，那一个时辰，我第一次听到你说话，第一次见到你。我怎么可能记不住呐？那标志着我人生的开始啊。请你再耐心的等待一下，我马上就告诉你从头到尾的所有事。在你空闲的时间听我说这些就感到厌烦了吗？但我用尽一生来爱你也未有丝毫疲倦啊。","tags":["reading"]},{"title":"Letter from an Unknown Woman p1","url":"/2019/07/04/letter-1/","content":"\n>Now I have only you left in the world;\n>　　Only you, who have never known me,\n>　　and whom I have never ceased to love.\n\n\nR. 最著名的小说家刚结束他在山上的一个短暂的假期。他清晨很早就到达了维也纳，并且买了一份报纸在车站，当他看到日期的时候才意识到今天是他的生日“41岁”。对此R.并没有很开心，也没有很遗憾，他找了一辆出租，并且在回去的路上快速扫了一遍报纸。他的管家报告说：“在他不在的期间，除了一些电话之外，还有几个拜访者和一大捆信在等着他。他对这些漠不关心，并打开了一两封对寄件人有兴趣的信。同时把一个巨大的用一个奇怪的笔迹写的信放在一旁。R. 惬意的坐在椅子里，喝着他的早茶，看完报纸，又读了几则传单，然后，他点了一支雪茄，转身去看剩下的信件。\n　　这是一封手稿而不是打印的信件，里面有几打女士笔迹匆忙写下的信纸，他不由自主的多次检查这个信封，以防忽视了被盖住的纸张，但并没有，在信封或者目录上，都没有署名也没有地址。“真奇怪” 他想，同时他开始读信。第一句话是标题。\n　　“对你而言，从来都不知道我是谁” R. 很疑惑，这是专门寄给他的信，还是寄给想象中的人？他的好奇心瞬间被唤起，他继续读着：\n　　我的孩子昨天死了。我为了这个虚弱的小生命与死神斗争了三天三夜，流行性感冒带来的发烧折磨了他整整40个小时。期间，我一直坐在他床边陪着他，我将冰绷带放在了他的额头上，过了一天又一夜，一夜又一天，我一直抓着他不安的小手，第三天晚上，我的力气耗尽了，我没意识到自己闭上了眼睛，我想我一定在硬板凳上睡了三四个小时，死神趁机带走了他。我亲爱的孩子，他躺在狭窄的婴儿床内，就像刚离开的样子，他那聪明的，黑色的眼睛永远闭上了，他的双手交叉放在胸前。四只蜡烛在床的四角燃烧，我不忍去看，不忍去移动，因为当蜡烛在闪烁，阴影投射在他的脸上，投射在他紧闭的嘴唇上，烛火摇曳。这看起来像是他的表情在变化，我几乎可以幻想他根本就没有死去，他会醒来并且用清晰地声音诉说着孩子气的爱。但是我知道他死了，我再也看不到那个场景了。我不止一次的乞求，却又一次次的失望。我知道，我的孩子，在昨天死了。在这个世上，我只剩下你了。你，不知道我是谁；你，毫无察觉的享乐；你，与其他人冒险。只剩你了，一个从来不知道我是谁，我却从未停止去爱的人。","tags":["reading"]},{"title":"《TCP/IP 详解》whois 试验","url":"/2019/06/24/TCP-IP-1/","content":"\n这里有一个ip地址为：47.90.78.76\n\n地址栏输入：http://whois.arin.net/rest/ip/47.90.78.76.txt\n\n查询结果为：\n```\n \n#\n# ARIN WHOIS data and services are subject to the Terms of Use\n# available at: https://www.arin.net/resources/registry/whois/tou/\n#\n# If you see inaccuracies in the results, please report at\n# https://www.arin.net/resources/registry/whois/inaccuracy_reporting/\n#\n# Copyright 1997-2019, American Registry for Internet Numbers, Ltd.\n#\n \nNetRange:       47.90.0.0 - 47.90.127.255\nCIDR:           47.90.0.0/17\nNetName:        ALICLOUD-HK\nNetHandle:      NET-47-90-0-0-1\nParent:         AL-3 (NET-47-88-0-0-1)\nNetType:        Reassigned\nOriginAS:       AS45102\nCustomer:       ALICLOUD-HK (C06961495)\nRegDate:        2018-04-20\nUpdated:        2018-04-20\nComment:        1.For AliCloud IPR Infringement and Abuse Claim, please use below link with browser to report: https://intl.aliyun.com/report\nComment:        \nComment:        2.For Alibaba.com and Aliexpress.com's IPR Infringement , please use below link with browser to report: https://ipp.alibabagroup.com\nComment:        \nComment:        3.For Alibaba.com and Aliexpress.com's Abuse, please send email to those two mail lists to report: intl-abuse@list.alibaba-inc.com and abuse@alibaba-inc.com\nComment:        \nComment:        4. For network issue, please send email to this mail list: aliops-goc@list.alibaba-inc.com\nRef:            https://whois.arin.net/rest/net/NET-47-90-0-0-1\n \n#\n# ARIN WHOIS data and services are subject to the Terms of Use\n# available at: https://www.arin.net/resources/registry/whois/tou/\n#\n# If you see inaccuracies in the results, please report at\n# https://www.arin.net/resources/registry/whois/inaccuracy_reporting/\n#\n# Copyright 1997-2019, American Registry for Internet Numbers, Ltd.\n#\n```\n可以看到该ip属于 47.90.0.0/17 地址块的，所以如果下面没有在划分，同样的主机有 2^15 个，所属状态是被分配，归属ALICLOUD-HK（香港阿里云）。这个地址块属于 AL-3 (NET-47-88-0-0-1)，所以继续往上查询。\n\n \n\n地址栏输入：http://whois.arin.net/rest/net/NET-47-88-0-0-1.txt\n\n查询结果为：\n```\n \n#\n# ARIN WHOIS data and services are subject to the Terms of Use\n# available at: https://www.arin.net/resources/registry/whois/tou/\n#\n# If you see inaccuracies in the results, please report at\n# https://www.arin.net/resources/registry/whois/inaccuracy_reporting/\n#\n# Copyright 1997-2019, American Registry for Internet Numbers, Ltd.\n#\n \nNetRange:       47.88.0.0 - 47.91.255.255\nCIDR:           47.88.0.0/14\nNetName:        AL-3\nNetHandle:      NET-47-88-0-0-1\nParent:         NET47 (NET-47-0-0-0-0)\nNetType:        Direct Allocation\nOriginAS:       \nOrganization:   Alibaba.com LLC (AL-3)\nRegDate:        2015-05-18\nUpdated:        2017-04-26\nRef:            https://whois.arin.net/rest/net/NET-47-88-0-0-1\n \n#\n# ARIN WHOIS data and services are subject to the Terms of Use\n# available at: https://www.arin.net/resources/registry/whois/tou/\n#\n# If you see inaccuracies in the results, please report at\n# https://www.arin.net/resources/registry/whois/inaccuracy_reporting/\n#\n# Copyright 1997-2019, American Registry for Internet Numbers, Ltd.\n#\n```\n可以看到前缀又变短了，这个地址块可以容纳 2^18 个主机，所属组织依然是阿里。继续往上查询\n\n地址栏输入：http://whois.arin.net/rest/net/NET-47-0-0-0-0.txt\n\n查询结果：\n```\n \n#\n# ARIN WHOIS data and services are subject to the Terms of Use\n# available at: https://www.arin.net/resources/registry/whois/tou/\n#\n# If you see inaccuracies in the results, please report at\n# https://www.arin.net/resources/registry/whois/inaccuracy_reporting/\n#\n# Copyright 1997-2019, American Registry for Internet Numbers, Ltd.\n#\n \nNetRange:       47.0.0.0 - 47.255.255.255\nCIDR:           47.0.0.0/8\nNetName:        NET47\nNetHandle:      NET-47-0-0-0-0\nParent:          ()\nNetType:        Early Registrations, Maintained by ARIN\nOriginAS:       \nOrganization:   American Registry for Internet Numbers (ARIN)\nRegDate:        1989-01-06\nUpdated:        2012-02-29\nRef:            https://whois.arin.net/rest/net/NET-47-0-0-0-0\n \n#\n# ARIN WHOIS data and services are subject to the Terms of Use\n# available at: https://www.arin.net/resources/registry/whois/tou/\n#\n# If you see inaccuracies in the results, please report at\n# https://www.arin.net/resources/registry/whois/inaccuracy_reporting/\n#\n# Copyright 1997-2019, American Registry for Internet Numbers, Ltd.\n#\n```\n前缀变为8，也就是一个 A 类网络。所属于 ARIN，也就是美洲 internet 号码注册机构。","tags":["网络"]},{"title":"单例模式","url":"/2019/04/26/singleton/","content":"### 介绍\n单例模式要点：\n- 构造函数私有化\n- 保证只会实例化一个对象\n\n### 种类\n#### 饱汉式\n优点：实现简单，安全  \n缺点：唯一的对象在类本身完成实例化的时候就会被构造，但如果从未使用过这个对象，就会造成内存浪费。  \n比如下面代码，只是使用了静态方法，未使用过对象，但对象也被构造了，并且会自始至终都存在。\n```java\n//饱汉式\nclass SingleTon {\n\t\n\t //构造函数私有化\n     private SingleTon() \n     {\n    \t System.out.println(\"构造函数被调用\");\n     }\n     \n     //将唯一的对象设置为常量\n     private final static SingleTon INSTANCE=new SingleTon();\n     \n     //提供获取对象的外部接口\n     public static SingleTon getInstance()\n     {\n    \t return INSTANCE;\n     }\n     \n     public static void method()\n     {\n    \t System.out.println(\"method方法被调用\");\n     }\n}\n \npublic class MyTest\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tSingleTon.method();\n\t}\n}\n```\n\n执行结果：\n\n>构造函数被调用\n>method方法被调用\n\n#### 懒汉式[不可用]\n优点：实现了 Lazy Loading，在下面代码中可以看出，不使用 INSTANCE 的时候 INSTANCE 是不会初始化的。  \n缺点：多线程下不安全，如果线程 A 进入了 if(INSTANCE == null) 的判断后被打断，线程B又进入了 if(INSTANCE == null) ，并且继续执行，这时已经实例化了一个对象。A 再回来执行时，因为已经判断过了，所以又实例化了一个对象，就违反了单例的原则。\n```java\nclass SingleTon\n{\n\tprivate SingleTon() \n\t{\n\t\tSystem.out.println(\"构造函数被调用\");\n\t}\n\t\n\tprivate static SingleTon INSTANCE;\n\t\n    public static SingleTon getInstance()\n    {\n    \tif(INSTANCE==null)\n    \t{\n    \t\tINSTANCE=new SingleTon();\n    \t}\n    \treturn INSTANCE;\n    }\n    \n    public static void method()\n    {\n    \tSystem.out.println(\"method方法被调用\");\n    }\n}\n \npublic class LazySingleTon {\n\tpublic static void main(String[] args)\n\t{\n\t\tSingleTon.method();\n\t}\n}\n```\n执行结果：\n\n>method方法被调用\n\n#### 懒汉式双重判断\n针对懒汉式线程不安全问题有一个逐步的完善过程，双重判断是最终可用并且不影响效率的版本  \n优点：Lazy Loading 并且线程安全   \n缺点：书写麻烦(如果算的话)\n```java\nclass SingleTon {\n\tprivate SingleTon() {\n\t}\n \n\tprivate static SingleTon INSTANCE;\n \n\tpublic static SingleTon getInstance() {\n\t\tif (INSTANCE == null)\n\t\t\tsynchronized (SingleTon.class) {\n\t\t\t\tif (INSTANCE == null)\n\t\t\t\t\tINSTANCE = new SingleTon();\n\t\t\t}\n\t\treturn INSTANCE;\n\t}\n}\n```\n#### 内部静态类实现单例\n优点：安全，高效，Lazy Loading\n```java\nclass SingleTon\n{\n\tprivate SingleTon() {}\n\t\n\tprivate static class SingleTonInstance\n\t{\n\t\tprivate final static SingleTon INSTANCE=new SingleTon();\n\t}\n \n\tpublic static SingleTon getInstance() {\n\t\treturn SingleTonInstance.INSTANCE;\n\t}\n}\n```\n### Reference\nhttps://www.cnblogs.com/zhaoyan001/p/6365064.html\n\n*如有错误，请多指教*\n","tags":["Java","Pattern"]},{"title":"生产者消费者问题","url":"/2019/04/25/producer-and-consumer/","content":"### 代码\n```java\n/**\n * 生产者消费者问题\n */\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Random;\n \npublic class MyTest {\n \n\tprivate static int maxSize = 10;\n \n\tpublic static void main(String[] args) {\n\t\t// 存储数据\n\t\tLinkedList<Integer> storage = new LinkedList<Integer>();\n \n\t\t// 创建生产者消费者\n\t\tProductor p1 = new Productor(storage, \"1号生产者\");\n\t\tProductor p2 = new Productor(storage, \"2号生产者\");\n\t\tProductor p3 = new Productor(storage, \"3号生产者\");\n\t\tConsumer c1 = new Consumer(storage, \"1号消费者\");\n\t\tConsumer c2 = new Consumer(storage, \"2号消费者\");\n\t\t//Consumer c3 = new Consumer(storage, \"3号消费者\");\n \n\t\t// 创建线程\n\t\tThread t1 = new Thread(p1);\n\t\tThread t2 = new Thread(p2);\n\t\tThread t3 = new Thread(p3);\n\t\tThread t4 = new Thread(c1);\n\t\tThread t5 = new Thread(c2);\n\t\t//Thread t6 = new Thread(c3);\n \n\t\t// 开启线程\n\t\tt1.start();\n\t\tt2.start();\n\t\tt3.start();\n\t\tt4.start();\n\t\tt5.start();\n\t\t//t6.start();\n\t}\n \n\t/*\n\t * 生产者类\n\t */\n\tstatic class Productor implements Runnable {\n\t\tprivate String name;\n\t\tprivate List<Integer> list;\n \n\t\tprivate Productor(List<Integer> list, String name) {\n\t\t\tthis.list = list;\n\t\t\tthis.name = name;\n\t\t}\n \n\t\t@Override\n\t\tpublic void run() {\n\t\t\twhile (true) {\n\t\t\t\tsynchronized (list) {\n\t\t\t\t\twhile (list.size() >= maxSize) {\n\t\t\t\t\t\tSystem.out.println(name + \"因空间不足，无法生产，进入等待\");\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.wait();\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// 这里也可以随机生成一个数字当成是商品\n\t\t\t\t\tlist.add(1);\n\t\t\t\t\tSystem.out.println(name + \"生产了1个商品,现库存:\" + list.size());\n \n\t\t\t\t\t// 生产完成后唤醒所有等待线程\n\t\t\t\t\tlist.notifyAll();\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \n\t}\n \n\t/*\n\t * 消费者类\n\t */\n\tstatic class Consumer implements Runnable {\n\t\tprivate String name;\n\t\tprivate List<Integer> list;\n \n\t\tprivate Consumer(List<Integer> list, String name) {\n\t\t\tthis.list = list;\n\t\t\tthis.name = name;\n\t\t}\n \n\t\t@Override\n\t\tpublic void run() {\n\t\t\twhile (true) {\n\t\t\t\tsynchronized (list) {\n\t\t\t\t\twhile (list.size() == 0) {\n\t\t\t\t\t\tSystem.out.println(name + \"因余量不足，无法消费，进入等待队列\");\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.wait();\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// 删除list的第一个元素\n\t\t\t\t\tlist.remove(0);\n\t\t\t\t\tSystem.out.println(name + \"消费了一个商品，现库存：\" + list.size());\n \n\t\t\t\t\t// 消费完成后唤醒所有的线程\n\t\t\t\t\tlist.notifyAll();\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n \n\t\t}\n \n\t}\n \n}\n```\n代码中创建了 3 个生产者，2 个消费者，一直进行生产/消费行为。\n\n并且设置仓储的最大容量为 10。\n\n运行结果如下：\n\n>1号生产者生产了1个商品,现库存:1\n2号生产者生产了1个商品,现库存:2\n2号消费者消费了一个商品，现库存：1\n3号生产者生产了1个商品,现库存:2\n1号消费者消费了一个商品，现库存：1\n2号生产者生产了1个商品,现库存:2\n1号生产者生产了1个商品,现库存:3\n1号消费者消费了一个商品，现库存：2\n2号消费者消费了一个商品，现库存：1\n3号生产者生产了1个商品,现库存:2\n1号生产者生产了1个商品,现库存:3\n2号生产者生产了1个商品,现库存:4\n3号生产者生产了1个商品,现库存:5\n1号消费者消费了一个商品，现库存：4\n2号消费者消费了一个商品，现库存：3\n1号生产者生产了1个商品,现库存:4\n2号生产者生产了1个商品,现库存:5\n2号消费者消费了一个商品，现库存：4\n3号生产者生产了1个商品,现库存:5\n1号消费者消费了一个商品，现库存：4\n1号生产者生产了1个商品,现库存:5\n2号生产者生产了1个商品,现库存:6\n2号消费者消费了一个商品，现库存：5\n3号生产者生产了1个商品,现库存:6\n1号消费者消费了一个商品，现库存：5\n2号生产者生产了1个商品,现库存:6\n1号生产者生产了1个商品,现库存:7\n1号消费者消费了一个商品，现库存：6\n3号生产者生产了1个商品,现库存:7\n2号消费者消费了一个商品，现库存：6\n2号生产者生产了1个商品,现库存:7\n1号生产者生产了1个商品,现库存:8\n2号消费者消费了一个商品，现库存：7\n3号生产者生产了1个商品,现库存:8\n1号消费者消费了一个商品，现库存：7\n2号生产者生产了1个商品,现库存:8\n1号生产者生产了1个商品,现库存:9\n3号生产者生产了1个商品,现库存:10\n2号消费者消费了一个商品，现库存：9\n1号消费者消费了一个商品，现库存：8\n2号生产者生产了1个商品,现库存:9\n1号生产者生产了1个商品,现库存:10\n2号消费者消费了一个商品，现库存：9\n3号生产者生产了1个商品,现库存:10\n1号消费者消费了一个商品，现库存：9\n2号生产者生产了1个商品,现库存:10\n1号生产者因空间不足，无法生产，进入等待\n3号生产者因空间不足，无法生产，进入等待\n2号消费者消费了一个商品，现库存：9\n1号消费者消费了一个商品，现库存：8\n3号生产者生产了1个商品,现库存:9\n1号生产者生产了1个商品,现库存:10\n2号生产者因空间不足，无法生产，进入等待\n1号消费者消费了一个商品，现库存：9\n2号生产者生产了1个商品,现库存:10\n3号生产者因空间不足，无法生产，进入等待\n1号生产者因空间不足，无法生产，进入等待\n2号消费者消费了一个商品，现库存：9\n1号生产者生产了1个商品,现库存:10\n3号生产者因空间不足，无法生产，进入等待\n......\n\n### 注意点\n1、wait 外面一般要套用一个 while (条件判断)\n如果不加，那么notify过早，线程会陷入等待；如果用 if(条件判断)，那么线程在判断条件后，进入等待；这时条件已经被更改，该线程被唤醒后会继续执行，而不会重新判断是否符合现在的条件。\n2、应使用 notifyAll 而不是 notify  \n如果仓储已满，而被唤醒的一直是生产者，那么所有线程都将陷入等待。\n\n### Reference\nhttps://www.jianshu.com/p/e29632593057\n","tags":["Java","OS"]},{"title":"Java 初始化顺序","url":"/2019/04/23/Java-init.1/","content":"\n### 实验过程\n\n#### 结论一\n静态代码块并不一定初始化在静态成员前，两者顺序关系与代码的顺序有关，依据如下实验\n```java\n/**\n * 测试类的初始化顺序\n * @author 神奇女侠\n *\n */\n \npublic class MyTest {\n \n\t\n\t//静态成员\n\tpublic static MyTest t=new MyTest();\n\t\n\t//静态代码块\n\tstatic\n\t{\n\t\tSystem.out.println(\"这里是MyTest类的静态代码块\");\n\t}\n\t\n\t//构造函数\n\tpublic MyTest()\n\t{\n\t\tSystem.out.println(\"构造函数被执行\");\n\t}\n\t\n\t//主函数\n\tpublic static void main(String[] args)\n\t{\n\t\t\n\t}\n \n}\n```\n执行结果：\n\n构造函数被执行\n这里是MyTest类的静态代码块\n\n```java\n/**\n * 测试类的初始化顺序\n * @author 神奇女侠\n *\n */\n \npublic class MyTest {\n\t//静态代码块\n\tstatic\n\t{\n\t\tSystem.out.println(\"这里是MyTest类的静态代码块\");\n\t}\n\t\t\n\t//静态成员\n\tpublic static MyTest t=new MyTest();\n\t\n\t//构造函数\n\tpublic MyTest()\n\t{\n\t\tSystem.out.println(\"构造函数被执行\");\n\t}\n\t\n\t//主函数\n\tpublic static void main(String[] args)\n\t{\n\t\t\n\t}\n}\n```\n执行结果：\n\n这里是MyTest类的静态代码块\n构造函数被执行\n\n#### 结论二\n内部类的静态代码块与静态成员的初始化顺序也与代码中的顺序有关\n```java\npublic class MyTest {\n\t//静态代码块\n\tstatic\n\t{\n\t\tSystem.out.println(\"这里是MyTest类的静态代码块\");\n\t}\n\t\t\n\t//静态成员\n\t//public static MyTest t=new MyTest();\n\t\n\t//构造函数\n\tpublic MyTest()\n\t{\n\t\tSystem.out.println(\"构造函数被执行\");\n\t}\n\t\n\t//内部类\n\tpublic static class Inner\n\t{\n\t\t//内部类的静态代码块\n\t\tstatic\n\t\t{\n\t\t\tSystem.out.println(\"这里是Inner类的静态代码块\");\n\t\t}\n\t\t\t\n\t\t//静态成员\n\t\tpublic static MyTest t=new MyTest();\n\t\t\n\t\tpublic static void Method()\n\t\t{\n\t\t\tSystem.out.println(\"Method()被执行\");\n\t\t}\n\t}\n\t\n\t//主函数\n\tpublic static void main(String[] args)\n\t{\n\t\tMyTest.Inner.Method();\n\t}\n}\n```\n执行结果：\n\n这里是MyTest类的静态代码块\n这里是Inner类的静态代码块\n构造函数被执行\nMethod()被执行\n\n```java\npublic class MyTest {\n\t//静态代码块\n\tstatic\n\t{\n\t\tSystem.out.println(\"这里是MyTest类的静态代码块\");\n\t}\n\t\t\n\t//静态成员\n\t//public static MyTest t=new MyTest();\n\t\n\t//构造函数\n\tpublic MyTest()\n\t{\n\t\tSystem.out.println(\"构造函数被执行\");\n\t}\n\t\n\t//内部类\n\tpublic static class Inner\n\t{\n\t\t\n\t\t//静态成员\n\t\tpublic static MyTest t=new MyTest();\n\t\t\n\t\t//内部类的静态代码块\n\t\tstatic\n\t\t{\n\t\t\tSystem.out.println(\"这里是Inner类的静态代码块\");\n\t\t}\n\t\t\t\t\t\n\t\t\n\t\tpublic static void Method()\n\t\t{\n\t\t\tSystem.out.println(\"Method()被执行\");\n\t\t}\n\t}\n\t\n\t//主函数\n\tpublic static void main(String[] args)\n\t{\n\t\tMyTest.Inner.Method();\n\t}\n}\n```\n\n这里是MyTest类的静态代码块\n构造函数被执行\n这里是Inner类的静态代码块\nMethod()被执行\n\n#### 结论三\n类的使用需经过加载(将二进制文件，即.class文件加载进内存)，链接，初始化。静态代码块的执行与静态成员的初始化都在类的初始化时期；也就是说，类只有被使用时才会完成初始化。\n分析：MyTest的静态代码块始终首先被执行，是因为jvm使用了MyTest内的main方法。所以MyTest在执行初的时候就完成了加载，链接，初始化三步。\n\n而Inner可以理解为是MyTest的静态成员，应该在一开始就完成了初始化，但是Inner内的静态代码块却没有在MyTest的静态成员初始化的时候执行，说明这时的Inner只是完成了加载，链接两步。直到调用了Inner内的Method方法，Inner的初始化才被完成。    \n\n#### 结论四\n只有类完成初始化之后（加载，链接，初始化）,才可以new对象。new对象的初始化顺序为：构造代码块，成员变量初始化，构造函数（先父后子）\n\n总结：类的初始化与对象的初始化是不一样的，也就可以理解为什么静态的只会执行一次，而非静态new多少次就执行多少次。因为静态的初始化是在类本身的初始化时期进行的，与对象的初始化不同。     \n\n### 总结\n引用一下别人的总结：\n>顺序是：父类静态属性->父类静态代码块->子类静态变量->子类静态代码块->父类非静态变量->父类非静态代码块->父类构造函数->子类非静态变量->子类非静态代码块->子类构造函数\n>这样的加载顺序不是绝对的 因为静态变量和静态代码块跟声明顺序有关。\n>对于如果静态代码块中调用静态变量，那么静态变量必须在静态代码块前面声明；如果静态代码块中没有调用静态变量，那么就跟顺序有关了，谁先声明谁先被加载。说白了还是顺序加载，之所以会出现“如果静态代码块中调用静态变量，那么静态变量必须在静态代码块前面声明”，是因为变量是声明，所以出现编译错误。\n>应用到内部类中 静态变量和静态代码块跟声明顺序有关。 这样就可以解释你的问题了。内部类也是类。\n>测试所用jdk版本1.8.0_20\n>类静态块-类静态属性这个跟顺序有关系 如果类静态属性在类静态代码块之前 那么类静态属性先初始化\n\n### Reference：\nhttps://www.oschina.net/question/2273217_217864   \nhttp://www.cnblogs.com/yahokuma/p/3668138.html   \n\n*如有错误，请多指教*\n\n\n\n","tags":["Java"]},{"title":"局域网聊天室","url":"/2018/08/04/lanChat/","content":"### 效果展示\n\n一个局域网内的聊天室，一个客户端发送了信息之后，服务端将其广播给当前连接的所有客户端。\n![](/img/lanchat.gif)\n\n### 服务端部分\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading;\n \nnamespace Unity聊天室服务端\n{\n    class Client\n    {\n        private Socket clientSkt;\n        private Thread t;\n        private byte[] rcvData;\n        private string massage;\n \n \n        public Client(Socket client)\n        {\n            this.clientSkt = client;\n            t = new Thread(ReceiveData);\n            t.Start();\n            rcvData = new byte[1024];\n            Console.WriteLine(\"一个客户端已连接\");\n        }\n \n \n        public bool Connected { get { return clientSkt.Connected; } }\n        /*connected返回的只是服务器是否断开和客户端的连接\n         *如果客户端单方断开了连接，这里的connected依然是true\n         * 所以要用poll来判断是否处于连通状态\n         */\n \n \n        /// <summary>\n        /// 接受客户端发来的信息，并调用广播方法\n        /// </summary>\n        private void ReceiveData()\n        {\n            while (true)\n            {\n \n                if (clientSkt.Poll(10, SelectMode.SelectRead))\n                {\n \n                    Program.accptClientList.Remove(this);\n                    clientSkt.Close();\n                    Console.WriteLine(\"一条连接已中断\");\n                    break;\n                }\n                else\n                {\n                    int lenth = clientSkt.Receive(rcvData);\n                    massage = Encoding.UTF8.GetString(rcvData, 0, lenth);\n                    Console.WriteLine(\"服务端收到了一条消息：\" + massage);\n                    Program.BroadcastMsg(massage);\n                }\n            }\n        }\n        /// <summary>\n        /// 发送消息给该客户端\n        /// </summary>\n        /// <param name=\"msg\"></param>\n        public void SendMsg(string msg)\n        {\n \n            clientSkt.Send(Encoding.UTF8.GetBytes(msg));\n        }\n \n \n \n    }\n}\n```\n\n```c#\nusing System;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nusing System.Collections.Generic;\n \nnamespace Unity聊天室服务端\n{\n    \n    class Program\n    {\n        public static List<Client> accptClientList = new List<Client>();\n        /// <summary>\n        /// 将msg广播给所有现在仍然连接的客户端\n        /// </summary>\n        /// <param name=\"msg\"></param>\n        public static void BroadcastMsg(string msg)\n        {\n           \n \n            /*foreach是只读模式，在里面不能删除自己，因为一旦删除，就会重新排序\n             * 比如原来的索引0被删除了，下一次foreach的索引0就会变成原来的1\n             * 1就会变成2，所以会报“集合已修改；可能无法执行枚举操作”的错误\n             */\n \n            //foreach(Client clt in accptClientList)\n            //{\n            //    if(clt.Connected)\n            //    {\n            //        clt.SendMsg(msg);\n            //        Console.WriteLine(\"发送消息成功\");\n            //    }\n            //    else\n            //    {\n            //        accptClientList.Remove(clt);\n            //    }\n            //}\n    \n            for (int i = 0; i < accptClientList.Count; i++)\n            {\n                accptClientList[i].SendMsg(msg);\n            }\n        }\n \n        static void Main(string[] args)\n        {\n            Socket serveSkt = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n \n            //绑定ip和端口\n            serveSkt.Bind(new IPEndPoint(IPAddress.Parse(\"192.168.1.4\"), 10086));\n \n            //开始监听消息\n            serveSkt.Listen(10);\n            Console.WriteLine(\"服务端正在运行\");\n \n            while (true)\n            {\n                Socket client = serveSkt.Accept();\n                accptClientList.Add(new Client(client));\n            }\n \n        }\n    }\n}\n```\n\n### Unity 部分\n```c#\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing System.Net.Sockets;\nusing System.Net;\nusing System.Text;\nusing UnityEngine.UI;\nusing System.Threading;\n \npublic class ChatManage : MonoBehaviour {\n    \n    private Socket client;\n    private Thread t;\n    private byte[] receiveMsg;\n    private byte[] sendMsg;\n    private string receiveSting;\n \n    public InputField inputField;\n    public Button sendBtn;\n    public Text msgText;\n \n \n    private void Awake()\n    {\n       \n    }\n    // Use this for initialization\n    void Start () {\n \n        sendMsg = new byte[1024];\n        receiveMsg = new byte[1024];\n        client = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n        client.Connect(new IPEndPoint(IPAddress.Parse(\"192.168.1.4\"), 10086));\n        \n \n        t = new Thread(ReceiveMsg);\n        t.Start();\n \n        /*\n         * receive不要写在主线程里面，不然服务端那边如果一直不传递消息过来的话\n         * 主线程就会一直堵塞\n         */\n    }\n\t\n\t// Update is called once per frame\n\tvoid Update () {\n        Debug.Log(\"收到消息为\"+receiveSting);\n        if (receiveSting != \"\")\n        {\n            msgText.text += (\"\\n\" + receiveSting);\n            receiveSting = \"\";\n        }\n    }\n \n    void ReceiveMsg()\n    {\n        while (true)\n        {\n            if (client.Connected)\n            {\n                int lenth = client.Receive(receiveMsg);\n                receiveSting = Encoding.UTF8.GetString(receiveMsg, 0, lenth);\n            }\n            else break;\n        }\n    }\n \npublic void OnSendBtn()\n    {\n        if(inputField.text!=\"\")\n        {\n            sendMsg = Encoding.UTF8.GetBytes(inputField.text);\n            client.Send(sendMsg);\n            inputField.text = \"\";\n        }\n        \n    }\n    private void OnDestroy()\n    {\n        //t.Abort();\n        client.Shutdown(SocketShutdown.Both);\n        client.Close();\n    }\n}\n```","tags":["网络","Unity"]},{"title":"CF Robot Vacuum Cleaner","url":"/2018/03/18/CF-Robot-Vacuum-Cleaner/","content":"\n### 题号\nCodeForces - 922D\n### 思路\ns/h越大的越往前排，这样整体的字符串才是s/h值由大变小。\n\n### 代码\n```c++\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int MAX=100005;\nstruct T\n{\n\tint sNum;\n\tint hNum;\n\tfloat sDh;\n\tint sh;\n}tManager[MAX];\nbool cmp(T a,T b)\n{\n\treturn a.sDh>b.sDh;\n}\nint main()\n{\n\tint total,id=0;\n\tchar str[MAX];\n\tcin>>total;\n\twhile(id<total)\n\t{\n\t    cin>>str;\n\t    int i=0;\n\t    while(str[i]!='\\0')\n\t    {\n\t    \tif(str[i]=='s')\n\t\t\t\ttManager[id].sNum++;\n\t    \telse if(str[i]=='h')\n\t\t\t\t{\n\t    \ttManager[id].hNum++;\n\t\t\t\ttManager[id].sh+=tManager[id].sNum;\n\t\t\t  }\n\t\t\t\ti++;\n\t    }\n\t\t\tif(!tManager[id].hNum)\n\t\t\t{\n\t\t\t\ttManager[id].sDh=MAX;//s的数量与h的数量的比值最大有可能为99999；\n\t\t\t\t//所以用MAX就足够了\n\t\t\t}\n\t\t\telse\n\t    tManager[id].sDh=(float)tManager[id].sNum/tManager[id].hNum;\n\t\t\tid++;\n\t}\n\tsort(tManager,tManager+id,cmp);\n  long long ans=0,sCot=0;//ans最大有可能是5w*5w，所以要用long long\n  for(int i=0;i<id;i++)\n\t{\n\t\tans+=sCot*tManager[i].hNum;\n\t\tans+=tManager[i].sh;\n\t\tsCot+=tManager[i].sNum;\n\t}\n   cout<<ans<<endl;\n \n}\n```\n","tags":["algorithm"]},{"title":"最长回文子串","url":"/2018/03/16/longest-palindromic-substring.1/","content":"\n### HDOJ3068\n```c++\n#include<iostream>\n#include<cstring>\n#include<algorithm> \nconst int MAX=110005;\nchar s1[MAX];\nchar s[2*MAX+2];//增加MAX+1个‘#’和一个‘$’ \nint d[2*MAX+2];\nusing namespace std;\nint main()\n{\n\twhile(cin>>s1)\n\t{\n\t\tmemset(d,0,sizeof(d));\n\t\tmemset(s,0,sizeof(s));\n\t\t\n\t\t//字符串预处理 \n\t   int ans=1;\n\t   int len=strlen(s1);\n\t   s[0]='&';\n\t   for(int i=1;i<=2*len+1;i+=2)\n\t   {\n\t   \ts[i]='#';\n\t   }\n\t   int k=0;\n\t   for(int i=2;i<=2*len;i+=2)\n\t   {\n\t   \ts[i]=s1[k++];\n\t   }\n\t   \n\t   //debug\n\t   /*for(int i=0;i<strlen(s);i++)\n\t   {\n\t   \tcout<<s[i]<<\" \";\n\t   }\n\t   cout<<endl;*/\n\t   \n\t   \n\t   \n\t   int id=0,mx=0;\n\t   d[0]=1;d[1]=1;d[2]=2;\n\t   //mx是以id为中心的回文字串的右边缘（不在字串内） \n\t   //id是已知的回文字串中，右边缘最靠右的子串的中心\n\t   id=2;mx=id+d[id];\n\t   \n\t   for(int i=3;s[i]!='\\0';i++)\n\t   {\n\t   \t\n\t   \t//j是i关于id的对称点\n\t   \tint j=2*id-i;\n\t   \t\n\t   \t//当i<mx,d[i]>=min(mx-i,d[j]) \n\t   \tif(i<mx)\n\t   \t{\n\t\t\tif(d[j]<mx-i)\n\t\t\t{\n\t\t\t\td[i]=d[j];\n\t\t\t}  \n\t\t  \n\t\t\telse\n\t\t\t{\n\t\t\t\td[i]=mx-i;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//当i>=mx的时候，的d[i]=1; \n\t\telse d[i]=1;\n\t\t\n\t\t/*\n\t\t上13行可写成d[i]=i<mx?min(d[2*id-i],mx-i):1; \n\t\t*/ \n\t\t\n\t\t//确定了d[i]的最小值之后，超出部分逐个比较 \n\t\twhile(s[i+d[i]]==s[i-d[i]])\n\t\t\td[i]++;\n\t\t\n\t\t//更新id，mx的值 \n\t\tif(i+d[i]>mx)\n\t\t{\n\t\t\tmx=i+d[i];\n\t\t\tid=i;\n\t\t}\n\t   \n        //更新最大值 \n\t\tif(d[i]-1>ans)\n\t\tans=d[i]-1;\n\t   } \n\t   \n\t   //输出答案 \n\t   cout<<ans<<endl;\n\t}\n\t\n}\n\n```\n\n### LeetCode: Longest Palindromic Substring\n```c++\nclass Solution {\npublic:\n    string longestPalindrome(string s) {\n         char pad='#';\n    int len=s.length();\n    int total_len=2*len+1;\n    char* cstr=new char[total_len];\n    int* rcd =new int[total_len];//记录以index为中心的最长回文子串长度\n    cstr[0]=pad;\n    int k=1;\n    for(int i=0;i<len;i++)\n    {\n      cstr[k++]=s[i];\n      cstr[k++]=pad;\n    }\n\n    int max_index=0;\n    for(int i=0;i<total_len;i++)\n    {\n      rcd[i]=1;\n      for(int j=i/2;j<i;j++)\n      {\n        if(2*j-i<0)continue;\n        if(rcd[j]==i-j&&cstr[2*j-i]==cstr[i])\n        rcd[j]++;\n        if(rcd[j]>rcd[max_index])\n        max_index=j;\n      }\n    }\n\n    string sb=\"\";\n\n    //起始位置的下标\n\n    int t=max_index-rcd[max_index]+1;\n    for(int i=t;i<=2*max_index-t;i++)\n    {\n      if(cstr[i]!=pad)\n      //append会运行错\n      //sb.append(cstr,i,1);\n          sb+=cstr[i];\n    }\n    return sb;\n        \n    }\n};\n```\n\n","tags":["algorithm","LeetCode"]},{"title":"My Summer Holiday Lives","url":"/2017/09/06/2017-08-24-My-Summer-Holiday-Lives/","content":"\n参考资料：\n* [字符串参考资料](#1.1.1)\n* [数学参考资料](#1.1.2)\n* [数据结构参考资料](#1.1.3)\n* [图论参考资料](#1.1.4)\n* [计算几何参考资料](#1.1.5)\n\n代码强化训练\n* [代码强化训练1 p3-24](#1.2.1)\n* [代码强化训练2 p25-42](#1.2.2)\n* [代码强化训练3 p42-74](#1.2.3)\n* [代码强化训练4 p74-96](#1.2.4)\n* [代码强化训练5 p96-121](#1.2.5)\n* [代码强化训练6 p121-152](#1.2.6)\n\n组队训练\n* [Summer 2017 Team Training 1](#1.3.1)\n* [Summer 2017 Team Training 2](#1.3.2)\n* [Summer 2017 Team Training 3](#1.3.3)\n* [Summer 2017 Team Training 4](#1.3.4)\n* [Summer 2017 Team Training 5](#1.3.5)\n\n个人强化训练\n* [Summer 2017 Individual Training 1](#1.4.1)\n* [Summer 2017 Individual Training 2](#1.4.2)\n\n综合训练\n* [Summer 2017 Team Professional Contest 1](#1.5.1)\n* [Summer 2017 Team Professional Contest 2](#1.5.2)\n* [Summer 2017 Team Professional Contest 3](#1.5.3)\n\n<h4 id=\"1.1.1\"> 字符串参考资料</h4>\n\n>1、从头到尾彻底理解KMP\n><http://www.cnblogs.com/zhangtianq/p/5839909.html>\n>\n>2、最长回文子串\n><http://blog.csdn.net/kangroger/article/details/3774263>\n>\n>3、AC自动机最详细的讲解，让你一次学会AC自动机\n><http://blog.csdn.net/creatorx/article/details/71100840>\n>\n>4、后缀数组\n><http://www.cnblogs.com/shanchuan04/p/5324009.html>\n><http://blog.csdn.net/fp_hzq/article/details/8990932>\n>\n>5、后缀自动机\n><https://www.zhihu.com/question/34039162>\n\n<h4 id=\"1.1.2\">数学参考资料</h4>\n\n>1、素数有关算法\n><http://blog.csdn.net/snow_me/article/details/52588819>\n>\n>2、扩展欧几里德算法\n><http://blog.csdn.net/zhjchengfeng5/article/details/7786595>\n>\n>3、逆元\n><http://blog.csdn.net/acdreamers/article/details/8220787>\n>\n>4、Miller_rabin算法\n><http://blog.csdn.net/maxichu/article/details/45458569>\n>\n>5、欧拉函数\n><http://blog.csdn.net/sentimental_dog/article/details/52002608>\n>\n>6、模线性方程组\n><http://blog.csdn.net/qq_21120027/article/details/51340218>\n>\n>7、高斯消元法\n><http://blog.csdn.net/duanxian0621/article/details/7408887>\n>\n>8、FFT（快速傅氏变换）\n><http://www.gatevin.moe/acm/fft%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/>\n>\n>9、莫比乌斯反演\n><http://blog.csdn.net/acdreamers/article/details/8542292>\n>\n>10、离散对数（Baby Step Giant Step）\n><http://blog.csdn.net/acdreamers/article/details/8579511>\n\n<h4 id=\"1.1.3\">数据结构参考资料</h4>\n\n>1、划分树\n><http://blog.csdn.net/shiqi_614/article/details/8041390>\n>\n>2、主席树\n><http://blog.csdn.net/sprintfwater/article/details/9162041>\n>\n>3、区间最值查询（RMQ）\n><http://blog.csdn.net/liang5630/article/details/7917702>\n><http://blog.csdn.net/metalseed/article/details/7953260>\n>\n>4、树链剖分原理\n><http://blog.csdn.net/acdreamers/article/details/10591443>\n>\n>5、树状数组\n><http://blog.csdn.net/ljd4305/article/details/10101535>\n>\n>6、线段树\n><http://www.cnblogs.com/TenosDoIt/p/3453089.html>\n>\n>7、Splay Tree（伸展树）\n><http://blog.csdn.net/niuox/article/details/8018280>\n>\n>8、动态树\n><http://blog.csdn.net/d891320478/article/details/9181385>\n>\n>9、主席树\n><http://blog.csdn.net/sprintfwater/article/details/9162041>\n\n\n\n<h4 id=\"1.1.4\">图论参考资料</h4>\n\n>1、最短路：Dijkstra算法\n><http://www.cnblogs.com/skywang12345/p/3711512.html>\n>\n>2、最短路：Bellman-Ford算法\n><http://blog.csdn.net/niushuai666/article/details/6791765>\n>\n>3、最短路：SPFA算法\n><http://www.layz.net/LAOJ/suanfa/s9-4.html>\n>\n>4、最小生成树：Kruskal算法 ><http://blog.csdn.net/luomingjun12315/article/details/47700237>\n>\n>5、最小生成树：Prim算法\n><http://blog.csdn.net/yeruby/article/details/38615045>\n>\n>6、次小生成树\n><http://yzmduncan.iteye.com/blog/1018358>\n>\n>7、有向图的强连通分量：Tarjan算法\n><http://www.cnblogs.com/uncle-lu/p/5876729.html>\n>\n>8、有向图的强连通分量：Kosaraju算法\n><http://www.cnblogs.com/nullzx/p/6437926.html>\n>\n>9、最小树形图\n><http://www.cnblogs.com/Ash-ly/p/5536796.html>\n>\n>10、二分图\n><http://dsqiu.iteye.com/blog/1689505>\n><http://www.renfei.org/blog/bipartite-matching.html>\n>\n>11、二分图最大匹配：匈牙利算法\n><http://blog.csdn.net/dark_scope/article/details/8880547>\n><http://www.cnblogs.com/pony1993/archive/2012/07/25/2607738.html>\n>\n>12、二分图最大匹配：Hopcroft-Karp算法\n><http://blog.csdn.net/wall_f/article/details/8248373>\n>\n>13、生成树计数：Matrix-Tree定理\n><http://blog.csdn.net/longshuai0821/article/details/7764267>\n>\n>14、二分图多重匹配问题\n><http://blog.csdn.net/u014427196/article/details/48319639>\n>\n>15、二分图最大权匹配：Kuhn-Munkres算法\n><http://www.cnblogs.com/kuangbin/archive/2012/08/19/2646535.html>\n>\n>16、最大流问题\n><http://blog.csdn.net/yiqingnian28/article/details/23388633>\n><http://www.cnblogs.com/kuangbin/archive/2011/07/26/2117636.html>\n>\n>17、最小费用最大流\n><http://blog.csdn.net/stillxjy/article/details/52047189>\n>\n>18、2-SAT\n><http://blog.csdn.net/jarjingx/article/details/8521690>\n>\n>19、曼哈顿距离最小生成树\n><http://blog.csdn.net/acm_cxlove/article/details/8890003>\n>\n>20、莫队算法\n><http://blog.csdn.net/hzj1054689699/article/details/51866615>\n>\n>21、一般图匹配问题：带花树\n><http://blog.csdn.net/u014261987/article/details/41350003>\n><http://blog.csdn.net/jackyguo1992/article/details/11271497>\n>\n>22、LCA（最近公共祖先）\n><http://blog.csdn.net/liangzhaoyang1/article/details/52549822>\n><http://www.cnblogs.com/wuminye/p/3527176.html>\n><http://blog.csdn.net/Janis_z/article/details/52937631?locationNum=6&fps=1>\n\n<h4 id=\"1.1.5\">计算几何参考资料</h4>\n>1、计算几何\n><http://www.cnblogs.com/kuangbin/category/410309.html>\n\n<h4 id=\"1.1.6\">其他-参考资料</h4>\n>1、动态规划\n><http://blog.csdn.net/baidu_28312631/article/details/47418773>\n><http://blog.csdn.net/scythe666/article/details/50921628>\n>\n>2、莫队算法\n><http://blog.csdn.net/hnshhslsh/article/details/50582926>\n\n<h3 id=\"1.2.1\">7-20 代码强化训练1 《葵花宝典》P3-24</h3>\nA - Cow Patterns\n来源：POJ – 3167\n知识点：扩展KMP等\n[http://blog.csdn.net/tmeteorj/article/details/8693366](http://blog.csdn.net/tmeteorj/article/details/8693366)\n[http://www.cppblog.com/zxb/archive/2010/10/06/128782.aspx?opt=admin](http://www.cppblog.com/zxb/archive/2010/10/06/128782.aspx?opt=admin)\n\nB - Best Sequence\n来源：POJ – 1699\n知识点：扩展KMP+DFS等\n[http://blog.csdn.net/zzzz40/article/details/39186109](http://blog.csdn.net/zzzz40/article/details/39186109)\n\nC – Palindrome\n来源：POJ – 3974\n知识点：Manacher算法等\n[http://blog.csdn.net/u010885899/article/details/45366633](http://blog.csdn.net/u010885899/article/details/45366633)\n[http://blog.csdn.net/geniusluzh/article/details/8639759](http://blog.csdn.net/geniusluzh/article/details/8639759)\n\nD - Keywords Search\n来源：HDU – 2222\n知识点：AC自动机等\n[http://blog.csdn.net/hnust_xiehonghao/article/details/9130539](http://blog.csdn.net/hnust_xiehonghao/article/details/9130539)\n\nE - Longest Common Substring\n来源：HDU – 1403\n知识点：后缀数组DA算法（倍增算法）等\n[http://blog.csdn.net/xinag578/article/details/50164599](http://blog.csdn.net/xinag578/article/details/50164599)\n\nF - Power Strings\n来源：POJ – 2406\n知识点：后缀数组DC3算法等\n[http://blog.csdn.net/libin56842/article/details/46310425](http://blog.csdn.net/libin56842/article/details/46310425)\n\nG – String\n来源：CodeForces - 123D\n知识点：后缀自动机（SAM）等\n[http://blog.csdn.net/dyx404514/article/details/8713542](http://blog.csdn.net/dyx404514/article/details/8713542)\n[http://www.hankcs.com/program/algorithm/codeforces-123d-string.html](http://www.hankcs.com/program/algorithm/codeforces-123d-string.html)\n\nH - Prime Distance\n来源：POJ – 2689\n知识点：大区间素数筛选等\n[http://www.cnblogs.com/kuangbin/archive/2013/05/20/3089840.html](http://www.cnblogs.com/kuangbin/archive/2013/05/20/3089840.html)\n\nI - The Factor\n来源：HDU – 5428\n知识点：素数筛选合数分解等\n[http://www.bubuko.com/infodetail-1079772.html](http://www.bubuko.com/infodetail-1079772.html)\n[http://www.cnblogs.com/Apro/p/4784808.html](http://www.cnblogs.com/Apro/p/4784808.html)\n\nJ - A/B\n来源：HDU - 1576\n知识点：扩展欧几里得算法等\n[http://blog.csdn.net/ljd4305/article/details/26057385](http://blog.csdn.net/ljd4305/article/details/26057385)\n[http://blog.csdn.net/lyc1635566ty/article/details/50611246](http://blog.csdn.net/lyc1635566ty/article/details/50611246)\n\nK - X问题\n来源：HDU - 1573\n知识点：解一元线性同余方程组、中国剩余定理等\n[http://www.cnblogs.com/zhangmingcheng/p/4238407.html](http://www.cnblogs.com/zhangmingcheng/p/4238407.html)\n[http://blog.csdn.net/a601025382s/article/details/10296577](http://blog.csdn.net/a601025382s/article/details/10296577)\n\nL - Prime Test\n来源：POJ – 1811\n知识点：大素数判断和素因子分解等\n[http://www.cnblogs.com/kuangbin/archive/2012/08/19/2646404.html](http://www.cnblogs.com/kuangbin/archive/2012/08/19/2646404.html)\n\nM - Farey Sequence\n来源：POJ – 2478\n知识点：欧拉函数等\n[http://blog.csdn.net/aaaaacmer/article/details/47272037](http://blog.csdn.net/aaaaacmer/article/details/47272037)\n\n<h3 id=\"1.2.2\">7-21 代码强化训练2 《葵花宝典》P24-42</h3>\n\nA - Kind of a Blur\n来源：HDU - 3359\n知识点：高斯消元法等\n<http://blog.csdn.net/qwb492859377/article/details/47013321>\n\nB - A * B Problem Plus\n来源：HDU – 1402\n知识点：FFT、大整数乘法等\n<http://blog.csdn.net/sdj222555/article/details/9786527>\n\nC - 3-idiots\n来源：HDU – 4609\n知识点：FFT计数等\n<http://blog.csdn.net/qq_33184171/article/details/54427994>\n\nD - Painter's Problem\n来源：POJ – 1681\n知识点：高斯消元法（一类开关问题，对2取模的01方程组）等\n<http://www.cnblogs.com/kuangbin/archive/2012/08/31/2665913.html>\n\nE - Widget Factory\n来源：POJ – 2947\n知识点：高斯消元法（解同余方程组）等\n<http://www.cnblogs.com/gj-Acit/p/3903085.html>\n\nF - Partition\n来源：HDU – 4651\n知识点：整数拆分等\n<http://www.cnblogs.com/zhsl/archive/2013/08/07/3242268.html>\n\nG - Integer Partition\n来源：HDU – 4658\n知识点：整数划分、生成函数等\n<http://blog.csdn.net/a601025382s/article/details/10299367>\n\nH - Sumdiv\n来源：POJ – 1845\n知识点：求A^B的约数之和对MOD取模等\n<http://www.cnblogs.com/kuangbin/archive/2012/08/10/2631225.html>\n\nI - GCD\n来源：HDU – 1695\n知识点：莫比乌斯反演等\n<http://blog.csdn.net/lixuepeng_001/article/details/50577932>\n\nJ - Discrete Logging\n来源：POJ – 2417\n知识点：离散对数（Baby Step Giant Step）等\n<http://www.cnblogs.com/kuangbin/archive/2013/08/24/3278852.html>\n\nK - K-th Number\n来源：POJ – 2104\n知识点：经典划分树、主席树等\n<http://blog.csdn.net/pure_lady/article/details/46806833>\n<http://www.cnblogs.com/oyking/p/3230296.html>\n\nL - Sliding Window\n来源：POJ – 2823\n知识点：单调队列、线段树、一维RMQ等\n<http://blog.csdn.net/u013351484/article/details/45112271>\n\nM – Cornfields\n来源：POJ – 2019\n知识点：二维RMQ等\n<http://www.cnblogs.com/kuangbin/p/3227420.html>\n\n<h3 id=\"1.2.3\">7-23 代码强化训练3 《葵花宝典》P43-74</h3>\n\nA - Aragorn's Story\n来源： HDU – 3966\n知识点：树链剖分+树状数组等\n<http://www.cnblogs.com/kuangbin/archive/2013/08/14/3258736.html>\n\nB - Query on a tree\n来源： SPOJ – QTREE\n知识点：树链剖分+线段树等\n<http://blog.csdn.net/niuox/article/details/8145842>\n\nC - SuperMemo\n来源：POJ – 3580\n知识点：Splay Tree（伸展树）等\n<http://blog.csdn.net/jasonzhu8/article/details/5747811>\n\nD - Query on The Trees\n来源：HDU – 4010\n知识点：动态树等\n<http://www.cnblogs.com/kuangbin/archive/2013/09/04/3300251.html>\n\nE - D-query\n来源：SPOJ - DQUERY\n知识点：主席树-区间不同数的个数 等\n<http://blog.csdn.net/aozil_yang/article/details/65448883>\n\nF - K-th Number\n来源：POJ – 2104\n知识点：主席树-静态区间第k大 等\n<http://www.cnblogs.com/kuangbin/archive/2013/09/05/3302731.html>\n\nG - Count on a tree\n来源：SPOJ – COT\n知识点：LCA+主席树等\n<http://blog.csdn.net/acm_cxlove/article/details/8564167>\n<http://www.cnblogs.com/arbitrary/archive/2013/10/09/3360104.html>\n\n\nH - Dynamic Rankings\n来源： ZOJ - 2112\n知识点：树状数组+主席树-动态第k大等\n<http://www.cnblogs.com/kuangbin/p/3308118.html>\n\nI - MPI Maelstrom\n来源：POJ – 1502\n知识点：Dijkstra算法等\n<http://blog.csdn.net/u013446688/article/details/42708487>\n\nJ - Invitation Cards\n来源：POJ – 1511\n知识点：优先队列优化的Dijkstra算法等\n<http://www.cnblogs.com/kuangbin/p/3140958.html>\n\nK - Currency Exchange\n来源：POJ – 1860\n知识点：Bellman-Ford算法等\n<http://www.cnblogs.com/kuangbin/archive/2012/08/17/2644807.html>\n\nL - Wormholes\n来源：POJ - 3259\n知识点：SPFA等\n<http://blog.csdn.net/murmured/article/details/18669909>\n\nM - Highways\n来源：POJ – 2485\n知识点：最小生成树等\n<http://blog.csdn.net/mikasa3/article/details/51559191>\n<http://blog.csdn.net/fanesemyk/article/details/51137466?locationNum=1&fps=1>\n\nN - Design Tutorial: Inverse the Problem\n来源：CodeForces - 472D\n知识点：最小生成树等\n<http://blog.csdn.net/u010660276/article/details/39901287>\n\nO - Qin Shi Huang's National Road System\n来源：HDU - 4081\n知识点：次小生成树等\n<http://blog.csdn.net/shuangde800/article/details/7982106>\n\n<h3 id=\"1.2.4\">7-24 代码强化训练4 《葵花宝典》P74-96</h3>\n\nA - Popular Cows\n来源：POJ – 2186\n知识点：Tarjan算法等\n<http://www.dontcry-tat.com/2017/04/26/poj-2186-popular-cows/>\n\nB - 迷宫城堡\n来源：HDU – 1269\n知识点：Kosaraju算法等\n<http://blog.csdn.net/qq7366020/article/details/12943345>\n\nC - Critical Links\n来源：UVA – 796\n知识点：无向图求桥等\n<http://www.cnblogs.com/chenchengxun/p/4718717.html>\n\nD - Electricity\n来源：POJ – 2117\n知识点：无向图求割点\n<http://blog.csdn.net/liwen_7/article/details/7919220>\n\nE - Redundant Paths\n来源：POJ – 3177\n知识点：无向图的双连通问题等\n<http://mojijs.com/2014/11/165169/index.html>\n\nF - Knights of the Round Table\n来源：POJ – 2942\n知识点：点的双连通分量等\n<http://www.cnblogs.com/wangfang20/p/3201502.html>\n\nG - Command Network\n来源：POJ – 3164\n知识点：最小树形图等\n<http://blog.csdn.net/shuangde800/article/details/8039359>\n\nH - The Perfect Stall\n来源：POJ – 1274\n知识点：二分图最大匹配：匈牙利算法\n<http://blog.csdn.net/u013487051/article/details/37656979>\n\nI - Asteroids\n来源：POJ – 3041\n知识点：二分图最大匹配：匈牙利算法\n<http://blog.csdn.net/yeruby/article/details/39315713>\n\nJ - COURSES\n来源：POJ – 1469\n知识点：二分图最大匹配：Hopcroft-Karp算法\n<http://blog.csdn.net/u011466175/article/details/23709885>\n\nK - Lightning\n来源：HDU – 4305\n知识点：生成树计数：Matrix-Tree定理\n<http://blog.csdn.net/julyana_lin/article/details/8067024>\n\nL - Highways\n来源：SPOJ – HIGH\n知识点：生成树计数\n<http://blog.csdn.net/gatevin/article/details/48051879>\n\nM - Alice's Chance\n来源：POJ – 1698\n知识点：二分图多重匹配\n<http://blog.csdn.net/l123012013048/article/details/47295503>\n\nN - 奔小康赚大钱\n来源：HDU – 2255\n知识点：二分图最大权匹配、KM算法等\n<http://blog.csdn.net/sr_19930829/article/details/40650359>\n\n<h3 id=\"1.2.5\">7-26 代码强化训练5 《葵花宝典》P96-121</h3>\n\nA - Dual Core CPU\n来源：POJ - 3469\n知识点：网络流：SAP算法等\n<http://blog.csdn.net/discreeter/article/details/51591775>\n\nB - Drainage Ditches\n来源：POJ - 1273\n知识点：网络流：ISAP算法等\n<http://blog.csdn.net/lianai911/article/details/44964361>\n\n\nC - Island Transport\n来源：HDU - 4280\n知识点：网络流：ISAP算法、Dinic等\n<http://blog.csdn.net/wubaizhe/article/details/74046372>\n\nD - Minimum Cost\n来源：POJ - 2516\n知识点：最小费用最大流等\n<http://blog.csdn.net/lyy289065406/article/details/6742534>\n<http://blog.csdn.net/u014552756/article/details/49977887>\n\nE - Peaceful Commission\n来源：HDU - 1814\n知识点：2-SAT等\n<http://m.blog.csdn.net/EzCUfST/article/details/47008027>\n\nF - Wedding\n来源：POJ - 3648\n知识点：2-SAT等\n<http://blog.csdn.net/sdj222555/article/details/7718821>\n\nG - Object Clustering\n来源：POJ - 3241\n知识点：莫队算法、曼哈顿最小生成树等\n<http://www.cnblogs.com/mfrbuaa/p/5375000.html>\n\n\nH - Work Scheduling\n来源：URAL - 1099\n知识点：一般图匹配带花树等\n<http://blog.csdn.net/u010660276/article/details/48013013>\n\nI - Nearest Common Ancestors\n来源：POJ - 1330\n知识点：LCA：dft+ST在线算法等\n<http://www.cnblogs.com/kuangbin/archive/2013/09/05/3302493.html>\n\nJ - Closest Common Ancestors\n来源：POJ - 1470\n知识点：LCA：离线Tarjan算法等\n<http://www.cnblogs.com/kuangbin/p/3302571.html>\n\nK - The merchant\n来源：POJ - 3728\n知识点：LCA：倍增法等\n<http://blog.csdn.net/lanshui_yang/article/details/11746513>\n\nL - Intersecting Lines\n来源：POJ - 1269\n知识点：判断线段相交等\n<http://blog.csdn.net/acdreamers/article/details/8811201>\n\nM - Segments\n来源：POJ - 3304\n知识点：直线和线段相交判断等\n<http://www.cnblogs.com/kuangbin/p/3188863.html>\n\nN - The Doors\n来源：POJ - 1556\n知识点：线段交+最短路等\n<http://www.cnblogs.com/kuangbin/p/3189309.html>\n\nO - Area\n来源：POJ – 1654\n知识点：求多边形面积等\n<http://www.cnblogs.com/lv-2012/archive/2012/12/01/2797264.html>\n\n<h3 id=\"1.2.6\">7-28 代码强化训练6 《葵花宝典》P121-152</h3>\n\nA - Card\n来源：HDU - 4350\n知识点：模拟等\n<http://blog.csdn.net/wconvey/article/details/7848235>\n\nB - A Round Peg in a Ground Hole\n来源：POJ - 1584\n知识点：判断凸多边形、判断点在多边形内、判断圆在多边形内等\n<http://www.cnblogs.com/liuxin13/p/4799667.html>\n\nC - Cupid's Arrow\n来源：HDU - 1756\n知识点：判断点在多边形内外等\n<http://blog.csdn.net/lttree/article/details/24301607>\n\nD - Shape of HDU\n来源：HDU - 2108\n知识点：判断凸多边形等\n<http://blog.csdn.net/lttree/article/details/24241987>\n\nE - Wall\n来源：HDU - 1348\n知识点：求凸包周长等\n<http://blog.csdn.net/W1413882708/article/details/52191385>\n\nF - Quoit Design\n来源：HDU - 1007\n知识点：查找平面最近点对等\n<http://blog.csdn.net/sun1956/article/details/8294048>\n\nG - Beauty Contest\n来源：POJ - 2187\n知识点：求解平面最远点对等\n<http://blog.csdn.net/crazy_ac/article/details/10082403>\n\nH - Triangle\n来源：ZOJ - 2419\n知识点：求解平面点集最大三角形等\n<http://blog.csdn.net/zxy_snow/article/details/6595123>\n\nI - The widest road\n来源：HDU - 2823\n知识点：求解两凸包最小距离等\n<http://blog.csdn.net/clover_hxy/article/details/54022026>\n\nJ - Art Gallery\n来源：ZOJ- 1369\n知识点：半平面交等\n<http://blog.csdn.net/l04205613/article/details/6626844>\n\nK - Kindergarten Electiond\n来源：ZOJ-3715\n知识点：枚举、贪心等\n<http://blog.csdn.net/zy691357966/article/details/44853449>\n\nL - Attack on Titans\n来源：ZOJ-3747\n知识点：递推等\n<http://blog.csdn.net/summer__show_/article/details/70243332>\n\nM - Alignment\n来源：HDU - 1950\n知识点：最长上升子序列等\n<http://www.cnblogs.com/blueprintf/p/5773393.html>\n<http://blog.csdn.net/wall_f/article/details/8295812>\n\nN - Game of Connections\n来源：HDU - 1134\n知识点：卡特兰数等\n<http://blog.csdn.net/u013509299/article/details/19758565>\n\nO - Group\n来源：HDU 4638\n知识点：莫队算法、离线线段树等\n<http://blog.csdn.net/xlzhang223/article/details/51439180>\n\nP - Count on a tree II\n来源：SPOJ - COT2\n知识点：树上的莫队算法、树上区间查询等\n<http://blog.csdn.net/htt_h/article/details/47729479>\n\n<h3 id=\"1.3.1\">7-30 Summer 2017 Team Training 1</h3>\n\nA-zoj 3878 Convert QWERTY to Dvorak 暴力\n<http://blog.csdn.net/loy_184548/article/details/50592408>\n\nB-codeforces 765E Tree Folding 拓扑排序\n<http://blog.csdn.net/hjt_fathomless/article/details/56013633>\n\nC-Gym 101063K Dire, Dire Docks 构造\n\nD-hdu 5875 Function 二分+rmq\n<http://blog.csdn.net/miracle_ma/article/details/52504922>\n\nE-poj 3244 Difference between Triplets 数学公式推导\n<http://blog.csdn.net/acdreamers/article/details/12236319>\n\nF-hdu 5724 Chess 博弈+sg函数\n<http://blog.csdn.net/Danliwoo/article/details/51968789>\n\nG-gym 101156L Super 2048 模拟\n\nH-hdu 6031Innumerable Ancestors 二分+lca\n<http://blog.csdn.net/oranges_c/article/details/71698555>\n\nI-hdu 1538 A Puzzle for Pirates 经典的海盗分金推理\n<http://blog.csdn.net/acm_cxlove/article/details/7853916>\n\nJ-hdu 5791 Two dp\n<http://blog.csdn.net/s_black/article/details/52102668>\n\n<h3 id=\"1.3.2\">7-31 Summer 2017 Team Training 2</h3>\n\nA.Coins 贪心\n<http://www.cnblogs.com/autsky-jadek/p/7226706.html?utm_source=itdadao&utm_medium=referral>\n\nB.Business Cycle 贪心、二分\n<http://www.cnblogs.com/shimu/p/5948176.html>\n\nC.Triangle Formation 水题\n<http://blog.csdn.net/code12hour/article/details/51990060>\n\nD.Powerful array 莫队算法\n<http://blog.csdn.net/zearot/article/details/50835130>\n\nE.Profact 暴搜、剪枝（STL）\n<http://blog.csdn.net/lmhacm/article/details/61416851>\n\nF.Kevin's Problem 组合数学\n<http://mcginn.lofter.com/post/1d50332c_7f59909>\n\nG.Sequence Value Dp\n<https://media.hihocoder.com/contests/challenge29/sol.pdf>\n<http://blog.csdn.net/werkeytom_ftd/article/details/73740771>\n\nH.Snakes capturing the Mongoose Cities 树形dp\n<https://discuss.codechef.com/questions/100120/captciti-editorial>\n\nI.Robot Racing\n<http://blog.csdn.net/KEYboarderQQ/article/details/57135492>\n\nJ.codechef SNGRAPH 简单图论\n<https://discuss.codechef.com/questions/99946/sngraph-editorial>\n\n<h3 id=\"1.3.3\">8-4 Summer 2017 Team Training 3</h3>\n\nA.OO's Sequence  约数枚举\n<http://blog.csdn.net/maxichu/article/details/47611819>\n\nB.LRU  概率+状态压缩DP\n<http://blog.csdn.net/clove_unique/article/details/62233833>\n\nC.Devu and Flowers  组合数学+容斥\n<http://hzwer.com/3810.html>\n\nD.Just a Hook  线段树区间更新\n<http://blog.csdn.net/libin56842/article/details/13511181>\n\nE.The Frog's Games  二分+贪心\n<http://blog.csdn.net/non_cease/article/details/6769814>\n\nF.A Simple Math Problem  矩阵快速幂\n<http://blog.csdn.net/efreet9539/article/details/24538071>\n\nG.翻纸牌游戏  DFS\n<http://blog.csdn.net/libin56842/article/details/14104989>\n\nH.Unlucky Strings  快速幂+KMP\n<http://blog.csdn.net/u014664226/article/details/49110349>\n\nI.Get Out!  计算几何\n<http://blog.csdn.net/diary_yang/article/details/13880547>\n\nJ.Cracking' RSA  高斯消元\n<http://blog.csdn.net/ok_again/article/details/13776037>\n\n<h3 id=\"1.3.4\">8-6 Summer 2017 Team Training 4</h3>\n\nA. LCM from 1 to n  节省空间的素数筛法\n<http://blog.csdn.net/whyorwhnt/article/details/9397289>\n\nB. Antiarithmetic? 枚举等差数列\n<http://blog.csdn.net/keshuai19940722/article/details/18803443>\n\nC. What a Ridiculous Election  bfs预处理\n<http://blog.csdn.net/keyboardmagician/article/details/53246315>\n\nD. Jogging Trails   欧拉回路+状压DP\n<http://blog.csdn.net/no__stop/article/details/16943929>\n\nE.  Pocky  凑数\n<http://www.oyohyee.com/post/HDU/5984.html>\n\nF.  Alice and Bob 博弈找规律\n<http://m.blog.csdn.net/xlzhang223/article/details/51755303>\n\nG. zxa and leaf   二分+dfs\n<http://blog.csdn.net/hjt_fathomless/article/details/51413061>\n\nH.  连接的管道\n<http://www.bubuko.com/infodetail-1044544.html>\n\nI.  Caocao's Bridges\n<http://blog.csdn.net/mengzhengnan/article/details/11856435>\n\nJ . Communication System\n<http://www.cnblogs.com/nicetomeetu/p/5152291.html>\n\n<h3 id=\"1.3.5\">8-7 Summer 2017 Team Training 5</h3>\n\nA题 hdu 5819 概率dp\n<http://blog.csdn.net/v5zsq/article/details/52372939>\n\nB题 poj2706 模拟+BFS\n<http://blog.csdn.net/lyy289065406/article/details/6648663>\n\nC题 poj 1085 博弈+极大极小搜索，剪枝\n<http://blog.csdn.net/acm_cxlove/article/details/7997246>\n\nD题 zoj 1919 欧拉路径的输出\n<http://blog.csdn.net/axuan_k/article/details/45844491>\n\nE题 hdu 3094 博弈sg函数\n<http://blog.csdn.net/Vmurder/article/details/42653129>\n\nF题 zoj 1101 二分\n<http://blog.csdn.net/forever_wjs/article/details/51493515>\n\nG题 poj 3904 容斥原理，莫比乌斯反演\n<http://blog.csdn.net/lianai911/article/details/47609075>\n\nH题 poj 1472 栈模拟\n<http://blog.csdn.net/lyy289065406/article/details/6648640>\n\n<h3 id=\"1.4.1\">8-2 Summer 2017 Individual Training 1</h3>\n\nA-hdu 2095 find your present(2) 异或\n<http://blog.csdn.net/dgq8211/article/details/7455722>\n\nB-hdu 4869 Turn the pokers 组合数\n<http://blog.csdn.net/dyx404514/article/details/38239155>\n\nC-hdu 5592 ZYB's Premutation 线段树或树状数组\n<http://blog.csdn.net/lljjccsskk/article/details/50215631>\n\nD-hdu 5636 Shortest Path Floyd+暴力\n<http://blog.csdn.net/liuke19950717/article/details/50923293>\n\nE-hdu 3038 How Many Answers Are Wrong 并查集\n<http://blog.csdn.net/backforward/article/details/51889011>\n\nF-poj 3318 Matrix Multiplication 随机化\n<http://blog.csdn.net/sr_19930829/article/details/38236769>\n\nG-Codeforces 739B Alyona and a tree dfs + 二分\n<http://blog.csdn.net/harlow_cheng/article/details/53687480>\n\nH-csu 1473 递增子序列 离散化+树状数组\n\nI-hdu 5742 It's All In The Mind 贪心\n<http://blog.csdn.net/helloiamclh/article/details/52002580>\n\nJ-UVA 11210 Chinese Mahjong 暴力搜索\n<http://blog.csdn.net/keshuai19940722/article/details/10034505>\n\n<h3 id=\"1.4.2\">8-9 Summer 2017 Individual Training 2</h3>\n\nA - 渐变字符串 UESTC - 1510 贪心水题\n<http://blog.csdn.net/wyk1823376647/article/details/66478566>\n\nB - PolandBall and Game CodeForces - 755B 博弈水题\n<http://www.cnblogs.com/tyty-Somnuspoppy/p/6294030.html>\n\nC - Rikka with Tree HihoCoder - 1453 动态规划\n<http://blog.csdn.net/qq_28954601/article/details/53872423>\n\nD - 神秘组织的的分数 UESTC - 1707 数学爆搜\n<http://blog.csdn.net/Tribleave/article/details/77070964>\n\nE - Fast Multiplication HihoCoder - 1527 贪心或动态规划\n<http://blog.csdn.net/f_zyj/article/details/73754452>\n\nF - 完美数 51Nod - 1232 数论 数位dp\n<http://blog.csdn.net/u010885899/article/details/51264468>\n\nG - Non-Decreasing Sequence HihoCoder - 1529 优先队列和函数构造\n<https://media.hihocoder.com/contests/challenge29/sol.pdf>\n<http://blog.csdn.net/u014609452/article/details/73740861>\n\nH - 找朋友 51Nod - 1463 线段树\n<http://blog.csdn.net/u010885899/article/details/50211737>\n<http://blog.csdn.net/doyouseeman/article/details/53815828>\n\nI - Word Puzzles  POJ - 1204 字典树 AC自动机\n<http://blog.csdn.net/u013588639/article/details/38406283>\n<http://blog.csdn.net/dan__ge/article/details/51427825>\n\n<h3 id=\"1.5.1\">8-21 Summer 2017 Team Professional Contest 1</h3>\n\n题目来源：\nJAG Practice Contest for ACM-ICPC Asia Regional 2016\n<http://jag2016autumn.contest.atcoder.jp/assignments>\n题解参考：\n<https://post.icpc-camp.org/d/581-jag-practice-contest-for-acm-icpc-asia-regional-2016-hints>\n\n<h3 id=\"1.5.2\">8-23 Summer 2017 Team Professional Contest 2</h3>\n\n题目来源：\n2015 ACM-ICPC Asia EC-Final Contest\n<http://acmicpc.info/wp-content/uploads/2015/12/ecfinal_problems.pdf>\n题解参考：\n<http://www.cnblogs.com/clrs97/p/6136032.html>\n\n<h3 id=\"1.5.3\">8-25 Summer 2017 Team Professional Contest 3</h3>\n\n题目来源：KTU camp DAY1\n题解：Analysis.pptx\n","tags":["algorithm","record"]}]